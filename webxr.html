<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Video Player - WebXR</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #000; color: white; }
        
        /* --- SETUP SCREEN --- */
        #setup { 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; 
            background: #121212; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px;
        }
        #setup.hidden { display: none; }
        
        .setup-container {
            width: 100%; max-width: 360px;
            background: #1e1e1e;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; gap: 15px;
        }

        h2 { margin: 0 0 10px 0; text-align: center; font-size: 22px; color: #fff; }
        
        .radio-group { display: flex; background: #2c2c2c; border-radius: 8px; padding: 4px; }
        .radio-group label {
            flex: 1; text-align: center; padding: 10px; cursor: pointer;
            border-radius: 6px; transition: background 0.2s; font-weight: 500; color: #888;
        }
        .radio-group input { display: none; }
        .radio-group input:checked + label { background: #007BFF; color: white; }

        /* File Input Label */
        .file-upload-label {
            display: block; background: #333; color: #ddd; width: 100%; padding: 12px;
            border-radius: 8px; text-align: center; font-weight: 500; border: 1px dashed #555;
            cursor: pointer; box-sizing: border-box;
        }
        .file-upload-label:active { background: #444; }
        #fileInput { display: none; }

        /* Preview Area */
        .preview-area {
            background: #000; border-radius: 8px; overflow: hidden; 
            height: 200px; display: flex; align-items: center; justify-content: center;
            position: relative; border: 1px solid #333;
        }
        #testVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        #testVideo.active { display: block; }
        .placeholder-text { position: absolute; color: #555; font-size: 14px; pointer-events: none; }
        .preview-area.has-video .placeholder-text { display: none; }

        #status { font-size: 13px; color: #666; text-align: center; height: 16px; }
        #status.success { color: #4CAF50; }
        #status.warning { color: #ff9800; }
        
        button.primary {
            background: #007BFF; color: white; border: none; padding: 14px;
            font-size: 16px; font-weight: bold; border-radius: 8px; cursor: pointer;
            width: 100%; transition: transform 0.1s;
        }
        button.primary:active { transform: scale(0.98); background: #0056b3; }
        button:disabled { background: #333; color: #555; cursor: not-allowed; transform: none; }

        /* --- VR OVERLAY --- */
        #progressOverlay { 
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: rgba(0, 0, 0, 0.45);
            padding: 8px 0; 
            display: none; 
            z-index: 998; 
            transition: opacity 0.3s;
            max-height: 100vh;
            overflow-y: auto;
        }
        #progressOverlay.visible { display: flex; }
        #progressOverlay.fading { opacity: 0; }
        .eye-controls { 
            width: 50%; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 0 6px; 
            box-sizing: border-box; 
        }
        
        .progressBar { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer; margin-bottom: 4px; position: relative; }
        .progressFill { height: 100%; background: #007BFF; border-radius: 5px; width: 0%; pointer-events: none; }
        .timeDisplay { font-size: 11px; color: #aaa; margin-bottom: 4px; font-family: monospace; }
        
        .controls-row { display: flex; justify-content: center; gap: 6px; margin-bottom: 3px; width: 100%; }
        .btn-icon {
            background: rgba(255,255,255,0.15); border: none; color: #eee;
            width: 36px; height: 36px; border-radius: 50%; font-size: 14px;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            flex-shrink: 0;
        }
        .btn-icon:active { background: rgba(255,255,255,0.4); }
        .btn-pill {
            background: rgba(255,255,255,0.15); border: none; color: #eee;
            height: 28px; padding: 0 12px; border-radius: 14px; font-size: 10px; cursor: pointer;
            white-space: nowrap; flex-shrink: 0;
        }
        .btn-pill:active { background: rgba(255,255,255,0.4); }
        .section-label {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 2px 0 2px 0;
        }
    </style>
</head>
<body>

    <div id="setup">
        <div class="setup-container">
            <h2>WebXR VR Player</h2>
            <div class="radio-group">
                <input type="radio" id="mode2d" name="mode" value="2d" checked><label for="mode2d">2D Video</label>
                <input type="radio" id="mode3d" name="mode" value="3d"><label for="mode3d">3D SBS</label>
            </div>
            
            <label for="fileInput" class="file-upload-label" id="fileLabel">Tap to Select Video File</label>
            <input type="file" id="fileInput" accept="video/*">

            <div class="preview-area" id="previewArea">
                <span class="placeholder-text">Preview</span>
                <video id="testVideo" controls playsinline webkit-playsinline></video>
            </div>
            
            <div id="status">Waiting for file...</div>
            <button id="startBtn" class="primary" disabled>ENTER VR</button>
        </div>
    </div>

    <div id="progressOverlay">
        <!-- Left Eye -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            
            <div class="section-label">Playback</div>
            <div class="controls-row">
                <button class="btn-icon rewind-btn">↺</button>
                <button class="btn-icon play-pause-btn">▶</button>
                <button class="btn-icon forward-btn">↻</button>
            </div>
            
            <div class="section-label">Zoom</div>
            <div class="controls-row">
                <button class="btn-icon zoom-out-btn">−</button>
                <button class="btn-pill zoom-reset-btn">RESET</button>
                <button class="btn-icon zoom-in-btn">+</button>
            </div>
            
            <div class="section-label">Screen Distance</div>
            <div class="controls-row">
                <button class="btn-icon dist-dec-btn">−</button>
                <button class="btn-pill dist-reset-btn">RESET</button>
                <button class="btn-icon dist-inc-btn">+</button>
            </div>
            
            <div class="section-label">Screen Size</div>
            <div class="controls-row">
                <button class="btn-icon size-dec-btn">−</button>
                <button class="btn-pill size-reset-btn">RESET</button>
                <button class="btn-icon size-inc-btn">+</button>
            </div>
            
            <div class="section-label">Screen Position</div>
            <div class="controls-row">
                <button class="btn-icon pos-down-btn">↓</button>
                <button class="btn-pill pos-reset-btn">RESET</button>
                <button class="btn-icon pos-up-btn">↑</button>
            </div>
        </div>
        
        <!-- Right Eye -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            
            <div class="section-label">Playback</div>
            <div class="controls-row">
                <button class="btn-icon rewind-btn">↺</button>
                <button class="btn-icon play-pause-btn">▶</button>
                <button class="btn-icon forward-btn">↻</button>
            </div>
            
            <div class="section-label">Zoom</div>
            <div class="controls-row">
                <button class="btn-icon zoom-out-btn">−</button>
                <button class="btn-pill zoom-reset-btn">RESET</button>
                <button class="btn-icon zoom-in-btn">+</button>
            </div>
            
            <div class="section-label">Screen Distance</div>
            <div class="controls-row">
                <button class="btn-icon dist-dec-btn">−</button>
                <button class="btn-pill dist-reset-btn">RESET</button>
                <button class="btn-icon dist-inc-btn">+</button>
            </div>
            
            <div class="section-label">Screen Size</div>
            <div class="controls-row">
                <button class="btn-icon size-dec-btn">−</button>
                <button class="btn-pill size-reset-btn">RESET</button>
                <button class="btn-icon size-inc-btn">+</button>
            </div>
            
            <div class="section-label">Screen Position</div>
            <div class="controls-row">
                <button class="btn-icon pos-down-btn">↓</button>
                <button class="btn-pill pos-reset-btn">RESET</button>
                <button class="btn-icon pos-up-btn">↑</button>
            </div>
        </div>
    </div>

    <script>
        const fileInput = document.getElementById('fileInput');
        const fileLabel = document.getElementById('fileLabel');
        const testVideo = document.getElementById('testVideo');
        const previewArea = document.getElementById('previewArea');
        const startBtn = document.getElementById('startBtn');
        const setupDiv = document.getElementById('setup');
        const status = document.getElementById('status');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressFills = document.querySelectorAll('.progressFill');
        const timeDisplays = document.querySelectorAll('.timeDisplay');
        const playPauseBtns = document.querySelectorAll('.play-pause-btn');

        let camera, scene, renderer;
        let video, videoTexture;
        let mode = '2d', isPlaying = false, videoURL = null;
        let hideOverlayTimer = null;
        let currentZoomIndex = 4;
        
        let screenDistance = 3.0;
        let screenWidth = 6.0;
        let screenYPosition = 0.0;
        const defaultDistance = 3.0;
        const defaultWidth = 6.0;
        const defaultYPosition = 0.0;
        let screenMeshes = [];

        const zoomLevels = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0];

        fileInput.addEventListener('change', handleFileSelect);
        startBtn.addEventListener('click', startVR);

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            fileLabel.textContent = file.name;
            if (videoURL) URL.revokeObjectURL(videoURL);
            videoURL = URL.createObjectURL(file);
            testVideo.src = videoURL;
            testVideo.classList.add('active');
            previewArea.classList.add('has-video');
            mode = document.querySelector('input[name="mode"]:checked').value;
            testVideo.addEventListener('loadedmetadata', function() {
                status.textContent = `Ready: ${testVideo.videoWidth}x${testVideo.videoHeight}`;
                status.className = 'status success';
                startBtn.disabled = false;
            }, { once: true });
        }

        async function startVR() {
            if (!videoURL) return;
            testVideo.pause();

            // Check WebXR support
            if (!navigator.xr) {
                status.textContent = 'WebXR not supported in this browser';
                status.className = 'status warning';
                return;
            }

            const supported = await navigator.xr.isSessionSupported('immersive-vr');
            if (!supported) {
                status.textContent = 'VR not available on this device';
                status.className = 'status warning';
                return;
            }

            setupDiv.classList.add('hidden');
            disposeResources();
            initVR();
        }

        function disposeResources() {
            if (videoTexture) { videoTexture.dispose(); videoTexture = null; }
            if (video) { video.pause(); video.src = ''; video.load(); video = null; }
            if (renderer) {
                renderer.dispose();
                if (renderer.domElement && renderer.domElement.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                }
                renderer = null;
            }
            screenMeshes = [];
            scene = null;
        }

        async function initVR() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 0);

            // Create video element
            video = document.createElement('video');
            video.src = videoURL;
            video.loop = false;
            video.muted = false;
            video.playsinline = true;
            video.setAttribute('webkit-playsinline', '');
            video.crossOrigin = 'anonymous';

            video.addEventListener('loadeddata', async function() {
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.generateMipmaps = false;

                // Setup renderer with WebXR
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;
                document.body.appendChild(renderer.domElement);

                createScreenMeshes();
                scene.add(camera);

                // Request WebXR session
                try {
                    const session = await navigator.xr.requestSession('immersive-vr', {
                        optionalFeatures: ['local-floor', 'bounded-floor']
                    });
                    
                    await renderer.xr.setSession(session);

                    // Setup session event listeners
                    session.addEventListener('end', onSessionEnd);

                    // Setup controls
                    window.addEventListener('resize', onResize);
                    progressOverlay.addEventListener('click', handleControls);
                    video.addEventListener('timeupdate', updateProgress);

                    // Start video and animation loop
                    await video.play();
                    isPlaying = true;
                    updatePlayPauseButtons();
                    
                    // Start render loop
                    renderer.setAnimationLoop(animate);
                    
                    showOverlay();
                } catch (error) {
                    console.error('Failed to start VR session:', error);
                    status.textContent = 'Failed to start VR: ' + error.message;
                    status.className = 'status warning';
                    setupDiv.classList.remove('hidden');
                }
            });
            video.load();
        }

        function createScreenMeshes() {
            // Clean up old meshes
            screenMeshes.forEach(mesh => {
                camera.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            screenMeshes = [];

            const aspect = mode === '3d' ? (video.videoWidth / 2) / video.videoHeight : video.videoWidth / video.videoHeight;
            const zoom = zoomLevels[currentZoomIndex];
            const width = screenWidth / zoom;
            const height = width / aspect;
            const distance = screenDistance;

            if (mode === '2d') {
                // Single screen for both eyes
                const geometry = new THREE.PlaneGeometry(width, height);
                const material = new THREE.MeshBasicMaterial({ 
                    map: videoTexture, 
                    side: THREE.DoubleSide,
                    toneMapped: false
                });
                const screenMesh = new THREE.Mesh(geometry, material);
                screenMesh.position.set(0, screenYPosition, -distance);
                camera.add(screenMesh);
                screenMeshes.push(screenMesh);
            } else {
                // Separate screens for each eye (3D SBS)
                const geometry = new THREE.PlaneGeometry(width, height);
                
                // Left eye screen
                const matL = new THREE.ShaderMaterial({
                    uniforms: { 
                        tex: { value: videoTexture }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tex;
                        varying vec2 vUv;
                        void main() {
                            // Sample left half of video
                            vec2 uv = vec2(vUv.x * 0.5, vUv.y);
                            gl_FragColor = texture2D(tex, uv);
                        }
                    `,
                    side: THREE.DoubleSide,
                    toneMapped: false
                });
                const screenL = new THREE.Mesh(geometry, matL);
                screenL.position.set(0, screenYPosition, -distance);
                screenL.layers.set(1); // Only visible to left eye
                camera.add(screenL);
                screenMeshes.push(screenL);

                // Right eye screen
                const matR = new THREE.ShaderMaterial({
                    uniforms: { 
                        tex: { value: videoTexture }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        void main() {
                            vUv = uv;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform sampler2D tex;
                        varying vec2 vUv;
                        void main() {
                            // Sample right half of video
                            vec2 uv = vec2(vUv.x * 0.5 + 0.5, vUv.y);
                            gl_FragColor = texture2D(tex, uv);
                        }
                    `,
                    side: THREE.DoubleSide,
                    toneMapped: false
                });
                const screenR = new THREE.Mesh(geometry, matR);
                screenR.position.set(0, screenYPosition, -distance);
                screenR.layers.set(2); // Only visible to right eye
                camera.add(screenR);
                screenMeshes.push(screenR);
            }
        }

        function updateScreenMeshes() {
            if (!video || !videoTexture) return;
            createScreenMeshes();
        }

        function animate(time, frame) {
            if (frame) {
                const session = renderer.xr.getSession();
                if (session) {
                    // Update camera layers for stereo rendering
                    if (mode === '3d') {
                        // In 3D mode, we need both layers visible
                        camera.layers.enable(1);
                        camera.layers.enable(2);
                    } else {
                        // In 2D mode, default layer
                        camera.layers.enable(0);
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        function onSessionEnd() {
            setupDiv.classList.remove('hidden');
            if (video) {
                video.pause();
                isPlaying = false;
                updatePlayPauseButtons();
            }
            disposeResources();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePlayPauseButtons() {
            playPauseBtns.forEach(btn => { btn.textContent = isPlaying ? '||' : '▶'; });
        }

        function togglePlayPause() {
            if (!video) return;
            if (isPlaying) {
                video.pause();
                isPlaying = false;
            } else {
                video.play();
                isPlaying = true;
            }
            updatePlayPauseButtons();
            showOverlay();
        }

        function seekVideo(e, barEl) {
            if (!video) return;
            const rect = barEl.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            video.currentTime = pos * video.duration;
            showOverlay();
        }

        function seekRelative(seconds) {
            if (!video) return;
            video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + seconds));
            showOverlay();
        }

        function updateProgress() {
            if (!video) return;
            const percent = (video.currentTime / video.duration) * 100;
            progressFills.forEach(fill => { fill.style.width = percent + '%'; });
            const format = (t) => {
                const m = Math.floor(t / 60);
                const s = Math.floor(t % 60).toString().padStart(2, '0');
                return `${m}:${s}`;
            };
            const timeText = `${format(video.currentTime)} / ${format(video.duration || 0)}`;
            timeDisplays.forEach(display => { display.textContent = timeText; });
        }

        function showOverlay() {
            progressOverlay.classList.add('visible');
            progressOverlay.classList.remove('fading');
            if (hideOverlayTimer) clearTimeout(hideOverlayTimer);
            hideOverlayTimer = setTimeout(() => {
                if (isPlaying) hideOverlay();
            }, 3000);
        }

        function hideOverlay() {
            progressOverlay.classList.add('fading');
            setTimeout(() => {
                progressOverlay.classList.remove('visible');
            }, 300);
        }

        function adjustZoom(direction) {
            if (direction > 0) currentZoomIndex = Math.min(zoomLevels.length - 1, currentZoomIndex + 1);
            else currentZoomIndex = Math.max(0, currentZoomIndex - 1);
            updateScreenMeshes();
            showOverlay();
        }

        function resetZoom() {
            currentZoomIndex = 4;
            updateScreenMeshes();
            showOverlay();
        }

        function adjustDistance(direction) {
            screenDistance += direction * 0.2;
            screenDistance = Math.max(1.0, Math.min(10.0, screenDistance));
            updateScreenMeshes();
            showOverlay();
        }

        function resetDistance() {
            screenDistance = defaultDistance;
            updateScreenMeshes();
            showOverlay();
        }

        function adjustSize(direction) {
            screenWidth += direction * 0.5;
            screenWidth = Math.max(2.0, Math.min(20.0, screenWidth));
            updateScreenMeshes();
            showOverlay();
        }

        function resetSize() {
            screenWidth = defaultWidth;
            updateScreenMeshes();
            showOverlay();
        }

        function adjustPosition(direction) {
            screenYPosition += direction * 0.2;
            screenYPosition = Math.max(-3.0, Math.min(3.0, screenYPosition));
            updateScreenMeshes();
            showOverlay();
        }

        function resetPosition() {
            screenYPosition = defaultYPosition;
            updateScreenMeshes();
            showOverlay();
        }

        function handleControls(e) {
            e.stopPropagation();
            const target = e.target.closest('button, .progressBar');
            if (!target) return;

            if (target.matches('.progressBar')) {
                seekVideo(e, target);
                return;
            }

            const cl = target.classList;
            if (cl.contains('play-pause-btn')) togglePlayPause();
            else if (cl.contains('rewind-btn')) seekRelative(-10);
            else if (cl.contains('forward-btn')) seekRelative(10);
            else if (cl.contains('zoom-in-btn')) adjustZoom(1);
            else if (cl.contains('zoom-out-btn')) adjustZoom(-1);
            else if (cl.contains('zoom-reset-btn')) resetZoom();
            else if (cl.contains('dist-inc-btn')) adjustDistance(1);
            else if (cl.contains('dist-dec-btn')) adjustDistance(-1);
            else if (cl.contains('dist-reset-btn')) resetDistance();
            else if (cl.contains('size-inc-btn')) adjustSize(1);
            else if (cl.contains('size-dec-btn')) adjustSize(-1);
            else if (cl.contains('size-reset-btn')) resetSize();
            else if (cl.contains('pos-up-btn')) adjustPosition(1);
            else if (cl.contains('pos-down-btn')) adjustPosition(-1);
            else if (cl.contains('pos-reset-btn')) resetPosition();
        }
    </script>
</body>
</html>
