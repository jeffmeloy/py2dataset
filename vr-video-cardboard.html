<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Video Player - Final Optimized</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* CORE LAYOUT */
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif; }
        
        /* SETUP SCREEN */
        #setup { 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; 
            background: #121212; display: flex; align-items: center; justify-content: center; padding: 20px;
        }
        #setup.hidden { display: none; }
        
        .setup-container {
            width: 100%; max-width: 380px; background: #1e1e1e; border-radius: 16px; padding: 24px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 16px;
        }
        
        h2 { margin: 0; text-align: center; font-size: 20px; letter-spacing: 1px; color: #fff; text-transform: uppercase; }

        /* INPUTS */
        .radio-group { display: flex; background: #2c2c2c; border-radius: 8px; padding: 4px; }
        .radio-group label { flex: 1; text-align: center; padding: 12px; cursor: pointer; border-radius: 6px; transition: 0.2s; font-weight: 600; color: #888; font-size: 14px; }
        .radio-group input { display: none; }
        .radio-group input:checked + label { background: #007BFF; color: white; }

        .file-btn { display: block; background: #333; color: #ddd; width: 100%; padding: 16px; border-radius: 8px; text-align: center; font-weight: 600; border: 1px dashed #555; cursor: pointer; box-sizing: border-box; transition: 0.2s; }
        .file-btn:active { background: #444; transform: scale(0.98); }
        #fileInput { display: none; }

        /* PREVIEW */
        .preview-box { background: #000; border-radius: 8px; height: 200px; display: flex; align-items: center; justify-content: center; position: relative; border: 1px solid #333; overflow: hidden; }
        #testVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        #testVideo.active { display: block; }
        .preview-text { position: absolute; color: #555; font-size: 14px; pointer-events: none; }

        /* ACTIONS */
        #status { font-size: 12px; color: #666; text-align: center; height: 14px; }
        #status.success { color: #4CAF50; }
        .primary-btn { background: #007BFF; color: white; border: none; padding: 16px; font-size: 16px; font-weight: bold; border-radius: 8px; cursor: pointer; width: 100%; transition: 0.1s; text-transform: uppercase; letter-spacing: 1px; }
        .primary-btn:active { transform: scale(0.98); background: #0056b3; }
        .primary-btn:disabled { background: #333; color: #555; cursor: not-allowed; transform: none; }

        /* VR OVERLAY */
        #progressOverlay { 
            position: fixed; bottom: 0; left: 0; right: 0; background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0)); 
            padding: 20px 0; display: none; z-index: 998; transition: opacity 0.3s; 
            will-change: opacity; /* GPU Hint */
        }
        #progressOverlay.visible { display: flex; }
        #progressOverlay.fading { opacity: 0; }
        
        .eye-ui { width: 50%; display: flex; flex-direction: column; align-items: center; padding: 0 10px; box-sizing: border-box; }
        
        .bar-track { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer; margin-bottom: 8px; overflow: hidden; }
        .bar-fill { height: 100%; background: #007BFF; width: 0%; pointer-events: none; will-change: width; }
        
        .time-txt { font-size: 12px; color: #ccc; margin-bottom: 8px; font-family: monospace; }
        
        .row { display: flex; justify-content: center; gap: 12px; margin-bottom: 6px; width: 100%; }
        .ico-btn { background: rgba(255,255,255,0.15); border: none; color: #eee; width: 42px; height: 42px; border-radius: 50%; font-size: 18px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: background 0.1s; }
        .ico-btn:active { background: rgba(255,255,255,0.4); }
        .pill-btn { background: rgba(255,255,255,0.15); border: none; color: #eee; height: 34px; padding: 0 18px; border-radius: 17px; font-size: 12px; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <!-- SETUP UI -->
    <div id="setup">
        <div class="setup-container">
            <h2>VR Player</h2>
            
            <div class="radio-group">
                <input type="radio" id="mode2d" name="mode" value="2d" checked><label for="mode2d">2D Video</label>
                <input type="radio" id="mode3d" name="mode" value="3d"><label for="mode3d">3D SBS</label>
            </div>

            <label for="fileInput" class="file-btn" id="fileLabel">Select Video File</label>
            <input type="file" id="fileInput" accept="video/*">

            <div class="preview-box" id="previewBox">
                <span class="preview-text" id="previewText">No video loaded</span>
                <video id="testVideo" controls playsinline webkit-playsinline></video>
            </div>
            
            <div id="status">Ready</div>
            <button id="startBtn" class="primary-btn" disabled>Enter VR</button>
        </div>
    </div>

    <!-- VR UI -->
    <div id="progressOverlay">
        <div class="eye-ui">
            <div class="bar-track"><div class="bar-fill"></div></div>
            <div class="time-txt">0:00 / 0:00</div>
            <div class="row">
                <button class="ico-btn pan-left-btn">&larr;</button>
                <button class="ico-btn pan-center-btn">⦾</button>
                <button class="ico-btn pan-right-btn">&rarr;</button>
            </div>
            <div class="row">
                <button class="ico-btn rewind-btn">↺</button>
                <button class="ico-btn play-pause-btn">▶</button>
                <button class="ico-btn forward-btn">↻</button>
            </div>
            <div class="row">
                <button class="ico-btn zoom-out-btn">-</button>
                <button class="pill-btn zoom-reset-btn">ZOOM</button>
                <button class="ico-btn zoom-in-btn">+</button>
            </div>
        </div>
        <div class="eye-ui">
            <div class="bar-track"><div class="bar-fill"></div></div>
            <div class="time-txt">0:00 / 0:00</div>
            <div class="row">
                <button class="ico-btn pan-left-btn">&larr;</button>
                <button class="ico-btn pan-center-btn">⦾</button>
                <button class="ico-btn pan-right-btn">&rarr;</button>
            </div>
            <div class="row">
                <button class="ico-btn rewind-btn">↺</button>
                <button class="ico-btn play-pause-btn">▶</button>
                <button class="ico-btn forward-btn">↻</button>
            </div>
            <div class="row">
                <button class="ico-btn zoom-out-btn">-</button>
                <button class="pill-btn zoom-reset-btn">ZOOM</button>
                <button class="ico-btn zoom-in-btn">+</button>
            </div>
        </div>
    </div>

    <!-- OPTIMIZED SHADERS -->
    <script id="vertexShader" type="x-shader/x-vertex">
        precision highp float; /* Optimization: Explicit precision */
        varying vec2 vUv;
        void main() { 
            vUv = uv; 
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
        }
    </script>

    <script id="fragmentShaderDistortion" type="x-shader/x-fragment">
        precision highp float; /* Optimization: Prevent banding */
        uniform sampler2D tDiffuse;
        uniform float k1;
        uniform float k2;
        uniform float headYawOffset;
        uniform float headPitchOffset;
        uniform float manualPanOffset;
        uniform float manualTiltOffset;
        uniform float zoomLevel;
        varying vec2 vUv;

        // Standard Lens Distortion Formula
        vec2 distort(vec2 p) {
            vec2 center = vec2(0.5, 0.5);
            vec2 v = p - center;
            float r2 = dot(v, v);
            return center + v * (1.0 + r2 * (k1 + k2 * r2));
        }

        void main() {
            vec2 eyeCenter = vec2(0.5, 0.5);
            vec2 distortedUV = distort(vUv);
            
            // Apply Transforms
            vec2 uv = (distortedUV - eyeCenter) / zoomLevel;
            uv.x += headYawOffset + manualPanOffset;
            uv.y += headPitchOffset + manualTiltOffset;
            uv += eyeCenter;

            // Hard Clamp to black (Avoids texture wrapping artifacts)
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = texture2D(tDiffuse, uv);
            }
        }
    </script>

    <script>
        // --- UI REFERENCES ---
        const el = (id) => document.getElementById(id);
        const qAll = (sel) => document.querySelectorAll(sel);
        
        const fileInput = el('fileInput'), fileLabel = el('fileLabel'), testVideo = el('testVideo');
        const previewBox = el('previewBox'), previewText = el('previewText');
        const startBtn = el('startBtn'), setupDiv = el('setup'), status = el('status');
        const progressOverlay = el('progressOverlay');
        const progressFills = qAll('.bar-fill'), timeDisplays = qAll('.time-txt'), playPauseBtns = qAll('.play-pause-btn');

        // --- STATE ---
        let camera, scene, renderer, effect;
        let video, videoTexture, orientationTracker;
        let mode = '2d', isPlaying = false, videoURL = null;
        let hideOverlayTimer = null, currentZoomIndex = 4;
        let manualPanX = 0, manualPanY = 0;
        let headYaw = 0, headPitch = 0, yawOffset = 0, pitchOffset = 0;
        let lastUpdateTime = 0;
        const zoomLevels = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.2, 2.4, 2.6, 2.8, 3.0, 3.2, 3.4, 3.6, 3.8, 4.0];

        // --- SETUP HANDLERS ---
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            fileLabel.textContent = file.name;
            if (videoURL) URL.revokeObjectURL(videoURL);
            videoURL = URL.createObjectURL(file);
            
            testVideo.src = videoURL;
            testVideo.classList.add('active');
            previewText.style.display = 'none';
            mode = document.querySelector('input[name="mode"]:checked').value;

            testVideo.addEventListener('loadedmetadata', () => {
                status.textContent = `Video Loaded: ${testVideo.videoWidth}x${testVideo.videoHeight}`;
                status.className = 'status success';
                startBtn.disabled = false;
            }, { once: true });
        });

        startBtn.addEventListener('click', async () => {
            if (!videoURL) return;
            testVideo.pause(); // Stop preview
            
            // Request Permissions
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
            }

            // Fullscreen & Lock
            const d = document.documentElement;
            if (d.requestFullscreen) d.requestFullscreen();
            else if (d.webkitRequestFullscreen) d.webkitRequestFullscreen();
            
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }

            setTimeout(() => {
                setupDiv.classList.add('hidden');
                disposeResources();
                initVR();
            }, 100);
        });

        function disposeResources() {
            if (videoTexture) { videoTexture.dispose(); videoTexture = null; }
            if (video) { video.pause(); video.src = ''; video.load(); video = null; }
            if (orientationTracker) { orientationTracker.disconnect(); orientationTracker = null; }
            if (effect) { effect.dispose(); effect = null; }
            if (renderer) { renderer.dispose(); if (renderer.domElement.parentNode) renderer.domElement.parentNode.removeChild(renderer.domElement); renderer = null; }
            scene = null;
        }

        function initVR() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 0);

            // 2. Video Setup
            video = document.createElement('video');
            video.src = videoURL;
            video.loop = false;
            video.muted = false; // Audio is controlled by device volume
            video.playsinline = true;
            video.setAttribute('webkit-playsinline', '');

            video.addEventListener('loadeddata', () => {
                // Optimization: RGBFormat saves bandwidth (no alpha channel needed for video)
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;
                videoTexture.generateMipmaps = false; 
                videoTexture.format = THREE.RGBFormat; 

                // 3. Renderer Setup (High Performance)
                renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel density
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
                // Enable Anisotropy if supported (sharper angles)
                const maxAniso = renderer.capabilities.getMaxAnisotropy();
                if(maxAniso > 1) videoTexture.anisotropy = maxAniso;

                // 4. Screen Geometry
                const aspect = mode === '3d' ? (video.videoWidth / 2) / video.videoHeight : video.videoWidth / video.videoHeight;
                const height = 6 / aspect;
                const distance = -2.5;

                if (mode === '2d') {
                    const mesh = new THREE.Mesh(
                        new THREE.PlaneGeometry(6, height), 
                        new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide })
                    );
                    mesh.position.z = distance;
                    camera.add(mesh);
                } else {
                    // Efficient Shader Materials for 3D Split
                    const createEye = (layer, offsetX) => {
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(6, height),
                            new THREE.ShaderMaterial({
                                uniforms: { tex: { value: videoTexture } },
                                vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                                fragmentShader: `precision highp float; uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x * 0.5 + ${offsetX}, vUv.y)); }`,
                                side: THREE.DoubleSide
                            })
                        );
                        mesh.position.z = distance;
                        mesh.layers.set(layer);
                        return mesh;
                    };
                    camera.add(createEye(1, 0.0)); // Left
                    camera.add(createEye(2, 0.5)); // Right
                }
                scene.add(camera);

                // 5. Effects & Trackers
                effect = new THREE.StereoEffect(renderer);
                effect.setSize(window.innerWidth, window.innerHeight);
                
                orientationTracker = new OrientationTracker();
                orientationTracker.connect();

                // 6. Listeners
                window.addEventListener('resize', onResize);
                document.addEventListener('click', toggleOverlay);
                video.addEventListener('timeupdate', updateProgress);
                progressOverlay.addEventListener('click', handleControls);

                // 7. Start
                showOverlay();
                video.play().then(() => {
                    isPlaying = true; updatePlayPauseButtons(); animate();
                }).catch(console.error);
            });
            video.load();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (orientationTracker) orientationTracker.update();
            if (effect) effect.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            effect.setSize(window.innerWidth, window.innerHeight);
        }

        // --- CONTROLS LOGIC ---
        const updatePlayPauseButtons = () => playPauseBtns.forEach(b => b.textContent = isPlaying ? '||' : '▶');
        
        function toggleOverlay(e) {
            if (e.target.closest('#progressOverlay')) return;
            if (progressOverlay.classList.contains('visible')) hideOverlay(); else showOverlay();
        }
        
        function showOverlay() {
            progressOverlay.classList.add('visible'); progressOverlay.classList.remove('fading');
            if (hideOverlayTimer) clearTimeout(hideOverlayTimer);
            hideOverlayTimer = setTimeout(() => { if (isPlaying) hideOverlay(); }, 3000);
        }
        
        function hideOverlay() {
            progressOverlay.classList.add('fading');
            setTimeout(() => { progressOverlay.classList.remove('visible'); }, 300);
        }

        function updateProgress() {
            if (!video) return;
            const pct = (video.currentTime / video.duration) * 100;
            progressFills.forEach(f => f.style.width = pct + '%');
            const fmt = (t) => { const m = Math.floor(t/60), s = Math.floor(t%60).toString().padStart(2,'0'); return `${m}:${s}`; };
            const txt = `${fmt(video.currentTime)} / ${fmt(video.duration||0)}`;
            timeDisplays.forEach(d => d.textContent = txt);
        }

        function handleControls(e) {
            e.stopPropagation();
            const t = e.target.closest('button, .bar-track');
            if (!t) return;

            // Seek
            if (t.matches('.bar-track')) {
                const rect = t.getBoundingClientRect();
                video.currentTime = ((e.clientX - rect.left) / rect.width) * video.duration;
                showOverlay(); return;
            }
            
            // Buttons
            const cl = t.classList;
            if (cl.contains('play-pause-btn')) { 
                if(isPlaying) { video.pause(); isPlaying=false; } else { video.play(); isPlaying=true; }
                updatePlayPauseButtons();
            }
            else if (cl.contains('rewind-btn')) video.currentTime = Math.max(0, video.currentTime - 10);
            else if (cl.contains('forward-btn')) video.currentTime = Math.min(video.duration, video.currentTime + 10);
            else if (cl.contains('zoom-in-btn')) adjustZoom(1);
            else if (cl.contains('zoom-out-btn')) adjustZoom(-1);
            else if (cl.contains('zoom-reset-btn')) { currentZoomIndex = 4; showOverlay(); }
            else if (cl.contains('pan-left-btn')) adjustPan(-1);
            else if (cl.contains('pan-right-btn')) adjustPan(1);
            else if (cl.contains('pan-center-btn')) { manualPanX=0; manualPanY=0; yawOffset=headYaw; pitchOffset=headPitch; }
            
            showOverlay();
        }

        const adjustZoom = (d) => currentZoomIndex = Math.max(0, Math.min(zoomLevels.length-1, currentZoomIndex + d));
        const adjustPan = (d) => manualPanX += d * 0.05;

        // --- MATH & ENGINE ---
        function OrientationTracker() {
            this.enabled = false; this.firstReadingTime = null; this.autoCenterTimer = null;
            // Pre-allocated for Zero-GC
            const _euler = new THREE.Euler(), _q = new THREE.Quaternion(), _qCam = new THREE.Quaternion();
            const _qScr = new THREE.Quaternion(), _zAxis = new THREE.Vector3(0,0,1), _vec = new THREE.Vector3(0,0,-1), _res = new THREE.Vector3();
            // Camera Offset (-90 deg X)
            _qCam.setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);

            let device = {}, screenAng = 0;
            const onDev = (e) => device = e;
            const onScr = () => screenAng = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (window.orientation || 0);

            this.connect = () => { onScr(); window.addEventListener('orientationchange', onScr); window.addEventListener('deviceorientation', onDev); this.enabled = true; };
            this.disconnect = () => { window.removeEventListener('orientationchange', onScr); window.removeEventListener('deviceorientation', onDev); this.enabled = false; };
            
            this.update = () => {
                if (!this.enabled) return;
                const now = Date.now(); if (now - lastUpdateTime < 16) return; // 60fps Cap
                if (!device.alpha) return;

                // Convert
                const a = THREE.MathUtils.degToRad(device.alpha), b = THREE.MathUtils.degToRad(device.beta), g = THREE.MathUtils.degToRad(device.gamma);
                const s = THREE.MathUtils.degToRad(screenAng);

                // Rotation Logic
                _euler.set(b, a, -g, 'YXZ');
                _q.setFromEuler(_euler);
                _q.multiply(_qCam); // Rotate camera
                _q.multiply(_qScr.setFromAxisAngle(_zAxis, -s)); // Handle Landscape
                _res.copy(_vec).applyQuaternion(_q); // Get look vector

                const p = Math.asin(_res.y), y = Math.atan2(_res.x, -_res.z);

                // Auto-Center Logic
                if (!this.firstReadingTime) {
                    this.firstReadingTime = now;
                    this.autoCenterTimer = setTimeout(() => { yawOffset = headYaw; pitchOffset = headPitch; }, 800);
                    headYaw = y; headPitch = p;
                } else {
                    headYaw = y; headPitch = p;
                }
                lastUpdateTime = now;
            };
        }

        THREE.StereoEffect = function(renderer) {
            const _stereo = new THREE.StereoCamera(); _stereo.aspect = 0.5;
            
            // Optimization: Limit texture size to 2K (saves VRAM on 4K screens)
            const dpr = window.devicePixelRatio || 1;
            let w = Math.min(Math.floor(window.innerWidth * dpr / 2), 2048);
            let h = Math.min(Math.floor(window.innerHeight * dpr), 2048);

            // Optimization: Disable depth/stencil buffers (video is flat)
            const rtParams = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, depthBuffer: false, stencilBuffer: false };
            let rtL = new THREE.WebGLRenderTarget(w, h, rtParams);
            let rtR = new THREE.WebGLRenderTarget(w, h, rtParams);

            const mat = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null }, k1: { value: 0.22 }, k2: { value: 0.18 },
                    headYawOffset: { value: 0 }, headPitchOffset: { value: 0 },
                    manualPanOffset: { value: 0 }, manualTiltOffset: { value: 0 }, zoomLevel: { value: 1 }
                },
                vertexShader: el('vertexShader').textContent,
                fragmentShader: el('fragmentShaderDistortion').textContent
            });

            const sceneQ = new THREE.Scene();
            const camQ = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            sceneQ.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat));

            // Cached vars to reduce uniform updates
            let cYaw = 0, cPitch = 0, cZoom = 1;

            this.setSize = (nw, nh) => {
                renderer.setSize(nw, nh);
                const ndpr = window.devicePixelRatio || 1;
                const rw = Math.min(Math.floor(nw * ndpr / 2), 2048);
                const rh = Math.min(Math.floor(nh * ndpr), 2048);
                if (rw !== w || rh !== h) {
                    rtL.dispose(); rtR.dispose(); w = rw; h = rh;
                    rtL = new THREE.WebGLRenderTarget(w, h, rtParams);
                    rtR = new THREE.WebGLRenderTarget(w, h, rtParams);
                }
            };

            this.dispose = () => { rtL.dispose(); rtR.dispose(); mat.dispose(); };

            this.render = (scene, camera) => {
                scene.updateMatrixWorld();
                _stereo.update(camera);

                // Render Eyes to Textures
                if (mode === '3d') { _stereo.cameraL.layers.set(1); _stereo.cameraR.layers.set(2); }
                renderer.setRenderTarget(rtL); renderer.clear(); renderer.render(scene, _stereo.cameraL);
                renderer.setRenderTarget(rtR); renderer.clear(); renderer.render(scene, _stereo.cameraR);
                renderer.setRenderTarget(null); 

                // Calc Offsets
                let yd = ((headYaw - yawOffset + Math.PI) % (2*Math.PI)) - Math.PI;
                let pd = Math.max(-1.57, Math.min(1.57, headPitch - pitchOffset));
                
                // Update Uniforms (Only if changed)
                const yUV = -yd * 0.7, pUV = pd * 0.8, zVal = zoomLevels[currentZoomIndex];
                
                if (Math.abs(yUV - cYaw) > 0.0001) { mat.uniforms.headYawOffset.value = yUV; cYaw = yUV; }
                if (Math.abs(pUV - cPitch) > 0.0001) { mat.uniforms.headPitchOffset.value = pUV; cPitch = pUV; }
                if (zVal !== cZoom) { mat.uniforms.zoomLevel.value = zVal; cZoom = zVal; }
                
                mat.uniforms.manualPanOffset.value = manualPanX;
                mat.uniforms.manualTiltOffset.value = manualPanY;

                // Final Composition
                const size = renderer.getSize(new THREE.Vector2());
                renderer.setScissorTest(true);
                
                // Left
                mat.uniforms.tDiffuse.value = rtL.texture;
                renderer.setScissor(0, 0, size.width/2, size.height); 
                renderer.setViewport(0, 0, size.width/2, size.height);
                renderer.render(sceneQ, camQ);
                
                // Right
                mat.uniforms.tDiffuse.value = rtR.texture;
                renderer.setScissor(size.width/2, 0, size.width/2, size.height); 
                renderer.setViewport(size.width/2, 0, size.width/2, size.height);
                renderer.render(sceneQ, camQ);
                
                renderer.setScissorTest(false);
            };
        };
    </script>
</body>
</html>
