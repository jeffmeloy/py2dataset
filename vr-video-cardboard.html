<!DOCTYPE html>
<html>
<head>
    <title>VR Video Player</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="theme-color" content="#000000">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; color: white; }
        #setup { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; background: #1a1a1a; padding: 20px; overflow-y: auto; }
        #setup.hidden { display: none; }
        .section { background: rgba(255,255,255,0.1); padding: 15px; margin: 10px 0; border-radius: 8px; }
        button { background: #007BFF; color: white; border: none; padding: 15px; font-size: 18px; border-radius: 5px; cursor: pointer; margin: 5px 0; width: 100%; }
        button:active { background: #0056b3; }
        button:disabled { background: #555; }
        input[type="file"] { width: 100%; padding: 10px; background: white; color: black; border-radius: 5px; margin: 10px 0; }
        input[type="radio"] { margin: 10px 5px; }
        label { margin-right: 15px; }
        #testVideo { width: 100%; max-width: 400px; background: #000; margin: 10px 0; }
        .status { padding: 10px; margin: 10px 0; background: #000; border-radius: 5px; }
        .success { color: #4CAF50; }
        #progressOverlay { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8); padding: 15px; display: none; z-index: 998; transition: opacity 0.3s; }
        #progressOverlay.visible { display: flex; }
        #progressOverlay.fading { opacity: 0; }
        .eye-controls { width: 50%; display: flex; flex-direction: column; align-items: center; padding: 0 10px; }
        .progressBar { width: 100%; height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; margin-bottom: 10px; }
        .progressFill { height: 100%; background: #007BFF; border-radius: 4px; width: 0%; transition: width 0.1s; }
        .timeDisplay { text-align: center; font-size: 16px; color: white; }
        .controls { display: flex; justify-content: center; gap: 10px; margin-top: 10px; }
        .control-btn { background: rgba(255,255,255,0.2); border: none; color: white; width: 50px; height: 50px; border-radius: 50%; font-size: 20px; cursor: pointer; padding: 0; }
        .control-btn:active { background: rgba(255,255,255,0.4); }
        .zoom-reset { width: 70px; font-size: 14px; }
    </style>
</head>
<body>
    <div id="setup">
        <h2>VR Video 2 Player</h2>
        <div class="section">
            <strong>Video Type</strong><br>
            <input type="radio" id="mode2d" name="mode" value="2d" checked><label for="mode2d">2D</label>
            <input type="radio" id="mode3d" name="mode" value="3d"><label for="mode3d">SBS 3D</label>
        </div>
        <div class="section"><strong>Select Video</strong><br><input type="file" id="fileInput" accept="video/*"></div>
        <div class="section">
            <strong>Test</strong><br>
            <video id="testVideo" controls playsinline webkit-playsinline></video>
            <div id="status" class="status">Load video...</div>
        </div>
        <div class="section"><button id="startBtn" disabled>START VR</button></div>
    </div>

    <div id="progressOverlay">
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            <div class="controls">
                <button class="control-btn pan-left-btn">&larr;</button>
                <button class="control-btn pan-center-btn">o</button>
                <button class="control-btn pan-right-btn">&rarr;</button>
            </div>
            <div class="controls">
                <button class="control-btn rewind-btn">&lt;&lt;</button>
                <button class="control-btn play-pause-btn">||</button>
                <button class="control-btn forward-btn">&gt;&gt;</button>
            </div>
            <div class="controls" style="margin-top: 5px;">
                <button class="control-btn zoom-out-btn">-</button>
                <button class="control-btn zoom-reset zoom-reset-btn">Reset</button>
                <button class="control-btn zoom-in-btn">+</button>
            </div>
        </div>
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            <div class="controls">
                <button class="control-btn pan-left-btn">&larr;</button>
                <button class="control-btn pan-center-btn">o</button>
                <button class="control-btn pan-right-btn">&rarr;</button>
            </div>
            <div class="controls">
                <button class="control-btn rewind-btn">&lt;&lt;</button>
                <button class="control-btn play-pause-btn">||</button>
                <button class="control-btn forward-btn">&gt;&gt;</button>
            </div>
            <div class="controls" style="margin-top: 5px;">
                <button class="control-btn zoom-out-btn">-</button>
                <button class="control-btn zoom-reset zoom-reset-btn">Reset</button>
                <button class="control-btn zoom-in-btn">+</button>
            </div>
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    
    <script id="fragmentShaderDistortion" type="x-shader/x-fragment">
        uniform sampler2D tDiffuse;
        uniform float k1;
        uniform float k2;
        uniform float eyeOffset;
        uniform float headYawOffset;
        uniform float headPitchOffset;
        uniform float manualPanOffset;
        uniform float manualTiltOffset;
        uniform float zoomLevel;
        uniform vec2 texelSize;
        varying vec2 vUv;
        
        const float PI = 3.14159265359;
        const float HALF_PI = 1.57079632679;
        
        vec2 distort(vec2 p) {
            // Each eye is rendered into its own full-sized texture,
            // so the lens center is simply the middle of that texture.
            vec2 center = vec2(0.5, 0.5);
            vec2 v = p - center;
            float r2 = dot(v, v);
            float distortion = 1.0 + r2 * (k1 + k2 * r2);
            return center + v * distortion;
        }
        
        float lanczos2(float x) {
            x = abs(x);
            if (x < 0.0001) return 1.0;
            if (x >= 2.0) return 0.0;
            float pix = PI * x;
            float pix_half = HALF_PI * x;
            return (sin(pix) / pix) * (sin(pix_half) / pix_half);
        }
        
        vec4 sampleLanczos2(vec2 uv) {
            vec2 center = uv / texelSize - 0.5;
            vec2 centerFloor = floor(center);
            vec2 f = center - centerFloor;
            
            vec4 color = vec4(0.0);
            float weightSum = 0.0;
            
            for (int y = -1; y <= 2; y++) {
                float fy = float(y) - f.y;
                float wy = lanczos2(fy);
                for (int x = -1; x <= 2; x++) {
                    float weight = lanczos2(float(x) - f.x) * wy;
                    vec2 sampleUV = (centerFloor + vec2(float(x), float(y)) + 0.5) * texelSize;
                    
                    if (sampleUV.x >= 0.0 && sampleUV.x <= 1.0 && sampleUV.y >= 0.0 && sampleUV.y <= 1.0) {
                        color += texture2D(tDiffuse, sampleUV) * weight;
                        weightSum += weight;
                    }
                }
            }
            
            return weightSum > 0.0001 ? color / weightSum : vec4(0.0);
        }
        
        void main() {
            vec2 distortedUV = distort(vUv);
            vec2 uv = (distortedUV - 0.5) / zoomLevel;
            uv.x += headYawOffset + manualPanOffset;
            uv.y += headPitchOffset + manualTiltOffset;
            uv += 0.5;
            
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
                gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
            } else {
                gl_FragColor = zoomLevel > 1.5 ? sampleLanczos2(uv) : texture2D(tDiffuse, uv);
            }
        }
    </script>

    <script>
        const fileInput = document.getElementById('fileInput');
        const testVideo = document.getElementById('testVideo');
        const startBtn = document.getElementById('startBtn');
        const setupDiv = document.getElementById('setup');
        const status = document.getElementById('status');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressFills = document.querySelectorAll('.progressFill');
        const timeDisplays = document.querySelectorAll('.timeDisplay');
        const playPauseBtns = document.querySelectorAll('.play-pause-btn');

        let camera, scene, renderer, effect;
        let video, videoTexture, orientationTracker;
        let mode = '2d';
        let isPlaying = false;
        let videoURL = null;
        let hideOverlayTimer = null;
        let currentZoomLevel = 4;
        let manualPanX = 0, manualPanY = 0;
        let headYaw = 0, headPitch = 0, yawOffset = 0, pitchOffset = 0;
        let lastUpdateTime = 0, lastYaw = 0, lastPitch = 0;
        let angularVelocity = 0;

        const zoomLevels = [
            0.2, 0.4, 0.6, 0.8,
            1.0, 1.2, 1.4, 1.6,
            1.8, 2.0, 2.2, 2.4,
            2.6, 2.8, 3.0, 3.2,
            3.4, 3.6, 3.8, 4.0
        ];

        fileInput.addEventListener('change', handleFileSelect);
        startBtn.addEventListener('click', startVR);

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            if (videoURL) URL.revokeObjectURL(videoURL);
            videoURL = URL.createObjectURL(file);
            testVideo.src = videoURL;

            testVideo.addEventListener('loadedmetadata', function() {
                status.textContent = `Ready: ${testVideo.videoWidth}x${testVideo.videoHeight}`;
                status.className = 'status success';
                startBtn.disabled = false;
            }, { once: true });

            testVideo.load();
        }

        async function startVR() {
            if (!videoURL) return;

            const selectedMode = document.querySelector('input[name="mode"]:checked');
            mode = selectedMode ? selectedMode.value : '2d';

            if (typeof DeviceOrientationEvent !== 'undefined' &&
                typeof DeviceOrientationEvent.requestPermission === 'function') {
                try {
                    const permission = await DeviceOrientationEvent.requestPermission();
                    if (permission !== 'granted') {
                        alert('Device orientation permission denied.');
                    }
                } catch (error) {
                    console.error('Error requesting orientation permission:', error);
                }
            }

            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) {
                elem.webkitRequestFullscreen();
            }

            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }

            setTimeout(() => {
                setupDiv.classList.add('hidden');
                disposeResources();
                initVR();
            }, 100);
        }

        function disposeResources() {
            if (videoTexture) {
                videoTexture.dispose();
                videoTexture = null;
            }
            if (video) {
                video.pause();
                video.src = '';
                video.load();
                video = null;
            }
            if (orientationTracker) {
                orientationTracker.disconnect();
                orientationTracker = null;
            }
            if (effect && effect.dispose) {
                effect.dispose();
                effect = null;
            }
            if (renderer) {
                renderer.dispose();
                if (renderer.domElement && renderer.domElement.parentNode) {
                    renderer.domElement.parentNode.removeChild(renderer.domElement);
                }
                renderer = null;
            }
            if (scene) {
                scene.traverse((obj) => {
                    if (obj.geometry) obj.geometry.dispose();
                    if (obj.material) {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                });
                scene = null;
            }
        }

        function initVR() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0);

            video = document.createElement('video');
            video.src = videoURL;
            video.loop = false;
            video.muted = false;
            video.playsinline = true;
            video.setAttribute('webkit-playsinline', '');

            video.addEventListener('loadeddata', function() {
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                videoTexture.magFilter = THREE.LinearFilter;

                const aspect = mode === '3d'
                    ? (video.videoWidth / 2) / video.videoHeight
                    : video.videoWidth / video.videoHeight;

                // Size the virtual screen so it fits comfortably inside the FOV
                const distance = 2.5;
                const fovRad = THREE.MathUtils.degToRad(camera.fov);
                const maxWidth = 2 * distance * Math.tan(fovRad / 2);
                const width = maxWidth * 0.9; // 90% of visible width
                const height = width / aspect;

                if (mode === '2d') {
                    const geometry = new THREE.PlaneGeometry(width, height);
                    const material = new THREE.MeshBasicMaterial({
                        map: videoTexture,
                        side: THREE.DoubleSide
                    });
                    const screen = new THREE.Mesh(geometry, material);
                    screen.position.set(0, 0, -distance);
                    camera.add(screen);
                    scene.add(camera);
                } else {
                    const geometryL = new THREE.PlaneGeometry(width, height);
                    const materialL = new THREE.ShaderMaterial({
                        uniforms: { tex: { value: videoTexture } },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D tex;
                            varying vec2 vUv;
                            void main() {
                                vec2 uv = vec2(vUv.x * 0.5, vUv.y);
                                gl_FragColor = texture2D(tex, uv);
                            }
                        `,
                        side: THREE.DoubleSide
                    });
                    const screenL = new THREE.Mesh(geometryL, materialL);
                    screenL.position.set(0, 0, -distance);
                    screenL.layers.set(1);
                    camera.add(screenL);

                    const geometryR = new THREE.PlaneGeometry(width, height);
                    const materialR = new THREE.ShaderMaterial({
                        uniforms: { tex: { value: videoTexture } },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D tex;
                            varying vec2 vUv;
                            void main() {
                                vec2 uv = vec2(vUv.x * 0.5 + 0.5, vUv.y);
                                gl_FragColor = texture2D(tex, uv);
                            }
                        `,
                        side: THREE.DoubleSide
                    });
                    const screenR = new THREE.Mesh(geometryR, materialR);
                    screenR.position.set(0, 0, -distance);
                    screenR.layers.set(2);
                    camera.add(screenR);
                    scene.add(camera);
                }

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                effect = new THREE.StereoEffect(renderer);
                effect.setSize(window.innerWidth, window.innerHeight);

                orientationTracker = new OrientationTracker();
                orientationTracker.connect();

                window.addEventListener('resize', onResize);
                document.addEventListener('click', toggleOverlay);
                video.addEventListener('timeupdate', updateProgress);
                progressOverlay.addEventListener('click', handleControls);

                showOverlay();

                video.play().then(() => {
                    isPlaying = true;
                    updatePlayPauseButtons();
                    animate();
                }).catch(err => {
                    console.error('Error playing video:', err);
                });
            });

            video.load();
        }

        function animate() {
            requestAnimationFrame(animate);
            if (orientationTracker) orientationTracker.update();
            effect.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            effect.setSize(window.innerWidth, window.innerHeight);
        }

        function updatePlayPauseButtons() {
            playPauseBtns.forEach(btn => {
                btn.textContent = isPlaying ? '||' : '>';
            });
        }

        function togglePlayPause() {
            if (!video) return;
            if (isPlaying) {
                video.pause();
                isPlaying = false;
            } else {
                video.play();
                isPlaying = true;
            }
            updatePlayPauseButtons();
            showOverlay();
        }

        function seekVideo(barElem, clientX) {
            if (!video || !barElem) return;
            const rect = barElem.getBoundingClientRect();
            const pos = (clientX - rect.left) / rect.width;
            const clampedPos = Math.max(0, Math.min(1, pos));
            video.currentTime = clampedPos * video.duration;
            showOverlay();
        }

        function seekRelative(seconds) {
            if (!video) return;
            const targetTime = video.currentTime + seconds;
            video.currentTime = Math.max(0, Math.min(video.duration, targetTime));
            showOverlay();
        }

        function updateProgress() {
            if (!video || !isFinite(video.duration) || video.duration <= 0) return;

            const percent = (video.currentTime / video.duration) * 100;
            progressFills.forEach(fill => {
                fill.style.width = percent + '%';
            });

            const currentMin = Math.floor(video.currentTime / 60);
            const currentSec = Math.floor(video.currentTime % 60);
            const durationMin = Math.floor(video.duration / 60);
            const durationSec = Math.floor(video.duration % 60);

            const timeText = `${currentMin}:${currentSec.toString().padStart(2, '0')} / ${durationMin}:${durationSec.toString().padStart(2, '0')}`;
            timeDisplays.forEach(display => {
                display.textContent = timeText;
            });
        }

        function toggleOverlay(e) {
            if (e.target.closest('#progressOverlay')) return;
            if (progressOverlay.classList.contains('visible')) {
                hideOverlay();
            } else {
                showOverlay();
            }
        }

        function showOverlay() {
            progressOverlay.classList.add('visible');
            progressOverlay.classList.remove('fading');
            if (hideOverlayTimer) clearTimeout(hideOverlayTimer);
            hideOverlayTimer = setTimeout(() => {
                if (isPlaying) hideOverlay();
            }, 3000);
        }

        function hideOverlay() {
            progressOverlay.classList.add('fading');
            setTimeout(() => {
                progressOverlay.classList.remove('visible');
            }, 300);
        }

        function adjustZoom(direction) {
            if (direction > 0) {
                currentZoomLevel = Math.min(zoomLevels.length - 1, currentZoomLevel + 1);
            } else {
                currentZoomLevel = Math.max(0, currentZoomLevel - 1);
            }
            showOverlay();
        }

        function resetZoom() {
            currentZoomLevel = 4;
            showOverlay();
        }

        function adjustPan(dx) {
            manualPanX += dx * 0.05;
            showOverlay();
        }

        function centerPan() {
            manualPanX = 0;
            manualPanY = 0;
            yawOffset = headYaw;
            pitchOffset = headPitch;
            showOverlay();
        }

        function handleControls(e) {
            e.stopPropagation();
            const target = e.target.closest('.control-btn, .progressBar');
            if (!target) return;

            if (target.classList.contains('progressBar')) {
                seekVideo(target, e.clientX);
                return;
            }

            const classList = target.classList;
            if (classList.contains('play-pause-btn')) togglePlayPause();
            else if (classList.contains('rewind-btn')) seekRelative(-10);
            else if (classList.contains('forward-btn')) seekRelative(10);
            else if (classList.contains('zoom-in-btn')) adjustZoom(1);
            else if (classList.contains('zoom-out-btn')) adjustZoom(-1);
            else if (classList.contains('zoom-reset-btn')) resetZoom();
            else if (classList.contains('pan-left-btn')) adjustPan(-1);
            else if (classList.contains('pan-center-btn')) centerPan();
            else if (classList.contains('pan-right-btn')) adjustPan(1);
        }

        function OrientationTracker() {
            this.deviceOrientation = {};
            this.screenOrientation = 0;
            this.enabled = false;
            this.autoCenterTimer = null;
            this.firstReadingTime = null;

            const onDeviceOrientationChangeEvent = (event) => {
                this.deviceOrientation = event;
            };

            const onScreenOrientationChangeEvent = () => {
                if (window.screen && window.screen.orientation && typeof window.screen.orientation.angle === 'number') {
                    this.screenOrientation = window.screen.orientation.angle;
                } else {
                    this.screenOrientation = window.orientation || 0;
                }
            };

            this.connect = function() {
                onScreenOrientationChangeEvent();
                window.addEventListener('orientationchange', onScreenOrientationChangeEvent);
                window.addEventListener('deviceorientation', onDeviceOrientationChangeEvent);
                this.enabled = true;
            };

            this.disconnect = function() {
                window.removeEventListener('orientationchange', onScreenOrientationChangeEvent);
                window.removeEventListener('deviceorientation', onDeviceOrientationChangeEvent);
                this.enabled = false;
                if (this.autoCenterTimer) clearTimeout(this.autoCenterTimer);
            };

            this.update = function() {
                if (!this.enabled) return;

                const now = Date.now();
                const dtMs = now - lastUpdateTime;
                const dt = dtMs / 1000;

                if (dtMs < 16) return;

                const device = this.deviceOrientation;
                if (device && device.alpha !== null && device.beta !== null && device.gamma !== null) {
                    const isLandscape = Math.abs(this.screenOrientation) === 90;

                    let currentYaw = THREE.MathUtils.degToRad(device.alpha || 0);

                    const currentPitch = isLandscape
                        ? THREE.MathUtils.degToRad(device.gamma || 0)
                        : THREE.MathUtils.degToRad(device.beta || 0);

                    if (!this.firstReadingTime) {
                        this.firstReadingTime = now;
                        this.autoCenterTimer = setTimeout(() => {
                            yawOffset = headYaw;
                            pitchOffset = headPitch;
                        }, 800);
                    }

                    let rawYawDiff = currentYaw - lastYaw;
                    rawYawDiff = ((rawYawDiff + Math.PI) % (2 * Math.PI)) - Math.PI;
                    const yawDiffAbs = Math.abs(rawYawDiff);
                    const pitchDiffAbs = Math.abs(currentPitch - lastPitch);

                    const minAngle = 0.002;
                    const deltaAngle = yawDiffAbs + pitchDiffAbs;

                    if (dt > 0) {
                        const instantaneousVel = deltaAngle / dt;
                        const smoothing = 0.8;
                        angularVelocity = smoothing * angularVelocity + (1 - smoothing) * instantaneousVel;
                        if (angularVelocity < 0.01) angularVelocity = 0;
                    }

                    if (yawDiffAbs > minAngle || pitchDiffAbs > minAngle) {
                        headYaw = headYaw + rawYawDiff;
                        headPitch = currentPitch;
                        lastYaw = currentYaw;
                        lastPitch = currentPitch;
                    }

                    lastUpdateTime = now;
                }
            };
        }

        THREE.StereoEffect = function(renderer) {
            const _stereo = new THREE.StereoCamera();
            _stereo.aspect = 0.5;

            const dpr = window.devicePixelRatio || 1;
            const maxTextureSize = renderer.capabilities.maxTextureSize;
            let rtWidth = Math.min(Math.floor(window.innerWidth * dpr / 2), maxTextureSize);
            let rtHeight = Math.min(Math.floor(window.innerHeight * dpr), maxTextureSize);
            
            let renderTargetL = new THREE.WebGLRenderTarget(rtWidth, rtHeight);
            let renderTargetR = new THREE.WebGLRenderTarget(rtWidth, rtHeight);

            const distortionMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: null },
                    k1: { value: 0.22 },
                    k2: { value: 0.18 },
                    eyeOffset: { value: 0.0 },
                    headYawOffset: { value: 0.0 },
                    headPitchOffset: { value: 0.0 },
                    manualPanOffset: { value: 0.0 },
                    manualTiltOffset: { value: 0.0 },
                    zoomLevel: { value: 1.0 },
                    texelSize: { value: new THREE.Vector2(1.0 / rtWidth, 1.0 / rtHeight) }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderDistortion').textContent
            });

            let cachedYawUV = 0;
            let cachedPitchUV = 0;
            let cachedZoom = 1.0;

            const quadGeometry = new THREE.PlaneGeometry(2, 2);
            const quadMesh = new THREE.Mesh(quadGeometry, distortionMaterial);
            const orthoScene = new THREE.Scene();
            const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            orthoScene.add(quadMesh);

            const sizeVec = new THREE.Vector2();

            this.setSize = function(width, height) {
                renderer.setSize(width, height);
                const newDpr = window.devicePixelRatio || 1;
                const newRtWidth = Math.min(Math.floor(width * newDpr / 2), maxTextureSize);
                const newRtHeight = Math.min(Math.floor(height * newDpr), maxTextureSize);

                if (newRtWidth !== rtWidth || newRtHeight !== rtHeight) {
                    renderTargetL.dispose();
                    renderTargetR.dispose();
                    rtWidth = newRtWidth;
                    rtHeight = newRtHeight;
                    renderTargetL = new THREE.WebGLRenderTarget(rtWidth, rtHeight);
                    renderTargetR = new THREE.WebGLRenderTarget(rtWidth, newRtHeight);
                    distortionMaterial.uniforms.texelSize.value.set(1.0 / rtWidth, 1.0 / rtHeight);
                }
            };

            this.render = function(scene, camera) {
                scene.updateMatrixWorld();
                if (camera.parent === null) camera.updateMatrixWorld();
                _stereo.update(camera);
                renderer.getSize(sizeVec);
                const halfWidth = sizeVec.width * 0.5;

                if (mode === '3d') {
                    _stereo.cameraL.layers.set(1);
                    _stereo.cameraR.layers.set(2);
                }

                // Render each eye into its own render target
                renderer.setRenderTarget(renderTargetL);
                renderer.clear();
                renderer.render(scene, _stereo.cameraL);
                
                renderer.setRenderTarget(renderTargetR);
                renderer.clear();
                renderer.render(scene, _stereo.cameraR);
                
                renderer.setRenderTarget(null);
                renderer.clear();
                renderer.setScissorTest(true);

                // ---- Head rotation -> UV offsets ----
                let yawDelta = headYaw - yawOffset;
                yawDelta = ((yawDelta + Math.PI) % (2 * Math.PI)) - Math.PI;

                let pitchDelta = headPitch - pitchOffset;
                pitchDelta = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitchDelta));

                // Yaw: faster (about 2x compared to previous 0.18)
                let yawUV = -yawDelta * 0.35;

                // Pitch: very gentle to avoid cropping when looking up/down
                let pitchUV = -pitchDelta * 0.06;

                // Clamp offsets to keep sampling safely inside the texture
                const maxYawOffset = 0.28;
                const maxPitchOffset = 0.12;
                yawUV = Math.max(-maxYawOffset, Math.min(maxYawOffset, yawUV));
                pitchUV = Math.max(-maxPitchOffset, Math.min(maxPitchOffset, pitchUV));

                // ---- Zoom purely controlled by user ----
                const currentZoom = zoomLevels[currentZoomLevel];
                const effectiveZoom = currentZoom;

                if (Math.abs(yawUV - cachedYawUV) > 0.001) {
                    distortionMaterial.uniforms.headYawOffset.value = yawUV;
                    cachedYawUV = yawUV;
                }
                if (Math.abs(pitchUV - cachedPitchUV) > 0.001) {
                    distortionMaterial.uniforms.headPitchOffset.value = pitchUV;
                    cachedPitchUV = pitchUV;
                }
                if (Math.abs(effectiveZoom - cachedZoom) > 0.001) {
                    distortionMaterial.uniforms.zoomLevel.value = effectiveZoom;
                    cachedZoom = effectiveZoom;
                }
                
                distortionMaterial.uniforms.manualPanOffset.value = manualPanX;
                distortionMaterial.uniforms.manualTiltOffset.value = manualPanY;
                
                // ---- Left eye ----
                distortionMaterial.uniforms.tDiffuse.value = renderTargetL.texture;
                distortionMaterial.uniforms.eyeOffset.value = 0.0;
                renderer.setScissor(0, 0, halfWidth, sizeVec.height);
                renderer.setViewport(0, 0, halfWidth, sizeVec.height);
                renderer.render(orthoScene, orthoCamera);

                // ---- Right eye ----
                distortionMaterial.uniforms.tDiffuse.value = renderTargetR.texture;
                distortionMaterial.uniforms.eyeOffset.value = 0.0;
                renderer.setScissor(halfWidth, 0, halfWidth, sizeVec.height);
                renderer.setViewport(halfWidth, 0, halfWidth, sizeVec.height);
                renderer.render(orthoScene, orthoCamera);

                renderer.setScissorTest(false);
            };

            this.dispose = function() {
                renderTargetL.dispose();
                renderTargetR.dispose();
                distortionMaterial.dispose();
                quadGeometry.dispose();
            };
        };
    </script>
</body>
</html>
