<!DOCTYPE html>
<html>
<head>
    <title>VR Video Player (IMAX Architecture)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="theme-color" content="#000000">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background: #000; color: white; }
        #setup { position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; background: #1a1a1a; padding: 20px; overflow-y: auto; }
        #setup.hidden { display: none; }
        .section { background: rgba(255,255,255,0.1); padding: 15px; margin: 10px 0; border-radius: 8px; }
        button { background: #007BFF; color: white; border: none; padding: 15px; font-size: 18px; border-radius: 5px; cursor: pointer; margin: 5px 0; width: 100%; }
        button:active { background: #0056b3; }
        button:disabled { background: #555; }
        input[type="file"] { width: 100%; padding: 10px; background: white; color: black; border-radius: 5px; margin: 10px 0; }
        #testVideo { width: 100%; max-width: 400px; background: #000; margin: 10px 0; }
        .status { padding: 10px; margin: 10px 0; background: #000; border-radius: 5px; }
        .success { color: #4CAF50; }
        #progressOverlay { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.8); padding: 15px; display: none; z-index: 998; transition: opacity 0.3s; }
        #progressOverlay.visible { display: flex; }
        #progressOverlay.fading { opacity: 0; }
        .eye-controls { width: 50%; display: flex; flex-direction: column; align-items: center; padding: 0 10px; }
        .progressBar { width: 100%; height: 8px; background: rgba(255,255,255,0.3); border-radius: 4px; cursor: pointer; margin-bottom: 10px; position: relative; }
        .progressFill { height: 100%; background: #007BFF; border-radius: 4px; width: 0%; transition: width 0.1s; }
        .timeDisplay { text-align: center; font-size: 16px; color: white; }
        .controls { display: flex; justify-content: center; gap: 10px; margin-top: 10px; }
        .control-btn { background: rgba(255,255,255,0.2); border: none; color: white; width: 50px; height: 50px; border-radius: 50%; font-size: 20px; cursor: pointer; padding: 0; }
        .control-btn:active { background: rgba(255,255,255,0.4); }
        .zoom-reset { width: 70px; font-size: 14px; }
    </style>
</head>
<body>
    <div id="setup">
        <h2>VR 2 Player</h2>
        <div class="section"><strong>Video Type</strong><br><input type="radio" id="mode2d" name="mode" value="2d" checked><label for="mode2d">2D</label><input type="radio" id="mode3d" name="mode" value="3d"><label for="mode3d">SBS 3D</label></div>
        <div class="section"><strong>Select Video</strong><br><input type="file" id="fileInput" accept="video/*"></div>
        <div class="section"><strong>Test</strong><br><video id="testVideo" controls playsinline webkit-playsinline></video><div id="status" class="status">Load video...</div></div>
        <div class="section"><button id="startBtn" disabled>START VR</button></div>
    </div>

    <div id="progressOverlay">
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            <div class="controls"><button class="control-btn pan-left-btn">&lt;</button><button class="control-btn pan-center-btn">o</button><button class="control-btn pan-right-btn">&gt;</button></div>
            <div class="controls"><button class="control-btn rewind-btn">&lt;&lt;</button><button class="control-btn play-pause-btn">||</button><button class="control-btn forward-btn">&gt;&gt;</button></div>
            <div class="controls" style="margin-top: 5px;"><button class="control-btn zoom-out-btn">-</button><button class="control-btn zoom-reset zoom-reset-btn">Reset</button><button class="control-btn zoom-in-btn">+</button></div>
        </div>
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            <div class="controls"><button class="control-btn pan-left-btn">&lt;</button><button class="control-btn pan-center-btn">o</button><button class="control-btn pan-right-btn">&gt;</button></div>
            <div class="controls"><button class="control-btn rewind-btn">&lt;&lt;</button><button class="control-btn play-pause-btn">||</button><button class="control-btn forward-btn">&gt;&gt;</button></div>
            <div class="controls" style="margin-top: 5px;"><button class="control-btn zoom-out-btn">-</button><button class="control-btn zoom-reset zoom-reset-btn">Reset</button><button class="control-btn zoom-in-btn">+</button></div>
        </div>
    </div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    
    <script id="fragmentShaderDistortion" type="x-shader/x-fragment">
        uniform sampler2D tDiffuse;
        uniform float k1, k2, eyeOffset;
        varying vec2 vUv;
        
        vec2 distort(vec2 p) {
            vec2 c = vec2(0.5 + eyeOffset, 0.5);
            vec2 v = p - c;
            float r2 = dot(v, v);
            return c + v * (1.0 + r2 * (k1 + k2 * r2));
        }
        
        void main() {
            gl_FragColor = texture2D(tDiffuse, distort(vUv));
        }
    </script>

    <script>
        // --- Globals & DOM Elements ---
        const fileInput = document.getElementById('fileInput');
        const testVideo = document.getElementById('testVideo');
        const startBtn = document.getElementById('startBtn');
        const setupDiv = document.getElementById('setup');
        const status = document.getElementById('status');
        const progressOverlay = document.getElementById('progressOverlay');
        const progressFills = document.querySelectorAll('.progressFill');
        const timeDisplays = document.querySelectorAll('.timeDisplay');
        const playPauseBtns = document.querySelectorAll('.play-pause-btn');

        // --- State Variables ---
        let camera, scene, renderer, effect, videoScreen;
        let video, videoTexture, controls;
        let mode = '2d', isPlaying = false, videoURL = null;
        let hideOverlayTimer = null, currentZoomLevel = 4;
        let screenOffsetX = 0, screenOffsetY = 0;
        const zoomLevels = [0.2, 0.4, 0.6, 0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0];

        // --- Event Listeners ---
        fileInput.addEventListener('change', handleFileSelect);
        startBtn.addEventListener('click', startVR);
        
        // --- Core Functions ---
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            URL.revokeObjectURL(videoURL);
            videoURL = URL.createObjectURL(file);
            testVideo.src = videoURL;
            mode = document.querySelector('input[name="mode"]:checked').value;
            testVideo.addEventListener('loadedmetadata', () => {
                status.textContent = `Ready: ${testVideo.videoWidth}x${testVideo.videoHeight}`;
                status.className = 'status success';
                startBtn.disabled = false;
            }, { once: true });
            testVideo.load();
        }

        async function startVR() {
            if (!videoURL) return;
            if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
                await DeviceOrientationEvent.requestPermission().catch(err => console.error(err));
            }
            const elem = document.documentElement;
            elem.requestFullscreen?.() || elem.webkitRequestFullscreen?.();
            screen.orientation?.lock?.('landscape').catch(() => {});
            setTimeout(() => {
                setupDiv.classList.add('hidden');
                disposeResources();
                initVR();
            }, 100);
        }

        function disposeResources() {
            videoTexture?.dispose();
            if(video){ video.pause(); video.src=''; video.load(); }
            effect?.dispose();
            controls?.dispose();
            if(renderer){ renderer.dispose(); renderer.domElement.parentElement?.removeChild(renderer.domElement); }
            scene?.traverse(o => { o.geometry?.dispose(); if(o.material){ o.material.map?.dispose(); o.material.dispose(); }});
        }

        function initVR() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);

            camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 10);
            scene.add(camera);
            
            video = document.createElement('video');
            video.src = videoURL;
            video.playsinline = true;
            video.setAttribute('webkit-playsinline', '');
            
            video.addEventListener('loadeddata', () => {
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                const aspect = (mode === '3d' ? video.videoWidth / 2 : video.videoWidth) / video.videoHeight;
                const height = 2;
                const width = height * aspect;
                
                if (mode === '2d') {
                    const geometry = new THREE.PlaneGeometry(width, height);
                    const material = new THREE.MeshBasicMaterial({ map: videoTexture });
                    videoScreen = new THREE.Mesh(geometry, material);
                    camera.add(videoScreen);
                } else {
                    videoScreen = [];
                    const createEyeScreen = (isLeft) => {
                        const geometry = new THREE.PlaneGeometry(width, height);
                        const material = new THREE.ShaderMaterial({
                            uniforms: { tex: { value: videoTexture } },
                            vertexShader: document.getElementById('vertexShader').textContent,
                            fragmentShader: `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x * 0.5 + ${isLeft ? '0.0':'0.5'}, vUv.y)); }`,
                        });
                        const screen = new THREE.Mesh(geometry, material);
                        screen.layers.set(isLeft ? 1 : 2);
                        camera.add(screen);
                        videoScreen.push(screen);
                    };
                    createEyeScreen(true);
                    createEyeScreen(false);
                }

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                effect = new THREE.StereoEffect(renderer);
                effect.setSize(window.innerWidth, window.innerHeight);
                controls = new THREE.DeviceOrientationControls(camera);
                controls.connect();

                window.addEventListener('resize', onResize);
                document.addEventListener('click', toggleOverlay);
                video.addEventListener('timeupdate', updateProgress);
                progressOverlay.addEventListener('click', handleControls);

                showOverlay();
                video.play().then(() => {
                    isPlaying = true;
                    updatePlayPauseButtons();
                    animate();
                }).catch(err => console.error(err));
            });
            video.load();
        }

        function updateScreenTransform() {
            if (!videoScreen) return;
            const scale = zoomLevels[currentZoomLevel];
            const distance = 2.5;
            const screens = Array.isArray(videoScreen) ? videoScreen : [videoScreen];
            screens.forEach(screen => {
                screen.position.set(screenOffsetX, screenOffsetY, -distance);
                screen.scale.set(scale, scale, scale);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            controls?.update();
            updateScreenTransform(); // Apply ergonomic adjustments every frame
            effect.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            effect.setSize(window.innerWidth, window.innerHeight);
        }
        
        function updatePlayPauseButtons() { playPauseBtns.forEach(btn => btn.textContent = isPlaying ? '||' : '>'); }
        function togglePlayPause() { if (!video) return; isPlaying ? video.pause() : video.play(); isPlaying = !isPlaying; updatePlayPauseButtons(); showOverlay(); }
        function seekVideo(e) { const rect = e.currentTarget.getBoundingClientRect(); video.currentTime = (e.clientX - rect.left) / rect.width * video.duration; showOverlay(); }
        function seekRelative(s) { video.currentTime = Math.max(0, Math.min(video.duration, video.currentTime + s)); showOverlay(); }
        function updateProgress() { if (!video.duration) return; const p = (video.currentTime / video.duration) * 100; const f = t => `${Math.floor(t/60)}:${Math.floor(t%60).toString().padStart(2,'0')}`; const t = `${f(video.currentTime)}/${f(video.duration)}`; progressFills.forEach(fill => fill.style.width = p + '%'); timeDisplays.forEach(display => display.textContent = t); }
        function toggleOverlay(e) { if (!e.target.closest('#progressOverlay')) { progressOverlay.classList.contains('visible') ? hideOverlay() : showOverlay(); } }
        function showOverlay() { progressOverlay.classList.add('visible'); progressOverlay.classList.remove('fading'); clearTimeout(hideOverlayTimer); hideOverlayTimer = setTimeout(() => { if (isPlaying) hideOverlay(); }, 3000); }
        function hideOverlay() { progressOverlay.classList.add('fading'); setTimeout(() => progressOverlay.classList.remove('visible'), 300); }
        
        function adjustZoom(direction) {
            currentZoomLevel = Math.max(0, Math.min(zoomLevels.length - 1, currentZoomLevel + direction));
            showOverlay();
        }
        function resetZoom() {
            currentZoomLevel = 4;
            showOverlay();
        }
        function adjustPan(direction) {
            screenOffsetX += direction * 0.1;
            showOverlay();
        }
        function centerScreen() {
            screenOffsetX = 0;
            screenOffsetY = 0;
            resetZoom();
        }

        function handleControls(e) {
            e.stopPropagation();
            const t = e.target.closest('.control-btn, .progressBar');
            if (!t) return;
            if (t.matches('.progressBar')) { seekVideo(e); return; }
            const c = t.classList;
            if      (c.contains('play-pause-btn')) togglePlayPause();
            else if (c.contains('rewind-btn'))     seekRelative(-10);
            else if (c.contains('forward-btn'))    seekRelative(10);
            else if (c.contains('zoom-in-btn'))    adjustZoom(1);
            else if (c.contains('zoom-out-btn'))   adjustZoom(-1);
            else if (c.contains('zoom-reset-btn')) resetZoom();
            else if (c.contains('pan-left-btn'))   adjustPan(-1);
            else if (c.contains('pan-right-btn'))  adjustPan(1);
            else if (c.contains('pan-center-btn')) centerScreen();
        }

        // --- SIMPLIFIED CONTROLS FOR IMAX ARCHITECTURE ---
        THREE.DeviceOrientationControls = function(camera) {
            const scope = this;
            this.camera = camera;
            this.camera.rotation.reorder('YXZ');
            this.enabled = true, this.deviceOrientation = {}, this.screenOrientation = 0;
            const e = new THREE.Euler(0,0,0,'YXZ'), q0 = new THREE.Quaternion(), q1 = new THREE.Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)), z = new THREE.Vector3(0,0,1);
            const onDeviceOrientation = e => scope.deviceOrientation = e;
            const onScreenOrientation = () => scope.screenOrientation = window.orientation || 0;
            this.connect = () => { onScreenOrientation(); window.addEventListener('orientationchange', onScreenOrientation); window.addEventListener('deviceorientation', onDeviceOrientation); scope.enabled = true; };
            this.disconnect = () => { window.removeEventListener('orientationchange', onScreenOrientation); window.removeEventListener('deviceorientation', onDeviceOrientation); scope.enabled = false; };
            this.update = function() { if (!scope.enabled) return; const d = scope.deviceOrientation; if (d) { const a=d.alpha?THREE.MathUtils.degToRad(d.alpha):0, b=d.beta?THREE.MathUtils.degToRad(d.beta):0, g=d.gamma?THREE.MathUtils.degToRad(d.gamma):0, o=scope.screenOrientation?THREE.MathUtils.degToRad(scope.screenOrientation):0; e.set(b,a,-g,'YXZ'); scope.camera.quaternion.setFromEuler(e); scope.camera.quaternion.multiply(q1); scope.camera.quaternion.multiply(q0.setFromAxisAngle(z, -o)); }};
            this.dispose = () => scope.disconnect();
        };

        // --- STEREO EFFECT (SIMPLIFIED FOR IMAX) ---
        THREE.StereoEffect = function(renderer) {
            const _stereo = new THREE.StereoCamera();
            _stereo.aspect = 0.5;
            let rtL, rtR;
            const distortionMaterial = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: { value: null }, k1: { value: 0.22 }, k2: { value: 0.18 }, eyeOffset: { value: 0.0 } },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderDistortion').textContent
            });
            const quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), distortionMaterial);
            const orthoScene = new THREE.Scene();
            orthoScene.add(quad);
            const orthoCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const size = new THREE.Vector2();
            this.setSize = (w, h) => { renderer.setSize(w, h); const dpr = window.devicePixelRatio || 1; const rw = Math.floor(w * dpr / 2), rh = Math.floor(h * dpr); if(rtL){ rtL.dispose(); rtR.dispose(); } rtL = new THREE.WebGLRenderTarget(rw, rh); rtR = new THREE.WebGLRenderTarget(rw, rh); };
            this.render = (scene, camera) => {
                scene.updateMatrixWorld(true);
                if(camera.parent === null) camera.updateMatrixWorld();
                _stereo.update(camera);
                renderer.getSize(size);
                const halfW = size.width/2;
                if (mode === '3d') { _stereo.cameraL.layers.set(1); _stereo.cameraR.layers.set(2); }
                renderer.setRenderTarget(rtL); renderer.clear(); renderer.render(scene, _stereo.cameraL);
                renderer.setRenderTarget(rtR); renderer.clear(); renderer.render(scene, _stereo.cameraR);
                renderer.setRenderTarget(null); renderer.clear();
                renderer.setScissorTest(true);
                distortionMaterial.uniforms.tDiffuse.value = rtL.texture;
                distortionMaterial.uniforms.eyeOffset.value = -0.02;
                renderer.setScissor(0, 0, halfW, size.height); renderer.setViewport(0, 0, halfW, size.height); renderer.render(orthoScene, orthoCam);
                distortionMaterial.uniforms.tDiffuse.value = rtR.texture;
                distortionMaterial.uniforms.eyeOffset.value = 0.02;
                renderer.setScissor(halfW, 0, halfW, size.height); renderer.setViewport(halfW, 0, halfW, size.height); renderer.render(orthoScene, orthoCam);
                renderer.setScissorTest(false);
            };
            this.dispose = () => { rtL?.dispose(); rtR?.dispose(); distortionMaterial.dispose(); quad.geometry.dispose(); };
        };
    </script>
</body>
</html>
