file_info:
  file_code: "\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n\
    \        a. Extracts the function and class method details from the file summary.\n\
    \        b. Creates a lookup dictionary for function and class method details.\n\
    \        c. Creates a directed graph with nodes and edges representing the relationships\
    \ in the code.\n        d. Adds edges for function and class method calls.\n \
    \       e. Adds edge data to edges.\n        f. Returns a dictionary with nodes\
    \ and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree\
    \ function performs the following:\n        a. Extracts control flow tree from\
    \ AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow\
    \ function performs the following:\n        a. Gets starting points from the code\
    \ graph.\n        b. Reorganizes the control flow structure recursively.\n   \
    \     c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element\
    \ function performs the following:\n        a. Gets plantUML code for each element.\n\
    \        b. Returns plantUML code for each element.\n[req05] The get_plantUML\
    \ function performs the following: \n        a. Gets plantUML code for entire\
    \ file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph\
    \ function performs the following:\n        a. Gets the entire code graph\n  \
    \      b. Gets the control flow structure\n        c. Gets the plantUML code\n\
    \        d. Returns entire code graph, control flow structure and plantUML code\n\
    \"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\n\
    import networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict,\
    \ str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n\
    \    Create a dictionary representation of file details.\n    Args:\n        file_summary:\
    \ Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n\
    \        dict: A dictionary with nodes and edges representing the relationships\
    \ in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries\
    \ for function and class method details\n    function_details_lookup = {}\n  \
    \  for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n\
    \    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"\
    ]:\n        for (\n            class_name,\n            class_details,\n     \
    \   ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)\
    \  # Add class as a graph node\n            for method_name, method_details in\
    \ class_details[\"method_defs\"].items():\n                qualified_method_name\
    \ = (\n                    f\"{class_name}.{method_name}\"  # Create method fully\
    \ qualified name\n                )\n                G.add_node(qualified_method_name)\
    \  # Add method as a graph node\n                class_method_details_lookup[\n\
    \                    qualified_method_name\n                ] = method_details\
    \  # Store method details\n                G.add_edge(\n                    class_name,\
    \ qualified_method_name\n                )  # Add edge from class to method\n\n\
    \    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n\
    \        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n\
    \        edge_data = {}\n        if target_details:\n            edge_data[\"\
    target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"\
    ] = list(set(target_details.get(\"returns\", [])))\n        if (\n           \
    \ source_details\n            and \"call_inputs\" in source_details\n        \
    \    and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"\
    target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\
    \n    # Helper function to add edge with data\n    def add_edge_with_data(\n \
    \       source: str, target: str, init_method: Optional[str] = None\n    ) ->\
    \ None:\n        target_details = class_method_details_lookup.get(\n         \
    \   init_method or target\n        ) or function_details_lookup.get(target)\n\
    \        source_details = function_details_lookup.get(\n            source\n \
    \       ) or class_method_details_lookup.get(source)\n        G.add_edge(\n  \
    \          source,\n            target,\n            **get_edge_data_from_details(target_details,\
    \ source_details, target),\n        )\n\n    # Helper function to add edges for\
    \ function or class method calls\n    def add_edges_for_calls(source_name, calls):\n\
    \        class_names = [\n            list(class_def.keys())[0] for class_def\
    \ in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n \
    \           called_class_name = called.split(\".\")[0]\n            if called.startswith(\"\
    self.\"):\n                method_name = called.replace(\"self.\", \"\")\n   \
    \             fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
    \n                if fully_qualified_name in class_method_details_lookup:\n  \
    \                  add_edge_with_data(source_name, fully_qualified_name)\n   \
    \                 continue\n            if (\n                called in function_details_lookup\n\
    \                or called in class_method_details_lookup\n                or\
    \ f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n\
    \            ):\n                add_edge_with_data(source_name, called)\n   \
    \         elif called_class_name in class_names:\n                init_method\
    \ = None\n                init_method_name = f\"{called}.__init__\"\n        \
    \        if init_method_name in class_method_details_lookup:\n               \
    \     init_method = init_method_name\n                add_edge_with_data(source_name,\
    \ called, init_method)\n            else:\n                G.add_node(called)\n\
    \                add_edge_with_data(source_name, called)\n\n    # Add function\
    \ nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n\
    \        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n\
    \        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges\
    \ for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n\
    \        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n  \
    \  # Add edge data to edges and create node and edges to return\n    for edge\
    \ in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n\
    \            target\n        ) or class_method_details_lookup.get(target)\n  \
    \      source_details = function_details_lookup.get(\n            source\n   \
    \     ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details,\
    \ source_details, target)\n        G[source][target].update(edge_data)\n    nodes\
    \ = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1],\
    \ **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that\
    \ are not either a source of an edge or a target of an edge\n    nodes_to_remove\
    \ = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge\
    \ in edges] and node not in [\n            edge[\"target\"] for edge in edges\n\
    \        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\"\
    : nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST])\
    \ -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n\
    \    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree:\
    \ control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map\
    \ = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\"\
    ,\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For:\
    \ \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n    \
    \    ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If:\
    \ \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n      \
    \  node_type = type(node)\n        if node_type not in node_keywords_map:\n  \
    \          control_flow_tree.append(ast.unparse(node))\n            continue\n\
    \        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\"\
    :\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n\
    \            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == \"\
    class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == \"\
    while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value\
    \ = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key:\
    \ value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)}\
    \ in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == \"\
    with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\
    \n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key:\
    \ value})\n        elif keyword == \"return\":\n            key = \"return\"\n\
    \            value = [ast.unparse(node.value)] if node.value is not None else\
    \ []\n            control_flow_tree.append({key: value})\n        elif keyword\
    \ == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n           \
    \ value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n\
    \            orelse = node.orelse\n            while orelse and isinstance(orelse[0],\
    \ ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n  \
    \              value = extract_control_flow_tree(orelse[0].body)\n           \
    \     if_block[key] = value\n                orelse = orelse[0].orelse\n     \
    \       if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n\
    \                if_block[key] = value\n            control_flow_tree.append(if_block)\n\
    \        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n\
    \            except_block = []\n            for handler in node.handlers:\n  \
    \              h_type = ast.unparse(handler.type) if handler.type is not None\
    \ else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n\
    \                    if isinstance(handler.name, ast.Name)\n                 \
    \   else \"\"\n                )\n                key = f\"except {h_type} as\
    \ {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n\
    \                except_block.append({key: value})\n            control_flow_dict\
    \ = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n\
    \                else_block = extract_control_flow_tree(node.orelse)\n       \
    \         control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n\
    \                finally_block = extract_control_flow_tree(node.finalbody)\n \
    \               control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n\
    \        else:\n            control_flow_tree.append(ast.unparse(node))\n\n  \
    \  return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n\
    \    \"\"\"\n    Reorganize control flow structure to match the code graph.\n\
    \    Args:\n        file_details: file details\n        control_flow_structure:\
    \ control flow structure\n    Returns:\n        reorganized_control_flow_structure:\
    \ reorganized control flow structure\n    \"\"\"\n    # Get starting points from\
    \ the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"\
    edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node\
    \ not in targets]\n\n    # Define a function to reorganize the structure recursively\n\
    \    def reorganize_structure(structure, start_points):\n        organized, seen\
    \ = [], set()\n\n        # Iterate through each start point and find matching\
    \ elements in structure\n        for start in start_points:\n            for element\
    \ in structure:\n                if isinstance(element, dict):\n             \
    \       key = next(iter(element))  # Get the first key of the dictionary\n   \
    \                 if (\n                        start in key\n               \
    \     ):  # Add element if it matches the start point and hasn't been seen\n \
    \                       element_id = json.dumps(element)\n                   \
    \     if element_id not in seen:\n                            organized.append(element)\n\
    \                            seen.add(element_id)\n                elif (\n  \
    \                  isinstance(element, str) and start in element\n           \
    \     ):  # Handle string elements\n                    organized.append(element)\n\
    \n        # Append elements not included in the organized list\n        remaining\
    \ = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n\
    \        return organized\n\n    # Reorganize the control flow structure recursively\n\
    \    return reorganize_structure(control_flow_structure, starting_points)\n\n\n\
    def get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML\
    \ code for each element.\n    Args:\n        element: element\n        indentation:\
    \ current indentation level\n    Returns:\n        plantuml_str: plantUML code\
    \ for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element,\
    \ dict):\n        key = next(iter(element))\n        value = element[key]\n  \
    \      if key.startswith(\"def \") or key.startswith(\"async def \"):\n      \
    \      plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation\
    \ = indentation + \"  \"\n        elif key.startswith(\"class \"):\n         \
    \   plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation\
    \ = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str\
    \ += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation\
    \ + \"  \"\n        elif (\n            key.startswith(\"for \")\n           \
    \ or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n\
    \        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\\
    n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"\
    try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n          \
    \  inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except\
    \ \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n\
    \            inner_indentation = indentation + \"  \"\n        else:\n       \
    \     plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation\
    \ = indentation\n\n        if isinstance(value, list):\n            for child\
    \ in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\
    \n        if key.startswith(\"def \") or key.startswith(\"class \"):\n       \
    \     plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"\
    if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"\
    while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"\
    try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str\
    \ += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str\
    \ += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n\
    \    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n\
    \        file_details: file details\n    Returns:\n        plantuml_str: plantUML\
    \ code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for\
    \ element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element,\
    \ \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\n\
    def get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and\
    \ control flow to file details.\n    Args:\n        file_details: file details\n\
    \    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n    \
    \    entire_code_graph = code_graph(file_summary)\n        control_flow_tree =\
    \ extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n\
    \            entire_code_graph, control_flow_tree\n        )\n        plantUML\
    \ = get_plantUML(control_flow_structure)\n    except Exception as e:\n       \
    \ control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:',\
    \ file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:',\
    \ control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph,\
    \ control_flow_structure, plantUML\n"
  file_dependencies:
  - json
  - ast
  - typing
  - networkx
  file_functions:
  - code_graph
  - get_edge_data_from_details
  - add_edge_with_data
  - add_edges_for_calls
  - extract_control_flow_tree
  - reorganize_control_flow
  - reorganize_structure
  - get_plantUML_element
  - get_plantUML
  - get_code_graph
  file_classes: []
  file_constants: []
  file_summary: '{dependencies: [json, ast, typing, networkx], function_defs: [{code_graph:
    {inputs: [file_summary], calls: [nx.DiGraph, function_details_lookup.update, class_def.items,
    G.add_node, class_details[''method_defs''].items, G.add_edge, target_details.get,
    list, set, class_method_details_lookup.get, function_details_lookup.get, get_edge_data_from_details,
    class_def.keys, called.split, called.startswith, called.replace, source_name.split,
    add_edge_with_data, function_details_lookup.items, add_edges_for_calls, class_method_details_lookup.items,
    G[source][target].update, G.edges.data, nodes_to_remove.append], call_inputs:
    {nx.DiGraph: [], function_details_lookup.update: [function_def], class_def.items:
    [], G.add_node: [class_name, qualified_method_name, called, function_name], class_details[''method_defs''].items:
    [], G.add_edge: [class_name, qualified_method_name, source, target], target_details.get:
    [''inputs'', ''returns'', []], list: [set(target_details.get(''returns'', [])),
    class_def.keys(), G.nodes], set: [target_details.get(''returns'', [])], class_method_details_lookup.get:
    [init_method or target, source, target, source], function_details_lookup.get:
    [target, source, target, source], get_edge_data_from_details: [target_details,
    source_details, target, target_details, source_details, target], class_def.keys:
    [], called.split: [''.''], called.startswith: [''self.''], called.replace: [''self.'',
    ''''], source_name.split: [''.'', ''.''], add_edge_with_data: [source_name, fully_qualified_name,
    source_name, called, source_name, called, init_method, source_name, called], function_details_lookup.items:
    [], add_edges_for_calls: [func_name, details[''calls''], qualified_method_name,
    details[''calls'']], class_method_details_lookup.items: [], G[source][target].update:
    [edge_data], G.edges.data: [], nodes_to_remove.append: [node]}, returns: [{''nodes'':
    nodes, ''edges'': edges}, edge_data]}}, {get_edge_data_from_details: {inputs:
    [target_details, source_details, target], calls: [target_details.get, list, set],
    call_inputs: {target_details.get: [''inputs'', ''returns'', []], list: [set(target_details.get(''returns'',
    []))], set: [target_details.get(''returns'', [])]}, returns: [edge_data]}}, {add_edge_with_data:
    {inputs: [source, target, init_method], calls: [class_method_details_lookup.get,
    function_details_lookup.get, G.add_edge, get_edge_data_from_details], call_inputs:
    {class_method_details_lookup.get: [init_method or target, source], function_details_lookup.get:
    [target, source], G.add_edge: [source, target], get_edge_data_from_details: [target_details,
    source_details, target]}, returns: []}}, {add_edges_for_calls: {inputs: [source_name,
    calls], calls: [list, class_def.keys, called.split, called.startswith, called.replace,
    source_name.split, add_edge_with_data, G.add_node], call_inputs: {list: [class_def.keys()],
    class_def.keys: [], called.split: [''.''], called.startswith: [''self.''], called.replace:
    [''self.'', ''''], source_name.split: [''.'', ''.''], add_edge_with_data: [source_name,
    fully_qualified_name, source_name, called, source_name, called, init_method, source_name,
    called], G.add_node: [called]}, returns: []}}, {extract_control_flow_tree: {inputs:
    [nodes], calls: [type, control_flow_tree.append, ast.unparse, '', ''.join, extract_control_flow_tree,
    isinstance, except_block.append], call_inputs: {type: [node], control_flow_tree.append:
    [ast.unparse(node), {key: value}, {key: value}, {key: value}, {key: value}, {key:
    value}, {key: value}, if_block, control_flow_dict, ast.unparse(node)], ast.unparse:
    [node, arg, node.test, node.target, node.iter, item, node.value, node.test, orelse[0].test,
    handler.type, handler.name, node], '', ''.join: [[ast.unparse(arg) for arg in
    node.args.args], [ast.unparse(item) for item in node.items]], extract_control_flow_tree:
    [node.body, node.body, node.body, node.body, node.body, node.body, orelse[0].body,
    orelse, node.body, handler.body, node.orelse, node.finalbody], isinstance: [orelse[0],
    ast.If, handler.name, ast.Name], except_block.append: [{key: value}]}, returns:
    [control_flow_tree]}}, {reorganize_control_flow: {inputs: [code_graph, control_flow_structure],
    calls: [set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend,
    reorganize_structure], call_inputs: {set: [], isinstance: [element, dict, element,
    str], next: [iter(element)], iter: [element], json.dumps: [element, elem], organized.append:
    [element, element], seen.add: [element_id], organized.extend: [remaining], reorganize_structure:
    [control_flow_structure, starting_points]}, returns: [reorganize_structure(control_flow_structure,
    starting_points), organized]}}, {reorganize_structure: {inputs: [structure, start_points],
    calls: [set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend],
    call_inputs: {set: [], isinstance: [element, dict, element, str], next: [iter(element)],
    iter: [element], json.dumps: [element, elem], organized.append: [element, element],
    seen.add: [element_id], organized.extend: [remaining]}, returns: [organized]}},
    {get_plantUML_element: {inputs: [element, indentation], calls: [isinstance, next,
    iter, key.startswith, get_plantUML_element], call_inputs: {isinstance: [element,
    dict, value, list, element, str], next: [iter(element)], iter: [element], key.startswith:
    [''def '', ''async def '', ''class '', ''if '', ''for '', ''while '', ''asyncfor
    '', ''try '', ''except '', ''def '', ''class '', ''if '', ''for '', ''while '',
    ''asyncfor '', ''try '', ''except ''], get_plantUML_element: [child, inner_indentation]},
    returns: [plantuml_str]}}, {get_plantUML: {inputs: [control_flow_structure], calls:
    [get_plantUML_element], call_inputs: {get_plantUML_element: [element, ''  '']},
    returns: [plantuml_str]}}, {get_code_graph: {inputs: [file_summary, file_ast],
    calls: [code_graph, extract_control_flow_tree, reorganize_control_flow, get_plantUML,
    str], call_inputs: {code_graph: [file_summary], extract_control_flow_tree: [file_ast.body],
    reorganize_control_flow: [entire_code_graph, control_flow_tree], get_plantUML:
    [control_flow_structure], str: [e, e]}, returns: [(entire_code_graph, control_flow_structure,
    plantUML)]}}], class_defs: []}'
  file_code_simplified: "import ast\nimport json\nfrom typing import Dict, List, Optional,\
    \ Union\nimport networkx as nx\n\ndef code_graph(file_summary: Dict[str, Union[Dict,\
    \ str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    G = nx.DiGraph()\n\
    \    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n\
    \        function_details_lookup.update(function_def)\n    class_method_details_lookup\
    \ = {}\n    for class_def in file_summary['class_defs']:\n        for class_name,\
    \ class_details in class_def.items():\n            G.add_node(class_name)\n  \
    \          for method_name, method_details in class_details['method_defs'].items():\n\
    \                qualified_method_name = f'{class_name}.{method_name}'\n     \
    \           G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name]\
    \ = method_details\n                G.add_edge(class_name, qualified_method_name)\n\
    \n    def get_edge_data_from_details(target_details: dict, source_details: dict,\
    \ target: str) -> dict:\n        edge_data = {}\n        if target_details:\n\
    \            edge_data['target_inputs'] = target_details.get('inputs')\n     \
    \       edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n\
    \        if source_details and 'call_inputs' in source_details and (target in\
    \ source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n\
    \        return edge_data\n\n    def add_edge_with_data(source: str, target: str,\
    \ init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method\
    \ or target) or function_details_lookup.get(target)\n        source_details =\
    \ function_details_lookup.get(source) or class_method_details_lookup.get(source)\n\
    \        G.add_edge(source, target, **get_edge_data_from_details(target_details,\
    \ source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n\
    \        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n\
    \        for called in calls:\n            called_class_name = called.split('.')[0]\n\
    \            if called.startswith('self.'):\n                method_name = called.replace('self.',\
    \ '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
    \n                if fully_qualified_name in class_method_details_lookup:\n  \
    \                  add_edge_with_data(source_name, fully_qualified_name)\n   \
    \                 continue\n            if called in function_details_lookup or\
    \ called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\"\
    \ in class_method_details_lookup:\n                add_edge_with_data(source_name,\
    \ called)\n            elif called_class_name in class_names:\n              \
    \  init_method = None\n                init_method_name = f'{called}.__init__'\n\
    \                if init_method_name in class_method_details_lookup:\n       \
    \             init_method = init_method_name\n                add_edge_with_data(source_name,\
    \ called, init_method)\n            else:\n                G.add_node(called)\n\
    \                add_edge_with_data(source_name, called)\n    for function_name\
    \ in function_details_lookup:\n        G.add_node(function_name)\n    for func_name,\
    \ details in function_details_lookup.items():\n        add_edges_for_calls(func_name,\
    \ details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n\
    \        add_edges_for_calls(qualified_method_name, details['calls'])\n    for\
    \ edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target)\
    \ or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source)\
    \ or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details,\
    \ source_details, target)\n        G[source][target].update(edge_data)\n    nodes\
    \ = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]}\
    \ for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n\
    \        if node not in [edge['source'] for edge in edges] and node not in [edge['target']\
    \ for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes':\
    \ nodes, 'edges': edges}\n\ndef extract_control_flow_tree(nodes: List[ast.AST])\
    \ -> List[Union[str, dict]]:\n    control_flow_tree = []\n    node_keywords_map\
    \ = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class',\
    \ ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith:\
    \ 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in\
    \ nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n\
    \            control_flow_tree.append(ast.unparse(node))\n            continue\n\
    \        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n\
    \            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n\
    \            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n\
    \            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n\
    \            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n\
    \            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n\
    \            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key:\
    \ value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item)\
    \ for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n\
    \            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n\
    \            key = 'return'\n            value = [ast.unparse(node.value)] if\
    \ node.value is not None else []\n            control_flow_tree.append({key: value})\n\
    \        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n\
    \            value = extract_control_flow_tree(node.body)\n            if_block\
    \ = {key: value}\n            orelse = node.orelse\n            while orelse and\
    \ isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n\
    \                value = extract_control_flow_tree(orelse[0].body)\n         \
    \       if_block[key] = value\n                orelse = orelse[0].orelse\n   \
    \         if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n\
    \                if_block[key] = value\n            control_flow_tree.append(if_block)\n\
    \        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n\
    \            except_block = []\n            for handler in node.handlers:\n  \
    \              h_type = ast.unparse(handler.type) if handler.type is not None\
    \ else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name,\
    \ ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n \
    \               value = extract_control_flow_tree(handler.body)\n            \
    \    except_block.append({key: value})\n            control_flow_dict = {'try':\
    \ try_block, 'except': except_block}\n            if node.orelse:\n          \
    \      else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else']\
    \ = else_block\n            if node.finalbody:\n                finally_block\
    \ = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally']\
    \ = finally_block\n            control_flow_tree.append(control_flow_dict)\n \
    \       else:\n            control_flow_tree.append(ast.unparse(node))\n    return\
    \ control_flow_tree\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n\
    \    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points\
    \ = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure,\
    \ start_points):\n        organized, seen = ([], set())\n        for start in\
    \ start_points:\n            for element in structure:\n                if isinstance(element,\
    \ dict):\n                    key = next(iter(element))\n                    if\
    \ start in key:\n                        element_id = json.dumps(element)\n  \
    \                      if element_id not in seen:\n                          \
    \  organized.append(element)\n                            seen.add(element_id)\n\
    \                elif isinstance(element, str) and start in element:\n       \
    \             organized.append(element)\n        remaining = [elem for elem in\
    \ structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n\
    \        return organized\n    return reorganize_structure(control_flow_structure,\
    \ starting_points)\n\ndef get_plantUML_element(element, indentation=''):\n   \
    \ plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n\
    \        value = element[key]\n        if key.startswith('def ') or key.startswith('async\
    \ def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n   \
    \         inner_indentation = indentation + '  '\n        elif key.startswith('class\
    \ '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n     \
    \       inner_indentation = indentation + '  '\n        elif key.startswith('if\
    \ '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n      \
    \      inner_indentation = indentation + '  '\n        elif key.startswith('for\
    \ ') or key.startswith('while ') or key.startswith('asyncfor '):\n           \
    \ plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation\
    \ = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str\
    \ += f'{indentation}try {{\\n'\n            inner_indentation = indentation +\
    \ '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch\
    \ ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n     \
    \   else:\n            plantuml_str += f'{indentation}:{key};\\n'\n          \
    \  inner_indentation = indentation\n        if isinstance(value, list):\n    \
    \        for child in value:\n                plantuml_str += get_plantUML_element(child,\
    \ inner_indentation)\n        if key.startswith('def ') or key.startswith('class\
    \ '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if\
    \ ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor\
    \ ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str\
    \ += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str\
    \ += f'{indentation}:{element};\\n'\n    return plantuml_str\n\ndef get_plantUML(control_flow_structure):\n\
    \    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n\
    \        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str\
    \ += 'end\\n@enduml'\n    return plantuml_str\n\ndef get_code_graph(file_summary,\
    \ file_ast):\n    try:\n        entire_code_graph = code_graph(file_summary)\n\
    \        control_flow_tree = extract_control_flow_tree(file_ast.body)\n      \
    \  control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n\
    \        plantUML = get_plantUML(control_flow_structure)\n    except Exception\
    \ as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\
    \    return (entire_code_graph, control_flow_structure, plantUML)"
  entire_code_graph:
    nodes:
    - code_graph
    - get_edge_data_from_details
    - add_edge_with_data
    - add_edges_for_calls
    - extract_control_flow_tree
    - reorganize_control_flow
    - reorganize_structure
    - get_plantUML_element
    - get_plantUML
    - get_code_graph
    - nx.DiGraph
    - function_details_lookup.update
    - class_def.items
    - G.add_node
    - class_details['method_defs'].items
    - G.add_edge
    - target_details.get
    - list
    - set
    - class_method_details_lookup.get
    - function_details_lookup.get
    - class_def.keys
    - called.split
    - called.startswith
    - called.replace
    - source_name.split
    - function_details_lookup.items
    - class_method_details_lookup.items
    - G[source][target].update
    - G.edges.data
    - nodes_to_remove.append
    - type
    - control_flow_tree.append
    - ast.unparse
    - ''', ''.join'
    - isinstance
    - except_block.append
    - next
    - iter
    - json.dumps
    - organized.append
    - seen.add
    - organized.extend
    - key.startswith
    - str
    edges:
    - source: code_graph
      target: nx.DiGraph
      target_inputs: []
    - source: code_graph
      target: function_details_lookup.update
      target_inputs:
      - function_def
    - source: code_graph
      target: class_def.items
      target_inputs: []
    - source: code_graph
      target: G.add_node
      target_inputs:
      - class_name
      - qualified_method_name
      - called
      - function_name
    - source: code_graph
      target: class_details['method_defs'].items
      target_inputs: []
    - source: code_graph
      target: G.add_edge
      target_inputs:
      - class_name
      - qualified_method_name
      - source
      - target
    - source: code_graph
      target: target_details.get
      target_inputs:
      - '''inputs'''
      - '''returns'''
      - '[]'
    - source: code_graph
      target: list
      target_inputs:
      - set(target_details.get('returns', []))
      - class_def.keys()
      - G.nodes
    - source: code_graph
      target: set
      target_inputs:
      - target_details.get('returns', [])
    - source: code_graph
      target: class_method_details_lookup.get
      target_inputs:
      - init_method or target
      - source
      - target
      - source
    - source: code_graph
      target: function_details_lookup.get
      target_inputs:
      - target
      - source
      - target
      - source
    - source: code_graph
      target: get_edge_data_from_details
      target_inputs:
      - target_details
      - source_details
      - target
      - target_details
      - source_details
      - target
      target_returns:
      - edge_data
    - source: code_graph
      target: class_def.keys
      target_inputs: []
    - source: code_graph
      target: called.split
      target_inputs:
      - '''.'''
    - source: code_graph
      target: called.startswith
      target_inputs:
      - '''self.'''
    - source: code_graph
      target: called.replace
      target_inputs:
      - '''self.'''
      - ''''''
    - source: code_graph
      target: source_name.split
      target_inputs:
      - '''.'''
      - '''.'''
    - source: code_graph
      target: add_edge_with_data
      target_inputs:
      - source_name
      - fully_qualified_name
      - source_name
      - called
      - source_name
      - called
      - init_method
      - source_name
      - called
      target_returns: []
    - source: code_graph
      target: function_details_lookup.items
      target_inputs: []
    - source: code_graph
      target: add_edges_for_calls
      target_inputs:
      - func_name
      - details['calls']
      - qualified_method_name
      - details['calls']
      target_returns: []
    - source: code_graph
      target: class_method_details_lookup.items
      target_inputs: []
    - source: code_graph
      target: G[source][target].update
      target_inputs:
      - edge_data
    - source: code_graph
      target: G.edges.data
      target_inputs: []
    - source: code_graph
      target: nodes_to_remove.append
      target_inputs:
      - node
    - source: get_edge_data_from_details
      target: target_details.get
      target_inputs:
      - '''inputs'''
      - '''returns'''
      - '[]'
    - source: get_edge_data_from_details
      target: list
      target_inputs:
      - set(target_details.get('returns', []))
    - source: get_edge_data_from_details
      target: set
      target_inputs:
      - target_details.get('returns', [])
    - source: add_edge_with_data
      target: class_method_details_lookup.get
      target_inputs:
      - init_method or target
      - source
    - source: add_edge_with_data
      target: function_details_lookup.get
      target_inputs:
      - target
      - source
    - source: add_edge_with_data
      target: G.add_edge
      target_inputs:
      - source
      - target
    - source: add_edge_with_data
      target: get_edge_data_from_details
      target_inputs:
      - target_details
      - source_details
      - target
      target_returns:
      - edge_data
    - source: add_edges_for_calls
      target: list
      target_inputs:
      - class_def.keys()
    - source: add_edges_for_calls
      target: class_def.keys
      target_inputs: []
    - source: add_edges_for_calls
      target: called.split
      target_inputs:
      - '''.'''
    - source: add_edges_for_calls
      target: called.startswith
      target_inputs:
      - '''self.'''
    - source: add_edges_for_calls
      target: called.replace
      target_inputs:
      - '''self.'''
      - ''''''
    - source: add_edges_for_calls
      target: source_name.split
      target_inputs:
      - '''.'''
      - '''.'''
    - source: add_edges_for_calls
      target: add_edge_with_data
      target_inputs:
      - source_name
      - fully_qualified_name
      - source_name
      - called
      - source_name
      - called
      - init_method
      - source_name
      - called
      target_returns: []
    - source: add_edges_for_calls
      target: G.add_node
      target_inputs:
      - called
    - source: extract_control_flow_tree
      target: type
      target_inputs:
      - node
    - source: extract_control_flow_tree
      target: control_flow_tree.append
      target_inputs:
      - ast.unparse(node)
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - if_block
      - control_flow_dict
      - ast.unparse(node)
    - source: extract_control_flow_tree
      target: ast.unparse
      target_inputs:
      - node
      - arg
      - node.test
      - node.target
      - node.iter
      - item
      - node.value
      - node.test
      - orelse[0].test
      - handler.type
      - handler.name
      - node
    - source: extract_control_flow_tree
      target: ''', ''.join'
      target_inputs:
      - '[ast.unparse(arg) for arg in node.args.args]'
      - '[ast.unparse(item) for item in node.items]'
    - source: extract_control_flow_tree
      target: extract_control_flow_tree
      target_inputs:
      - node.body
      - node.body
      - node.body
      - node.body
      - node.body
      - node.body
      - orelse[0].body
      - orelse
      - node.body
      - handler.body
      - node.orelse
      - node.finalbody
      target_returns:
      - control_flow_tree
    - source: extract_control_flow_tree
      target: isinstance
      target_inputs:
      - orelse[0]
      - ast.If
      - handler.name
      - ast.Name
    - source: extract_control_flow_tree
      target: except_block.append
      target_inputs:
      - '{key: value}'
    - source: reorganize_control_flow
      target: set
      target_inputs: []
    - source: reorganize_control_flow
      target: isinstance
      target_inputs:
      - element
      - dict
      - element
      - str
    - source: reorganize_control_flow
      target: next
      target_inputs:
      - iter(element)
    - source: reorganize_control_flow
      target: iter
      target_inputs:
      - element
    - source: reorganize_control_flow
      target: json.dumps
      target_inputs:
      - element
      - elem
    - source: reorganize_control_flow
      target: organized.append
      target_inputs:
      - element
      - element
    - source: reorganize_control_flow
      target: seen.add
      target_inputs:
      - element_id
    - source: reorganize_control_flow
      target: organized.extend
      target_inputs:
      - remaining
    - source: reorganize_control_flow
      target: reorganize_structure
      target_inputs:
      - control_flow_structure
      - starting_points
      target_returns:
      - organized
    - source: reorganize_structure
      target: set
      target_inputs: []
    - source: reorganize_structure
      target: isinstance
      target_inputs:
      - element
      - dict
      - element
      - str
    - source: reorganize_structure
      target: next
      target_inputs:
      - iter(element)
    - source: reorganize_structure
      target: iter
      target_inputs:
      - element
    - source: reorganize_structure
      target: json.dumps
      target_inputs:
      - element
      - elem
    - source: reorganize_structure
      target: organized.append
      target_inputs:
      - element
      - element
    - source: reorganize_structure
      target: seen.add
      target_inputs:
      - element_id
    - source: reorganize_structure
      target: organized.extend
      target_inputs:
      - remaining
    - source: get_plantUML_element
      target: isinstance
      target_inputs:
      - element
      - dict
      - value
      - list
      - element
      - str
    - source: get_plantUML_element
      target: next
      target_inputs:
      - iter(element)
    - source: get_plantUML_element
      target: iter
      target_inputs:
      - element
    - source: get_plantUML_element
      target: key.startswith
      target_inputs:
      - '''def '''
      - '''async def '''
      - '''class '''
      - '''if '''
      - '''for '''
      - '''while '''
      - '''asyncfor '''
      - '''try '''
      - '''except '''
      - '''def '''
      - '''class '''
      - '''if '''
      - '''for '''
      - '''while '''
      - '''asyncfor '''
      - '''try '''
      - '''except '''
    - source: get_plantUML_element
      target: get_plantUML_element
      target_inputs:
      - child
      - inner_indentation
      target_returns:
      - plantuml_str
    - source: get_plantUML
      target: get_plantUML_element
      target_inputs:
      - element
      - '''  '''
      target_returns:
      - plantuml_str
    - source: get_code_graph
      target: code_graph
      target_inputs:
      - file_summary
      target_returns:
      - '{''nodes'': nodes, ''edges'': edges}'
      - edge_data
    - source: get_code_graph
      target: extract_control_flow_tree
      target_inputs:
      - file_ast.body
      target_returns:
      - control_flow_tree
    - source: get_code_graph
      target: reorganize_control_flow
      target_inputs:
      - entire_code_graph
      - control_flow_tree
      target_returns:
      - reorganize_structure(control_flow_structure, starting_points)
      - organized
    - source: get_code_graph
      target: get_plantUML
      target_inputs:
      - control_flow_structure
      target_returns:
      - plantuml_str
    - source: get_code_graph
      target: str
      target_inputs:
      - e
      - e
  control_flow_structure:
  - def get_code_graph(file_summary, file_ast):
    - try:
      - entire_code_graph = code_graph(file_summary)
      - control_flow_tree = extract_control_flow_tree(file_ast.body)
      - control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)
      - plantUML = get_plantUML(control_flow_structure)
      except:
      - 'except Exception as :':
        - control_flow_structure = [str(e)]
        - plantUML = str(e)
    - return:
      - (entire_code_graph, control_flow_structure, plantUML)
  - import ast
  - import json
  - from typing import Dict, List, Optional, Union
  - import networkx as nx
  - 'def code_graph(file_summary: Dict[str, Union[Dict, str]])':
    - G = nx.DiGraph()
    - function_details_lookup = {}
    - for function_def in file_summary['function_defs']:
      - function_details_lookup.update(function_def)
    - class_method_details_lookup = {}
    - for class_def in file_summary['class_defs']:
      - for (class_name, class_details) in class_def.items():
        - G.add_node(class_name)
        - for (method_name, method_details) in class_details['method_defs'].items():
          - qualified_method_name = f'{class_name}.{method_name}'
          - G.add_node(qualified_method_name)
          - class_method_details_lookup[qualified_method_name] = method_details
          - G.add_edge(class_name, qualified_method_name)
    - 'def get_edge_data_from_details(target_details: dict, source_details: dict, target: str)':
      - edge_data = {}
      - if target_details:
        - edge_data['target_inputs'] = target_details.get('inputs')
        - edge_data['target_returns'] = list(set(target_details.get('returns', [])))
      - if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):
        - edge_data['target_inputs'] = source_details['call_inputs'][target]
      - return:
        - edge_data
    - 'def add_edge_with_data(source: str, target: str, init_method: Optional[str])':
      - target_details = class_method_details_lookup.get(init_method or target) or
        function_details_lookup.get(target)
      - source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)
      - G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details,
        target))
    - def add_edges_for_calls(source_name, calls):
      - class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]
      - for called in calls:
        - called_class_name = called.split('.')[0]
        - if called.startswith('self.'):
          - method_name = called.replace('self.', '')
          - fully_qualified_name = f"{source_name.split('.')[0]}.{method_name}"
          - if fully_qualified_name in class_method_details_lookup:
            - add_edge_with_data(source_name, fully_qualified_name)
            - continue
        - ? if called in function_details_lookup or called in class_method_details_lookup
            or f"{source_name.split('.')[0]}.{called}" in class_method_details_lookup
          : - add_edge_with_data(source_name, called)
          elif called_class_name in class_names:
          - init_method = None
          - init_method_name = f'{called}.__init__'
          - if init_method_name in class_method_details_lookup:
            - init_method = init_method_name
          - add_edge_with_data(source_name, called, init_method)
          else:
          - G.add_node(called)
          - add_edge_with_data(source_name, called)
    - for function_name in function_details_lookup:
      - G.add_node(function_name)
    - for (func_name, details) in function_details_lookup.items():
      - add_edges_for_calls(func_name, details['calls'])
    - for (qualified_method_name, details) in class_method_details_lookup.items():
      - add_edges_for_calls(qualified_method_name, details['calls'])
    - for edge in G.edges:
      - source, target = edge
      - target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)
      - source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)
      - edge_data = get_edge_data_from_details(target_details, source_details, target)
      - G[source][target].update(edge_data)
    - nodes = list(G.nodes)
    - 'edges = [{''source'': edge[0], ''target'': edge[1], **edge[2]} for edge in
      G.edges.data()]'
    - nodes_to_remove = []
    - for node in nodes:
      - if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:
        - nodes_to_remove.append(node)
    - return:
      - '{''nodes'': nodes, ''edges'': edges}'
  - 'def extract_control_flow_tree(nodes: List[ast.AST])':
    - control_flow_tree = []
    - 'node_keywords_map = {ast.FunctionDef: ''def'', ast.AsyncFunctionDef: ''def'',
      ast.ClassDef: ''class'', ast.While: ''while'', ast.For: ''for'', ast.AsyncFor:
      ''for'', ast.With: ''with'', ast.AsyncWith: ''with'', ast.Return: ''return'',
      ast.If: ''if'', ast.Try: ''try''}'
    - for node in nodes:
      - node_type = type(node)
      - if node_type not in node_keywords_map:
        - control_flow_tree.append(ast.unparse(node))
        - continue
      - keyword = node_keywords_map[node_type]
      - if keyword == 'def':
        - args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])
        - key = f'def {node.name}({args_str})'
        - value = extract_control_flow_tree(node.body)
        - 'control_flow_tree.append({key: value})'
        elif keyword == 'class':
        - key = f'class {node.name}'
        - value = extract_control_flow_tree(node.body)
        - 'control_flow_tree.append({key: value})'
        elif keyword == 'while':
        - key = f'while {ast.unparse(node.test)}'
        - value = extract_control_flow_tree(node.body)
        - 'control_flow_tree.append({key: value})'
        elif keyword == 'for':
        - key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'
        - value = extract_control_flow_tree(node.body)
        - 'control_flow_tree.append({key: value})'
        elif keyword == 'with':
        - key = f"with {', '.join([ast.unparse(item) for item in node.items])}"
        - value = extract_control_flow_tree(node.body)
        - 'control_flow_tree.append({key: value})'
        elif keyword == 'return':
        - key = 'return'
        - value = [ast.unparse(node.value)] if node.value is not None else []
        - 'control_flow_tree.append({key: value})'
        elif keyword == 'if':
        - key = f'if {ast.unparse(node.test)}'
        - value = extract_control_flow_tree(node.body)
        - 'if_block = {key: value}'
        - orelse = node.orelse
        - while orelse and isinstance(orelse[0], ast.If):
          - key = f'elif {ast.unparse(orelse[0].test)}'
          - value = extract_control_flow_tree(orelse[0].body)
          - if_block[key] = value
          - orelse = orelse[0].orelse
        - if orelse:
          - key = 'else'
          - value = extract_control_flow_tree(orelse)
          - if_block[key] = value
        - control_flow_tree.append(if_block)
        elif keyword == 'try':
        - try_block = extract_control_flow_tree(node.body)
        - except_block = []
        - for handler in node.handlers:
          - h_type = ast.unparse(handler.type) if handler.type is not None else ''
          - h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name)
            else ''
          - key = f'except {h_type} as {h_name}:'
          - value = extract_control_flow_tree(handler.body)
          - 'except_block.append({key: value})'
        - 'control_flow_dict = {''try'': try_block, ''except'': except_block}'
        - if node.orelse:
          - else_block = extract_control_flow_tree(node.orelse)
          - control_flow_dict['else'] = else_block
        - if node.finalbody:
          - finally_block = extract_control_flow_tree(node.finalbody)
          - control_flow_dict['finally'] = finally_block
        - control_flow_tree.append(control_flow_dict)
        else:
        - control_flow_tree.append(ast.unparse(node))
    - return:
      - control_flow_tree
  - def reorganize_control_flow(code_graph, control_flow_structure):
    - targets = [edge['target'] for edge in code_graph['edges']]
    - starting_points = [node for node in code_graph['nodes'] if node not in targets]
    - def reorganize_structure(structure, start_points):
      - organized, seen = ([], set())
      - for start in start_points:
        - for element in structure:
          - if isinstance(element, dict):
            - key = next(iter(element))
            - if start in key:
              - element_id = json.dumps(element)
              - if element_id not in seen:
                - organized.append(element)
                - seen.add(element_id)
            elif isinstance(element, str) and start in element:
            - organized.append(element)
      - remaining = [elem for elem in structure if json.dumps(elem) not in seen]
      - organized.extend(remaining)
      - return:
        - organized
    - return:
      - reorganize_structure(control_flow_structure, starting_points)
  - def get_plantUML_element(element, indentation):
    - plantuml_str = ''
    - if isinstance(element, dict):
      - key = next(iter(element))
      - value = element[key]
      - if key.startswith('def ') or key.startswith('async def '):
        - plantuml_str += f'{indentation}def {value} {{\n'
        - inner_indentation = indentation + '  '
        elif key.startswith('class '):
        - plantuml_str += f'{indentation}class {value} {{\n'
        - inner_indentation = indentation + '  '
        elif key.startswith('if '):
        - plantuml_str += f'{indentation}if ({value}) {{\n'
        - inner_indentation = indentation + '  '
        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):
        - plantuml_str += f'{indentation}while ({value}) {{\n'
        - inner_indentation = indentation + '  '
        elif key.startswith('try '):
        - plantuml_str += f'{indentation}try {{\n'
        - inner_indentation = indentation + '  '
        elif key.startswith('except '):
        - plantuml_str += f'{indentation}catch ({value}) {{\n'
        - inner_indentation = indentation + '  '
        else:
        - plantuml_str += f'{indentation}:{key};\n'
        - inner_indentation = indentation
      - if isinstance(value, list):
        - for child in value:
          - plantuml_str += get_plantUML_element(child, inner_indentation)
      - if key.startswith('def ') or key.startswith('class '):
        - plantuml_str += f'{indentation}}}\n'
        ? elif key.startswith('if ') or key.startswith('for ') or key.startswith('while
          ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except
          ')
        : - plantuml_str += f'{indentation}}}\n'
      elif isinstance(element, str):
      - plantuml_str += f'{indentation}:{element};\n'
    - return:
      - plantuml_str
  - def get_plantUML(control_flow_structure):
    - plantuml_str = '@startuml\n'
    - for element in control_flow_structure:
      - plantuml_str += get_plantUML_element(element, '  ')
    - plantuml_str += 'end\n@enduml'
    - return:
      - plantuml_str
  plant_uml: "@startuml\n  def [{'try': ['entire_code_graph = code_graph(file_summary)',\
    \ 'control_flow_tree = extract_control_flow_tree(file_ast.body)', 'control_flow_structure\
    \ = reorganize_control_flow(entire_code_graph, control_flow_tree)', 'plantUML\
    \ = get_plantUML(control_flow_structure)'], 'except': [{'except Exception as :':\
    \ ['control_flow_structure = [str(e)]', 'plantUML = str(e)']}]}, {'return': ['(entire_code_graph,\
    \ control_flow_structure, plantUML)']}] {\n    :try;\n    :entire_code_graph =\
    \ code_graph(file_summary);\n    :control_flow_tree = extract_control_flow_tree(file_ast.body);\n\
    \    :control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree);\n\
    \    :plantUML = get_plantUML(control_flow_structure);\n    :return;\n    :(entire_code_graph,\
    \ control_flow_structure, plantUML);\n  }\n  :import ast;\n  :import json;\n \
    \ :from typing import Dict, List, Optional, Union;\n  :import networkx as nx;\n\
    \  def ['G = nx.DiGraph()', 'function_details_lookup = {}', {\"for function_def\
    \ in file_summary['function_defs']\": ['function_details_lookup.update(function_def)']},\
    \ 'class_method_details_lookup = {}', {\"for class_def in file_summary['class_defs']\"\
    : [{'for (class_name, class_details) in class_def.items()': ['G.add_node(class_name)',\
    \ {\"for (method_name, method_details) in class_details['method_defs'].items()\"\
    : [\"qualified_method_name = f'{class_name}.{method_name}'\", 'G.add_node(qualified_method_name)',\
    \ 'class_method_details_lookup[qualified_method_name] = method_details', 'G.add_edge(class_name,\
    \ qualified_method_name)']}]}]}, {'def get_edge_data_from_details(target_details:\
    \ dict, source_details: dict, target: str)': ['edge_data = {}', {'if target_details':\
    \ [\"edge_data['target_inputs'] = target_details.get('inputs')\", \"edge_data['target_returns']\
    \ = list(set(target_details.get('returns', [])))\"]}, {\"if source_details and\
    \ 'call_inputs' in source_details and (target in source_details['call_inputs'])\"\
    : [\"edge_data['target_inputs'] = source_details['call_inputs'][target]\"]}, {'return':\
    \ ['edge_data']}]}, {'def add_edge_with_data(source: str, target: str, init_method:\
    \ Optional[str])': ['target_details = class_method_details_lookup.get(init_method\
    \ or target) or function_details_lookup.get(target)', 'source_details = function_details_lookup.get(source)\
    \ or class_method_details_lookup.get(source)', 'G.add_edge(source, target, **get_edge_data_from_details(target_details,\
    \ source_details, target))']}, {'def add_edges_for_calls(source_name, calls)':\
    \ [\"class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\"\
    , {'for called in calls': [\"called_class_name = called.split('.')[0]\", {\"if\
    \ called.startswith('self.')\": [\"method_name = called.replace('self.', '')\"\
    , 'fully_qualified_name = f\"{source_name.split(\\'.\\')[0]}.{method_name}\"',\
    \ {'if fully_qualified_name in class_method_details_lookup': ['add_edge_with_data(source_name,\
    \ fully_qualified_name)', 'continue']}]}, {'if called in function_details_lookup\
    \ or called in class_method_details_lookup or f\"{source_name.split(\\'.\\')[0]}.{called}\"\
    \ in class_method_details_lookup': ['add_edge_with_data(source_name, called)'],\
    \ 'elif called_class_name in class_names': ['init_method = None', \"init_method_name\
    \ = f'{called}.__init__'\", {'if init_method_name in class_method_details_lookup':\
    \ ['init_method = init_method_name']}, 'add_edge_with_data(source_name, called,\
    \ init_method)'], 'else': ['G.add_node(called)', 'add_edge_with_data(source_name,\
    \ called)']}]}]}, {'for function_name in function_details_lookup': ['G.add_node(function_name)']},\
    \ {'for (func_name, details) in function_details_lookup.items()': [\"add_edges_for_calls(func_name,\
    \ details['calls'])\"]}, {'for (qualified_method_name, details) in class_method_details_lookup.items()':\
    \ [\"add_edges_for_calls(qualified_method_name, details['calls'])\"]}, {'for edge\
    \ in G.edges': ['source, target = edge', 'target_details = function_details_lookup.get(target)\
    \ or class_method_details_lookup.get(target)', 'source_details = function_details_lookup.get(source)\
    \ or class_method_details_lookup.get(source)', 'edge_data = get_edge_data_from_details(target_details,\
    \ source_details, target)', 'G[source][target].update(edge_data)']}, 'nodes =\
    \ list(G.nodes)', \"edges = [{'source': edge[0], 'target': edge[1], **edge[2]}\
    \ for edge in G.edges.data()]\", 'nodes_to_remove = []', {'for node in nodes':\
    \ [{\"if node not in [edge['source'] for edge in edges] and node not in [edge['target']\
    \ for edge in edges]\": ['nodes_to_remove.append(node)']}]}, {'return': [\"{'nodes':\
    \ nodes, 'edges': edges}\"]}] {\n    :G = nx.DiGraph();\n    :function_details_lookup\
    \ = {};\n    while (['function_details_lookup.update(function_def)']) {\n    \
    \  :function_details_lookup.update(function_def);\n    }\n    :class_method_details_lookup\
    \ = {};\n    while ([{'for (class_name, class_details) in class_def.items()':\
    \ ['G.add_node(class_name)', {\"for (method_name, method_details) in class_details['method_defs'].items()\"\
    : [\"qualified_method_name = f'{class_name}.{method_name}'\", 'G.add_node(qualified_method_name)',\
    \ 'class_method_details_lookup[qualified_method_name] = method_details', 'G.add_edge(class_name,\
    \ qualified_method_name)']}]}]) {\n      while (['G.add_node(class_name)', {\"\
    for (method_name, method_details) in class_details['method_defs'].items()\": [\"\
    qualified_method_name = f'{class_name}.{method_name}'\", 'G.add_node(qualified_method_name)',\
    \ 'class_method_details_lookup[qualified_method_name] = method_details', 'G.add_edge(class_name,\
    \ qualified_method_name)']}]) {\n        :G.add_node(class_name);\n        while\
    \ ([\"qualified_method_name = f'{class_name}.{method_name}'\", 'G.add_node(qualified_method_name)',\
    \ 'class_method_details_lookup[qualified_method_name] = method_details', 'G.add_edge(class_name,\
    \ qualified_method_name)']) {\n          :qualified_method_name = f'{class_name}.{method_name}';\n\
    \          :G.add_node(qualified_method_name);\n          :class_method_details_lookup[qualified_method_name]\
    \ = method_details;\n          :G.add_edge(class_name, qualified_method_name);\n\
    \        }\n      }\n    }\n    def ['edge_data = {}', {'if target_details': [\"\
    edge_data['target_inputs'] = target_details.get('inputs')\", \"edge_data['target_returns']\
    \ = list(set(target_details.get('returns', [])))\"]}, {\"if source_details and\
    \ 'call_inputs' in source_details and (target in source_details['call_inputs'])\"\
    : [\"edge_data['target_inputs'] = source_details['call_inputs'][target]\"]}, {'return':\
    \ ['edge_data']}] {\n      :edge_data = {};\n      if ([\"edge_data['target_inputs']\
    \ = target_details.get('inputs')\", \"edge_data['target_returns'] = list(set(target_details.get('returns',\
    \ [])))\"]) {\n        :edge_data['target_inputs'] = target_details.get('inputs');\n\
    \        :edge_data['target_returns'] = list(set(target_details.get('returns',\
    \ [])));\n      }\n      if ([\"edge_data['target_inputs'] = source_details['call_inputs'][target]\"\
    ]) {\n        :edge_data['target_inputs'] = source_details['call_inputs'][target];\n\
    \      }\n      :return;\n      :edge_data;\n    }\n    def ['target_details =\
    \ class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)',\
    \ 'source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)',\
    \ 'G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details,\
    \ target))'] {\n      :target_details = class_method_details_lookup.get(init_method\
    \ or target) or function_details_lookup.get(target);\n      :source_details =\
    \ function_details_lookup.get(source) or class_method_details_lookup.get(source);\n\
    \      :G.add_edge(source, target, **get_edge_data_from_details(target_details,\
    \ source_details, target));\n    }\n    def [\"class_names = [list(class_def.keys())[0]\
    \ for class_def in file_summary['class_defs']]\", {'for called in calls': [\"\
    called_class_name = called.split('.')[0]\", {\"if called.startswith('self.')\"\
    : [\"method_name = called.replace('self.', '')\", 'fully_qualified_name = f\"\
    {source_name.split(\\'.\\')[0]}.{method_name}\"', {'if fully_qualified_name in\
    \ class_method_details_lookup': ['add_edge_with_data(source_name, fully_qualified_name)',\
    \ 'continue']}]}, {'if called in function_details_lookup or called in class_method_details_lookup\
    \ or f\"{source_name.split(\\'.\\')[0]}.{called}\" in class_method_details_lookup':\
    \ ['add_edge_with_data(source_name, called)'], 'elif called_class_name in class_names':\
    \ ['init_method = None', \"init_method_name = f'{called}.__init__'\", {'if init_method_name\
    \ in class_method_details_lookup': ['init_method = init_method_name']}, 'add_edge_with_data(source_name,\
    \ called, init_method)'], 'else': ['G.add_node(called)', 'add_edge_with_data(source_name,\
    \ called)']}]}] {\n      :class_names = [list(class_def.keys())[0] for class_def\
    \ in file_summary['class_defs']];\n      while ([\"called_class_name = called.split('.')[0]\"\
    , {\"if called.startswith('self.')\": [\"method_name = called.replace('self.',\
    \ '')\", 'fully_qualified_name = f\"{source_name.split(\\'.\\')[0]}.{method_name}\"\
    ', {'if fully_qualified_name in class_method_details_lookup': ['add_edge_with_data(source_name,\
    \ fully_qualified_name)', 'continue']}]}, {'if called in function_details_lookup\
    \ or called in class_method_details_lookup or f\"{source_name.split(\\'.\\')[0]}.{called}\"\
    \ in class_method_details_lookup': ['add_edge_with_data(source_name, called)'],\
    \ 'elif called_class_name in class_names': ['init_method = None', \"init_method_name\
    \ = f'{called}.__init__'\", {'if init_method_name in class_method_details_lookup':\
    \ ['init_method = init_method_name']}, 'add_edge_with_data(source_name, called,\
    \ init_method)'], 'else': ['G.add_node(called)', 'add_edge_with_data(source_name,\
    \ called)']}]) {\n        :called_class_name = called.split('.')[0];\n       \
    \ if ([\"method_name = called.replace('self.', '')\", 'fully_qualified_name =\
    \ f\"{source_name.split(\\'.\\')[0]}.{method_name}\"', {'if fully_qualified_name\
    \ in class_method_details_lookup': ['add_edge_with_data(source_name, fully_qualified_name)',\
    \ 'continue']}]) {\n          :method_name = called.replace('self.', '');\n  \
    \        :fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
    ;\n          if (['add_edge_with_data(source_name, fully_qualified_name)', 'continue'])\
    \ {\n            :add_edge_with_data(source_name, fully_qualified_name);\n   \
    \         :continue;\n          }\n        }\n        if (['add_edge_with_data(source_name,\
    \ called)']) {\n          :add_edge_with_data(source_name, called);\n        }\n\
    \      }\n    }\n    while (['G.add_node(function_name)']) {\n      :G.add_node(function_name);\n\
    \    }\n    while ([\"add_edges_for_calls(func_name, details['calls'])\"]) {\n\
    \      :add_edges_for_calls(func_name, details['calls']);\n    }\n    while ([\"\
    add_edges_for_calls(qualified_method_name, details['calls'])\"]) {\n      :add_edges_for_calls(qualified_method_name,\
    \ details['calls']);\n    }\n    while (['source, target = edge', 'target_details\
    \ = function_details_lookup.get(target) or class_method_details_lookup.get(target)',\
    \ 'source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)',\
    \ 'edge_data = get_edge_data_from_details(target_details, source_details, target)',\
    \ 'G[source][target].update(edge_data)']) {\n      :source, target = edge;\n \
    \     :target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target);\n\
    \      :source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source);\n\
    \      :edge_data = get_edge_data_from_details(target_details, source_details,\
    \ target);\n      :G[source][target].update(edge_data);\n    }\n    :nodes = list(G.nodes);\n\
    \    :edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()];\n\
    \    :nodes_to_remove = [];\n    while ([{\"if node not in [edge['source'] for\
    \ edge in edges] and node not in [edge['target'] for edge in edges]\": ['nodes_to_remove.append(node)']}])\
    \ {\n      if (['nodes_to_remove.append(node)']) {\n        :nodes_to_remove.append(node);\n\
    \      }\n    }\n    :return;\n    :{'nodes': nodes, 'edges': edges};\n  }\n \
    \ def ['control_flow_tree = []', \"node_keywords_map = {ast.FunctionDef: 'def',\
    \ ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For:\
    \ 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return:\
    \ 'return', ast.If: 'if', ast.Try: 'try'}\", {'for node in nodes': ['node_type\
    \ = type(node)', {'if node_type not in node_keywords_map': ['control_flow_tree.append(ast.unparse(node))',\
    \ 'continue']}, 'keyword = node_keywords_map[node_type]', {\"if keyword == 'def'\"\
    : [\"args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\", \"\
    key = f'def {node.name}({args_str})'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'class'\": [\"\
    key = f'class {node.name}'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'while'\": [\"\
    key = f'while {ast.unparse(node.test)}'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'for'\": [\"key\
    \ = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\", 'value =\
    \ extract_control_flow_tree(node.body)', 'control_flow_tree.append({key: value})'],\
    \ \"elif keyword == 'with'\": ['key = f\"with {\\', \\'.join([ast.unparse(item)\
    \ for item in node.items])}\"', 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'return'\": [\"\
    key = 'return'\", 'value = [ast.unparse(node.value)] if node.value is not None\
    \ else []', 'control_flow_tree.append({key: value})'], \"elif keyword == 'if'\"\
    : [\"key = f'if {ast.unparse(node.test)}'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'if_block = {key: value}', 'orelse = node.orelse', {'while orelse and isinstance(orelse[0],\
    \ ast.If)': [\"key = f'elif {ast.unparse(orelse[0].test)}'\", 'value = extract_control_flow_tree(orelse[0].body)',\
    \ 'if_block[key] = value', 'orelse = orelse[0].orelse']}, {'if orelse': [\"key\
    \ = 'else'\", 'value = extract_control_flow_tree(orelse)', 'if_block[key] = value']},\
    \ 'control_flow_tree.append(if_block)'], \"elif keyword == 'try'\": ['try_block\
    \ = extract_control_flow_tree(node.body)', 'except_block = []', {'for handler\
    \ in node.handlers': [\"h_type = ast.unparse(handler.type) if handler.type is\
    \ not None else ''\", \"h_name = ast.unparse(handler.name) if isinstance(handler.name,\
    \ ast.Name) else ''\", \"key = f'except {h_type} as {h_name}:'\", 'value = extract_control_flow_tree(handler.body)',\
    \ 'except_block.append({key: value})']}, \"control_flow_dict = {'try': try_block,\
    \ 'except': except_block}\", {'if node.orelse': ['else_block = extract_control_flow_tree(node.orelse)',\
    \ \"control_flow_dict['else'] = else_block\"]}, {'if node.finalbody': ['finally_block\
    \ = extract_control_flow_tree(node.finalbody)', \"control_flow_dict['finally']\
    \ = finally_block\"]}, 'control_flow_tree.append(control_flow_dict)'], 'else':\
    \ ['control_flow_tree.append(ast.unparse(node))']}]}, {'return': ['control_flow_tree']}]\
    \ {\n    :control_flow_tree = [];\n    :node_keywords_map = {ast.FunctionDef:\
    \ 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while',\
    \ ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with',\
    \ ast.Return: 'return', ast.If: 'if', ast.Try: 'try'};\n    while (['node_type\
    \ = type(node)', {'if node_type not in node_keywords_map': ['control_flow_tree.append(ast.unparse(node))',\
    \ 'continue']}, 'keyword = node_keywords_map[node_type]', {\"if keyword == 'def'\"\
    : [\"args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\", \"\
    key = f'def {node.name}({args_str})'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'class'\": [\"\
    key = f'class {node.name}'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'while'\": [\"\
    key = f'while {ast.unparse(node.test)}'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'for'\": [\"key\
    \ = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\", 'value =\
    \ extract_control_flow_tree(node.body)', 'control_flow_tree.append({key: value})'],\
    \ \"elif keyword == 'with'\": ['key = f\"with {\\', \\'.join([ast.unparse(item)\
    \ for item in node.items])}\"', 'value = extract_control_flow_tree(node.body)',\
    \ 'control_flow_tree.append({key: value})'], \"elif keyword == 'return'\": [\"\
    key = 'return'\", 'value = [ast.unparse(node.value)] if node.value is not None\
    \ else []', 'control_flow_tree.append({key: value})'], \"elif keyword == 'if'\"\
    : [\"key = f'if {ast.unparse(node.test)}'\", 'value = extract_control_flow_tree(node.body)',\
    \ 'if_block = {key: value}', 'orelse = node.orelse', {'while orelse and isinstance(orelse[0],\
    \ ast.If)': [\"key = f'elif {ast.unparse(orelse[0].test)}'\", 'value = extract_control_flow_tree(orelse[0].body)',\
    \ 'if_block[key] = value', 'orelse = orelse[0].orelse']}, {'if orelse': [\"key\
    \ = 'else'\", 'value = extract_control_flow_tree(orelse)', 'if_block[key] = value']},\
    \ 'control_flow_tree.append(if_block)'], \"elif keyword == 'try'\": ['try_block\
    \ = extract_control_flow_tree(node.body)', 'except_block = []', {'for handler\
    \ in node.handlers': [\"h_type = ast.unparse(handler.type) if handler.type is\
    \ not None else ''\", \"h_name = ast.unparse(handler.name) if isinstance(handler.name,\
    \ ast.Name) else ''\", \"key = f'except {h_type} as {h_name}:'\", 'value = extract_control_flow_tree(handler.body)',\
    \ 'except_block.append({key: value})']}, \"control_flow_dict = {'try': try_block,\
    \ 'except': except_block}\", {'if node.orelse': ['else_block = extract_control_flow_tree(node.orelse)',\
    \ \"control_flow_dict['else'] = else_block\"]}, {'if node.finalbody': ['finally_block\
    \ = extract_control_flow_tree(node.finalbody)', \"control_flow_dict['finally']\
    \ = finally_block\"]}, 'control_flow_tree.append(control_flow_dict)'], 'else':\
    \ ['control_flow_tree.append(ast.unparse(node))']}]) {\n      :node_type = type(node);\n\
    \      if (['control_flow_tree.append(ast.unparse(node))', 'continue']) {\n  \
    \      :control_flow_tree.append(ast.unparse(node));\n        :continue;\n   \
    \   }\n      :keyword = node_keywords_map[node_type];\n      if ([\"args_str =\
    \ ', '.join([ast.unparse(arg) for arg in node.args.args])\", \"key = f'def {node.name}({args_str})'\"\
    , 'value = extract_control_flow_tree(node.body)', 'control_flow_tree.append({key:\
    \ value})']) {\n        :args_str = ', '.join([ast.unparse(arg) for arg in node.args.args]);\n\
    \        :key = f'def {node.name}({args_str})';\n        :value = extract_control_flow_tree(node.body);\n\
    \        :control_flow_tree.append({key: value});\n      }\n    }\n    :return;\n\
    \    :control_flow_tree;\n  }\n  def [\"targets = [edge['target'] for edge in\
    \ code_graph['edges']]\", \"starting_points = [node for node in code_graph['nodes']\
    \ if node not in targets]\", {'def reorganize_structure(structure, start_points)':\
    \ ['organized, seen = ([], set())', {'for start in start_points': [{'for element\
    \ in structure': [{'if isinstance(element, dict)': ['key = next(iter(element))',\
    \ {'if start in key': ['element_id = json.dumps(element)', {'if element_id not\
    \ in seen': ['organized.append(element)', 'seen.add(element_id)']}]}], 'elif isinstance(element,\
    \ str) and start in element': ['organized.append(element)']}]}]}, 'remaining =\
    \ [elem for elem in structure if json.dumps(elem) not in seen]', 'organized.extend(remaining)',\
    \ {'return': ['organized']}]}, {'return': ['reorganize_structure(control_flow_structure,\
    \ starting_points)']}] {\n    :targets = [edge['target'] for edge in code_graph['edges']];\n\
    \    :starting_points = [node for node in code_graph['nodes'] if node not in targets];\n\
    \    def ['organized, seen = ([], set())', {'for start in start_points': [{'for\
    \ element in structure': [{'if isinstance(element, dict)': ['key = next(iter(element))',\
    \ {'if start in key': ['element_id = json.dumps(element)', {'if element_id not\
    \ in seen': ['organized.append(element)', 'seen.add(element_id)']}]}], 'elif isinstance(element,\
    \ str) and start in element': ['organized.append(element)']}]}]}, 'remaining =\
    \ [elem for elem in structure if json.dumps(elem) not in seen]', 'organized.extend(remaining)',\
    \ {'return': ['organized']}] {\n      :organized, seen = ([], set());\n      while\
    \ ([{'for element in structure': [{'if isinstance(element, dict)': ['key = next(iter(element))',\
    \ {'if start in key': ['element_id = json.dumps(element)', {'if element_id not\
    \ in seen': ['organized.append(element)', 'seen.add(element_id)']}]}], 'elif isinstance(element,\
    \ str) and start in element': ['organized.append(element)']}]}]) {\n        while\
    \ ([{'if isinstance(element, dict)': ['key = next(iter(element))', {'if start\
    \ in key': ['element_id = json.dumps(element)', {'if element_id not in seen':\
    \ ['organized.append(element)', 'seen.add(element_id)']}]}], 'elif isinstance(element,\
    \ str) and start in element': ['organized.append(element)']}]) {\n          if\
    \ (['key = next(iter(element))', {'if start in key': ['element_id = json.dumps(element)',\
    \ {'if element_id not in seen': ['organized.append(element)', 'seen.add(element_id)']}]}])\
    \ {\n            :key = next(iter(element));\n            if (['element_id = json.dumps(element)',\
    \ {'if element_id not in seen': ['organized.append(element)', 'seen.add(element_id)']}])\
    \ {\n              :element_id = json.dumps(element);\n              if (['organized.append(element)',\
    \ 'seen.add(element_id)']) {\n                :organized.append(element);\n  \
    \              :seen.add(element_id);\n              }\n            }\n      \
    \    }\n        }\n      }\n      :remaining = [elem for elem in structure if\
    \ json.dumps(elem) not in seen];\n      :organized.extend(remaining);\n      :return;\n\
    \      :organized;\n    }\n    :return;\n    :reorganize_structure(control_flow_structure,\
    \ starting_points);\n  }\n  def [\"plantuml_str = ''\", {'if isinstance(element,\
    \ dict)': ['key = next(iter(element))', 'value = element[key]', {\"if key.startswith('def\
    \ ') or key.startswith('async def ')\": [\"plantuml_str += f'{indentation}def\
    \ {value} {{\\\\n'\", \"inner_indentation = indentation + '  '\"], \"elif key.startswith('class\
    \ ')\": [\"plantuml_str += f'{indentation}class {value} {{\\\\n'\", \"inner_indentation\
    \ = indentation + '  '\"], \"elif key.startswith('if ')\": [\"plantuml_str +=\
    \ f'{indentation}if ({value}) {{\\\\n'\", \"inner_indentation = indentation +\
    \ '  '\"], \"elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor\
    \ ')\": [\"plantuml_str += f'{indentation}while ({value}) {{\\\\n'\", \"inner_indentation\
    \ = indentation + '  '\"], \"elif key.startswith('try ')\": [\"plantuml_str +=\
    \ f'{indentation}try {{\\\\n'\", \"inner_indentation = indentation + '  '\"],\
    \ \"elif key.startswith('except ')\": [\"plantuml_str += f'{indentation}catch\
    \ ({value}) {{\\\\n'\", \"inner_indentation = indentation + '  '\"], 'else': [\"\
    plantuml_str += f'{indentation}:{key};\\\\n'\", 'inner_indentation = indentation']},\
    \ {'if isinstance(value, list)': [{'for child in value': ['plantuml_str += get_plantUML_element(child,\
    \ inner_indentation)']}]}, {\"if key.startswith('def ') or key.startswith('class\
    \ ')\": [\"plantuml_str += f'{indentation}}}\\\\n'\"], \"elif key.startswith('if\
    \ ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor\
    \ ') or key.startswith('try ') or key.startswith('except ')\": [\"plantuml_str\
    \ += f'{indentation}}}\\\\n'\"]}], 'elif isinstance(element, str)': [\"plantuml_str\
    \ += f'{indentation}:{element};\\\\n'\"]}, {'return': ['plantuml_str']}] {\n \
    \   :plantuml_str = '';\n    if (['key = next(iter(element))', 'value = element[key]',\
    \ {\"if key.startswith('def ') or key.startswith('async def ')\": [\"plantuml_str\
    \ += f'{indentation}def {value} {{\\\\n'\", \"inner_indentation = indentation\
    \ + '  '\"], \"elif key.startswith('class ')\": [\"plantuml_str += f'{indentation}class\
    \ {value} {{\\\\n'\", \"inner_indentation = indentation + '  '\"], \"elif key.startswith('if\
    \ ')\": [\"plantuml_str += f'{indentation}if ({value}) {{\\\\n'\", \"inner_indentation\
    \ = indentation + '  '\"], \"elif key.startswith('for ') or key.startswith('while\
    \ ') or key.startswith('asyncfor ')\": [\"plantuml_str += f'{indentation}while\
    \ ({value}) {{\\\\n'\", \"inner_indentation = indentation + '  '\"], \"elif key.startswith('try\
    \ ')\": [\"plantuml_str += f'{indentation}try {{\\\\n'\", \"inner_indentation\
    \ = indentation + '  '\"], \"elif key.startswith('except ')\": [\"plantuml_str\
    \ += f'{indentation}catch ({value}) {{\\\\n'\", \"inner_indentation = indentation\
    \ + '  '\"], 'else': [\"plantuml_str += f'{indentation}:{key};\\\\n'\", 'inner_indentation\
    \ = indentation']}, {'if isinstance(value, list)': [{'for child in value': ['plantuml_str\
    \ += get_plantUML_element(child, inner_indentation)']}]}, {\"if key.startswith('def\
    \ ') or key.startswith('class ')\": [\"plantuml_str += f'{indentation}}}\\\\n'\"\
    ], \"elif key.startswith('if ') or key.startswith('for ') or key.startswith('while\
    \ ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except\
    \ ')\": [\"plantuml_str += f'{indentation}}}\\\\n'\"]}]) {\n      :key = next(iter(element));\n\
    \      :value = element[key];\n      if ([\"plantuml_str += f'{indentation}def\
    \ {value} {{\\\\n'\", \"inner_indentation = indentation + '  '\"]) {\n       \
    \ :plantuml_str += f'{indentation}def {value} {{\\n';\n        :inner_indentation\
    \ = indentation + '  ';\n      }\n      if ([{'for child in value': ['plantuml_str\
    \ += get_plantUML_element(child, inner_indentation)']}]) {\n        while (['plantuml_str\
    \ += get_plantUML_element(child, inner_indentation)']) {\n          :plantuml_str\
    \ += get_plantUML_element(child, inner_indentation);\n        }\n      }\n   \
    \   if ([\"plantuml_str += f'{indentation}}}\\\\n'\"]) {\n        :plantuml_str\
    \ += f'{indentation}}}\\n';\n      }\n    }\n    :return;\n    :plantuml_str;\n\
    \  }\n  def [\"plantuml_str = '@startuml\\\\n'\", {'for element in control_flow_structure':\
    \ [\"plantuml_str += get_plantUML_element(element, '  ')\"]}, \"plantuml_str +=\
    \ 'end\\\\n@enduml'\", {'return': ['plantuml_str']}] {\n    :plantuml_str = '@startuml\\\
    n';\n    while ([\"plantuml_str += get_plantUML_element(element, '  ')\"]) {\n\
    \      :plantuml_str += get_plantUML_element(element, '  ');\n    }\n    :plantuml_str\
    \ += 'end\\n@enduml';\n    :return;\n    :plantuml_str;\n  }\nend\n@enduml"
functions:
  code_graph:
    function_name: code_graph
    function_code: "def code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str,\
      \ Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary\
      \ representation of file details.\n    Args:\n        file_summary: Dict[str,\
      \ Union[Dict, str]]: The details extracted from the file.\n    Returns:\n  \
      \      dict: A dictionary with nodes and edges representing the relationships\
      \ in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup\
      \ = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n\
      \    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n\
      \        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n\
      \            for method_name, method_details in class_details['method_defs'].items():\n\
      \                qualified_method_name = f'{class_name}.{method_name}'\n   \
      \             G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name]\
      \ = method_details\n                G.add_edge(class_name, qualified_method_name)\n\
      \n    def get_edge_data_from_details(target_details: dict, source_details: dict,\
      \ target: str) -> dict:\n        edge_data = {}\n        if target_details:\n\
      \            edge_data['target_inputs'] = target_details.get('inputs')\n   \
      \         edge_data['target_returns'] = list(set(target_details.get('returns',\
      \ [])))\n        if source_details and 'call_inputs' in source_details and (target\
      \ in source_details['call_inputs']):\n            edge_data['target_inputs']\
      \ = source_details['call_inputs'][target]\n        return edge_data\n\n    def\
      \ add_edge_with_data(source: str, target: str, init_method: Optional[str]=None)\
      \ -> None:\n        target_details = class_method_details_lookup.get(init_method\
      \ or target) or function_details_lookup.get(target)\n        source_details\
      \ = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n\
      \        G.add_edge(source, target, **get_edge_data_from_details(target_details,\
      \ source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n\
      \        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n\
      \        for called in calls:\n            called_class_name = called.split('.')[0]\n\
      \            if called.startswith('self.'):\n                method_name = called.replace('self.',\
      \ '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
      \n                if fully_qualified_name in class_method_details_lookup:\n\
      \                    add_edge_with_data(source_name, fully_qualified_name)\n\
      \                    continue\n            if called in function_details_lookup\
      \ or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\"\
      \ in class_method_details_lookup:\n                add_edge_with_data(source_name,\
      \ called)\n            elif called_class_name in class_names:\n            \
      \    init_method = None\n                init_method_name = f'{called}.__init__'\n\
      \                if init_method_name in class_method_details_lookup:\n     \
      \               init_method = init_method_name\n                add_edge_with_data(source_name,\
      \ called, init_method)\n            else:\n                G.add_node(called)\n\
      \                add_edge_with_data(source_name, called)\n    for function_name\
      \ in function_details_lookup:\n        G.add_node(function_name)\n    for func_name,\
      \ details in function_details_lookup.items():\n        add_edges_for_calls(func_name,\
      \ details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n\
      \        add_edges_for_calls(qualified_method_name, details['calls'])\n    for\
      \ edge in G.edges:\n        source, target = edge\n        target_details =\
      \ function_details_lookup.get(target) or class_method_details_lookup.get(target)\n\
      \        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n\
      \        edge_data = get_edge_data_from_details(target_details, source_details,\
      \ target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n\
      \    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in\
      \ G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n      \
      \  if node not in [edge['source'] for edge in edges] and node not in [edge['target']\
      \ for edge in edges]:\n            nodes_to_remove.append(node)\n    return\
      \ {'nodes': nodes, 'edges': edges}"
    function_docstring: "\n    Create a dictionary representation of file details.\n\
      \    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted\
      \ from the file.\n    Returns:\n        dict: A dictionary with nodes and edges\
      \ representing the relationships in the code.\n    "
    function_inputs:
    - file_summary
    function_defaults: []
    function_returns:
    - '{''nodes'': nodes, ''edges'': edges}'
    - edge_data
    function_calls:
    - nx.DiGraph
    - function_details_lookup.update
    - class_def.items
    - G.add_node
    - class_details['method_defs'].items
    - G.add_edge
    - target_details.get
    - list
    - set
    - class_method_details_lookup.get
    - function_details_lookup.get
    - get_edge_data_from_details
    - class_def.keys
    - called.split
    - called.startswith
    - called.replace
    - source_name.split
    - add_edge_with_data
    - function_details_lookup.items
    - add_edges_for_calls
    - class_method_details_lookup.items
    - G[source][target].update
    - G.edges.data
    - nodes_to_remove.append
    function_call_inputs:
      nx.DiGraph: []
      function_details_lookup.update:
      - function_def
      class_def.items: []
      G.add_node:
      - class_name
      - qualified_method_name
      - called
      - function_name
      class_details['method_defs'].items: []
      G.add_edge:
      - class_name
      - qualified_method_name
      - source
      - target
      target_details.get:
      - '''inputs'''
      - '''returns'''
      - '[]'
      list:
      - set(target_details.get('returns', []))
      - class_def.keys()
      - G.nodes
      set:
      - target_details.get('returns', [])
      class_method_details_lookup.get:
      - init_method or target
      - source
      - target
      - source
      function_details_lookup.get:
      - target
      - source
      - target
      - source
      get_edge_data_from_details:
      - target_details
      - source_details
      - target
      - target_details
      - source_details
      - target
      class_def.keys: []
      called.split:
      - '''.'''
      called.startswith:
      - '''self.'''
      called.replace:
      - '''self.'''
      - ''''''
      source_name.split:
      - '''.'''
      - '''.'''
      add_edge_with_data:
      - source_name
      - fully_qualified_name
      - source_name
      - called
      - source_name
      - called
      - init_method
      - source_name
      - called
      function_details_lookup.items: []
      add_edges_for_calls:
      - func_name
      - details['calls']
      - qualified_method_name
      - details['calls']
      class_method_details_lookup.items: []
      G[source][target].update:
      - edge_data
      G.edges.data: []
      nodes_to_remove.append:
      - node
    function_variables:
    - target_details
    - called_class_name
    - edge_data
    - edges
    - class_method_details_lookup
    - nodes
    - source_details
    - nodes_to_remove
    - function_details_lookup
    - G
    - init_method
    - fully_qualified_name
    - init_method_name
    - class_names
    - qualified_method_name
    - file_summary
    - method_name
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_edge_data_from_details:
    function_name: get_edge_data_from_details
    function_code: "def get_edge_data_from_details(target_details: dict, source_details:\
      \ dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n\
      \        edge_data['target_inputs'] = target_details.get('inputs')\n       \
      \ edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n\
      \    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n\
      \        edge_data['target_inputs'] = source_details['call_inputs'][target]\n\
      \    return edge_data"
    function_docstring: null
    function_inputs:
    - target_details
    - source_details
    - target
    function_defaults: []
    function_returns:
    - edge_data
    function_calls:
    - target_details.get
    - list
    - set
    function_call_inputs:
      target_details.get:
      - '''inputs'''
      - '''returns'''
      - '[]'
      list:
      - set(target_details.get('returns', []))
      set:
      - target_details.get('returns', [])
    function_variables:
    - target_details
    - source_details
    - target
    - edge_data
    function_decorators: []
    function_annotations: []
    function_properties: []
  add_edge_with_data:
    function_name: add_edge_with_data
    function_code: "def add_edge_with_data(source: str, target: str, init_method:\
      \ Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method\
      \ or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source)\
      \ or class_method_details_lookup.get(source)\n    G.add_edge(source, target,\
      \ **get_edge_data_from_details(target_details, source_details, target))"
    function_docstring: null
    function_inputs:
    - source
    - target
    - init_method
    function_defaults:
    - None
    function_returns: []
    function_calls:
    - class_method_details_lookup.get
    - function_details_lookup.get
    - G.add_edge
    - get_edge_data_from_details
    function_call_inputs:
      class_method_details_lookup.get:
      - init_method or target
      - source
      function_details_lookup.get:
      - target
      - source
      G.add_edge:
      - source
      - target
      get_edge_data_from_details:
      - target_details
      - source_details
      - target
    function_variables:
    - target_details
    - init_method
    - source_details
    - target
    - source
    function_decorators: []
    function_annotations: []
    function_properties: []
  add_edges_for_calls:
    function_name: add_edges_for_calls
    function_code: "def add_edges_for_calls(source_name, calls):\n    class_names\
      \ = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n\
      \    for called in calls:\n        called_class_name = called.split('.')[0]\n\
      \        if called.startswith('self.'):\n            method_name = called.replace('self.',\
      \ '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\
      \n            if fully_qualified_name in class_method_details_lookup:\n    \
      \            add_edge_with_data(source_name, fully_qualified_name)\n       \
      \         continue\n        if called in function_details_lookup or called in\
      \ class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in\
      \ class_method_details_lookup:\n            add_edge_with_data(source_name,\
      \ called)\n        elif called_class_name in class_names:\n            init_method\
      \ = None\n            init_method_name = f'{called}.__init__'\n            if\
      \ init_method_name in class_method_details_lookup:\n                init_method\
      \ = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n\
      \        else:\n            G.add_node(called)\n            add_edge_with_data(source_name,\
      \ called)"
    function_docstring: null
    function_inputs:
    - source_name
    - calls
    function_defaults: []
    function_returns: []
    function_calls:
    - list
    - class_def.keys
    - called.split
    - called.startswith
    - called.replace
    - source_name.split
    - add_edge_with_data
    - G.add_node
    function_call_inputs:
      list:
      - class_def.keys()
      class_def.keys: []
      called.split:
      - '''.'''
      called.startswith:
      - '''self.'''
      called.replace:
      - '''self.'''
      - ''''''
      source_name.split:
      - '''.'''
      - '''.'''
      add_edge_with_data:
      - source_name
      - fully_qualified_name
      - source_name
      - called
      - source_name
      - called
      - init_method
      - source_name
      - called
      G.add_node:
      - called
    function_variables:
    - called_class_name
    - calls
    - source_name
    - init_method
    - fully_qualified_name
    - init_method_name
    - class_names
    - method_name
    function_decorators: []
    function_annotations: []
    function_properties: []
  extract_control_flow_tree:
    function_name: extract_control_flow_tree
    function_code: "def extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str,\
      \ dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n\
      \        nodes: AST nodes\n    Returns:\n        control_flow_tree: control\
      \ flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map =\
      \ {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class',\
      \ ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with',\
      \ ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n\
      \    for node in nodes:\n        node_type = type(node)\n        if node_type\
      \ not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n\
      \            continue\n        keyword = node_keywords_map[node_type]\n    \
      \    if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg)\
      \ for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n\
      \            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key:\
      \ value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n\
      \            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key:\
      \ value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n\
      \            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key:\
      \ value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)}\
      \ in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n\
      \            control_flow_tree.append({key: value})\n        elif keyword ==\
      \ 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item\
      \ in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n\
      \            control_flow_tree.append({key: value})\n        elif keyword ==\
      \ 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)]\
      \ if node.value is not None else []\n            control_flow_tree.append({key:\
      \ value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n\
      \            value = extract_control_flow_tree(node.body)\n            if_block\
      \ = {key: value}\n            orelse = node.orelse\n            while orelse\
      \ and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n\
      \                value = extract_control_flow_tree(orelse[0].body)\n       \
      \         if_block[key] = value\n                orelse = orelse[0].orelse\n\
      \            if orelse:\n                key = 'else'\n                value\
      \ = extract_control_flow_tree(orelse)\n                if_block[key] = value\n\
      \            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n\
      \            try_block = extract_control_flow_tree(node.body)\n            except_block\
      \ = []\n            for handler in node.handlers:\n                h_type =\
      \ ast.unparse(handler.type) if handler.type is not None else ''\n          \
      \      h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name)\
      \ else ''\n                key = f'except {h_type} as {h_name}:'\n         \
      \       value = extract_control_flow_tree(handler.body)\n                except_block.append({key:\
      \ value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n\
      \            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n\
      \                control_flow_dict['else'] = else_block\n            if node.finalbody:\n\
      \                finally_block = extract_control_flow_tree(node.finalbody)\n\
      \                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n\
      \        else:\n            control_flow_tree.append(ast.unparse(node))\n  \
      \  return control_flow_tree"
    function_docstring: "\n    Extract control flow tree from AST.\n    Args:\n  \
      \      nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow\
      \ tree\n    "
    function_inputs:
    - nodes
    function_defaults: []
    function_returns:
    - control_flow_tree
    function_calls:
    - type
    - control_flow_tree.append
    - ast.unparse
    - ''', ''.join'
    - extract_control_flow_tree
    - isinstance
    - except_block.append
    function_call_inputs:
      type:
      - node
      control_flow_tree.append:
      - ast.unparse(node)
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - '{key: value}'
      - if_block
      - control_flow_dict
      - ast.unparse(node)
      ast.unparse:
      - node
      - arg
      - node.test
      - node.target
      - node.iter
      - item
      - node.value
      - node.test
      - orelse[0].test
      - handler.type
      - handler.name
      - node
      ''', ''.join':
      - '[ast.unparse(arg) for arg in node.args.args]'
      - '[ast.unparse(item) for item in node.items]'
      extract_control_flow_tree:
      - node.body
      - node.body
      - node.body
      - node.body
      - node.body
      - node.body
      - orelse[0].body
      - orelse
      - node.body
      - handler.body
      - node.orelse
      - node.finalbody
      isinstance:
      - orelse[0]
      - ast.If
      - handler.name
      - ast.Name
      except_block.append:
      - '{key: value}'
    function_variables:
    - if_block
    - key
    - try_block
    - control_flow_tree
    - nodes
    - except_block
    - node_type
    - keyword
    - h_name
    - node_keywords_map
    - else_block
    - orelse
    - args_str
    - control_flow_dict
    - value
    - finally_block
    - h_type
    function_decorators: []
    function_annotations: []
    function_properties: []
  reorganize_control_flow:
    function_name: reorganize_control_flow
    function_code: "def reorganize_control_flow(code_graph, control_flow_structure):\n\
      \    \"\"\"\n    Reorganize control flow structure to match the code graph.\n\
      \    Args:\n        file_details: file details\n        control_flow_structure:\
      \ control flow structure\n    Returns:\n        reorganized_control_flow_structure:\
      \ reorganized control flow structure\n    \"\"\"\n    targets = [edge['target']\
      \ for edge in code_graph['edges']]\n    starting_points = [node for node in\
      \ code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure,\
      \ start_points):\n        organized, seen = ([], set())\n        for start in\
      \ start_points:\n            for element in structure:\n                if isinstance(element,\
      \ dict):\n                    key = next(iter(element))\n                  \
      \  if start in key:\n                        element_id = json.dumps(element)\n\
      \                        if element_id not in seen:\n                      \
      \      organized.append(element)\n                            seen.add(element_id)\n\
      \                elif isinstance(element, str) and start in element:\n     \
      \               organized.append(element)\n        remaining = [elem for elem\
      \ in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n\
      \        return organized\n    return reorganize_structure(control_flow_structure,\
      \ starting_points)"
    function_docstring: "\n    Reorganize control flow structure to match the code\
      \ graph.\n    Args:\n        file_details: file details\n        control_flow_structure:\
      \ control flow structure\n    Returns:\n        reorganized_control_flow_structure:\
      \ reorganized control flow structure\n    "
    function_inputs:
    - code_graph
    - control_flow_structure
    function_defaults: []
    function_returns:
    - reorganize_structure(control_flow_structure, starting_points)
    - organized
    function_calls:
    - set
    - isinstance
    - next
    - iter
    - json.dumps
    - organized.append
    - seen.add
    - organized.extend
    - reorganize_structure
    function_call_inputs:
      set: []
      isinstance:
      - element
      - dict
      - element
      - str
      next:
      - iter(element)
      iter:
      - element
      json.dumps:
      - element
      - elem
      organized.append:
      - element
      - element
      seen.add:
      - element_id
      organized.extend:
      - remaining
      reorganize_structure:
      - control_flow_structure
      - starting_points
    function_variables:
    - key
    - code_graph
    - control_flow_structure
    - remaining
    - starting_points
    - element_id
    - targets
    function_decorators: []
    function_annotations: []
    function_properties: []
  reorganize_structure:
    function_name: reorganize_structure
    function_code: "def reorganize_structure(structure, start_points):\n    organized,\
      \ seen = ([], set())\n    for start in start_points:\n        for element in\
      \ structure:\n            if isinstance(element, dict):\n                key\
      \ = next(iter(element))\n                if start in key:\n                \
      \    element_id = json.dumps(element)\n                    if element_id not\
      \ in seen:\n                        organized.append(element)\n            \
      \            seen.add(element_id)\n            elif isinstance(element, str)\
      \ and start in element:\n                organized.append(element)\n    remaining\
      \ = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n\
      \    return organized"
    function_docstring: null
    function_inputs:
    - structure
    - start_points
    function_defaults: []
    function_returns:
    - organized
    function_calls:
    - set
    - isinstance
    - next
    - iter
    - json.dumps
    - organized.append
    - seen.add
    - organized.extend
    function_call_inputs:
      set: []
      isinstance:
      - element
      - dict
      - element
      - str
      next:
      - iter(element)
      iter:
      - element
      json.dumps:
      - element
      - elem
      organized.append:
      - element
      - element
      seen.add:
      - element_id
      organized.extend:
      - remaining
    function_variables:
    - key
    - remaining
    - element_id
    - start_points
    - structure
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_plantUML_element:
    function_name: get_plantUML_element
    function_code: "def get_plantUML_element(element, indentation=''):\n    \"\"\"\
      \n    Get plantUML code for each element.\n    Args:\n        element: element\n\
      \        indentation: current indentation level\n    Returns:\n        plantuml_str:\
      \ plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if\
      \ isinstance(element, dict):\n        key = next(iter(element))\n        value\
      \ = element[key]\n        if key.startswith('def ') or key.startswith('async\
      \ def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n \
      \           inner_indentation = indentation + '  '\n        elif key.startswith('class\
      \ '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n   \
      \         inner_indentation = indentation + '  '\n        elif key.startswith('if\
      \ '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n    \
      \        inner_indentation = indentation + '  '\n        elif key.startswith('for\
      \ ') or key.startswith('while ') or key.startswith('asyncfor '):\n         \
      \   plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation\
      \ = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str\
      \ += f'{indentation}try {{\\n'\n            inner_indentation = indentation\
      \ + '  '\n        elif key.startswith('except '):\n            plantuml_str\
      \ += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation =\
      \ indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\\
      n'\n            inner_indentation = indentation\n        if isinstance(value,\
      \ list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child,\
      \ inner_indentation)\n        if key.startswith('def ') or key.startswith('class\
      \ '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if\
      \ ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor\
      \ ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str\
      \ += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str\
      \ += f'{indentation}:{element};\\n'\n    return plantuml_str"
    function_docstring: "\n    Get plantUML code for each element.\n    Args:\n  \
      \      element: element\n        indentation: current indentation level\n  \
      \  Returns:\n        plantuml_str: plantUML code for each element\n    "
    function_inputs:
    - element
    - indentation
    function_defaults:
    - ''''''
    function_returns:
    - plantuml_str
    function_calls:
    - isinstance
    - next
    - iter
    - key.startswith
    - get_plantUML_element
    function_call_inputs:
      isinstance:
      - element
      - dict
      - value
      - list
      - element
      - str
      next:
      - iter(element)
      iter:
      - element
      key.startswith:
      - '''def '''
      - '''async def '''
      - '''class '''
      - '''if '''
      - '''for '''
      - '''while '''
      - '''asyncfor '''
      - '''try '''
      - '''except '''
      - '''def '''
      - '''class '''
      - '''if '''
      - '''for '''
      - '''while '''
      - '''asyncfor '''
      - '''try '''
      - '''except '''
      get_plantUML_element:
      - child
      - inner_indentation
    function_variables:
    - key
    - plantuml_str
    - element
    - inner_indentation
    - value
    - indentation
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_plantUML:
    function_name: get_plantUML
    function_code: "def get_plantUML(control_flow_structure):\n    \"\"\"\n    Get\
      \ plantUML activity diagram code for entire file.\n    Args:\n        file_details:\
      \ file details\n    Returns:\n        plantuml_str: plantUML code for entire\
      \ file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n\
      \        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str\
      \ += 'end\\n@enduml'\n    return plantuml_str"
    function_docstring: "\n    Get plantUML activity diagram code for entire file.\n\
      \    Args:\n        file_details: file details\n    Returns:\n        plantuml_str:\
      \ plantUML code for entire file\n    "
    function_inputs:
    - control_flow_structure
    function_defaults: []
    function_returns:
    - plantuml_str
    function_calls:
    - get_plantUML_element
    function_call_inputs:
      get_plantUML_element:
      - element
      - '''  '''
    function_variables:
    - control_flow_structure
    - plantuml_str
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_code_graph:
    function_name: get_code_graph
    function_code: "def get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add\
      \ code graph and control flow to file details.\n    Args:\n        file_details:\
      \ file details\n    Returns:\n        file_details: file details\n    \"\"\"\
      \n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree\
      \ = extract_control_flow_tree(file_ast.body)\n        control_flow_structure\
      \ = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML\
      \ = get_plantUML(control_flow_structure)\n    except Exception as e:\n     \
      \   control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return\
      \ (entire_code_graph, control_flow_structure, plantUML)"
    function_docstring: "\n    Add code graph and control flow to file details.\n\
      \    Args:\n        file_details: file details\n    Returns:\n        file_details:\
      \ file details\n    "
    function_inputs:
    - file_summary
    - file_ast
    function_defaults: []
    function_returns:
    - (entire_code_graph, control_flow_structure, plantUML)
    function_calls:
    - code_graph
    - extract_control_flow_tree
    - reorganize_control_flow
    - get_plantUML
    - str
    function_call_inputs:
      code_graph:
      - file_summary
      extract_control_flow_tree:
      - file_ast.body
      reorganize_control_flow:
      - entire_code_graph
      - control_flow_tree
      get_plantUML:
      - control_flow_structure
      str:
      - e
      - e
    function_variables:
    - control_flow_structure
    - plantUML
    - control_flow_tree
    - file_ast
    - entire_code_graph
    - file_summary
    function_decorators: []
    function_annotations: []
    function_properties: []
classes: {}
