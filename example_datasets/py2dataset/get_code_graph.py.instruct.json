[
    {
        "instruction": "Dependencies in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "'typing', 'ast', 'networkx', 'json'\n\nPurpose and Significance:\n1. Purpose and Significance of Dependencies:\n   a. typing: This Python standard library module provides advanced data type annotations that help enhance type hinting within the codebase for improved readability, refactoring assistance by IDEs/linters, and static analysis tools effectiveness. It allows defining generic functions with more precision and clarity on expected input/output types. In 'get_code_graph.py', typing is utilized to define argument types in various function signatures such as Dict[str, Union[Dict, str]], List[Union[str, dict]] or Optional[str].\n   b. ast (Abstract Syntax Tree): It's a module from Python's standard library used for parsing Python code into a data structure representing its syntactic structure. In 'get_code_graph.py', the AST module helps parse file details as abstract syntax tree nodes and extract control flow trees through traversal for analysis. This provides more semantic information on code behavior enabling advanced language processing like refactoring or transformation.\n   c. networkx: An external Python package offering efficient algorithms and data structures for complex networks modeling and analysis. In 'get_code_graph.py', NetworkX DiGraph is employed to create a directed graph representing relationships among functions, classes, and methods within the codebase. It enables efficient handling of nodes (classes/functions) and edges (method calls), as well as storing additional data related to these connections.\n   d. json: A standard Python library facilitating conversion between Python objects and JSON format. In 'get_code_graph.py', JSON is used for serializing complex data structures like control flow elements into strings for identification during reorganization processes, ensuring unique references while traversing the structure recursively. It also assists in generating PlantUML activity diagram code by converting Python objects to JSON format suitable for string concatenation.'"
    },
    {
        "instruction": "Call code graph in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "{'nodes': ['code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'extract_control_flow_tree', 'reorganize_control_flow', 'reorganize_structure', 'get_plantUML_element', 'get_plantUML', 'get_code_graph', 'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', \"class_details['method_defs'].items\", 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'function_details_lookup.items', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'nodes_to_remove.append', 'type', 'control_flow_tree.append', 'ast.unparse', \"', '.join\", 'isinstance', 'except_block.append', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend', 'key.startswith', 'str'], 'edges': [{'source': 'code_graph', 'target': 'nx.DiGraph', 'target_inputs': []}, {'source': 'code_graph', 'target': 'function_details_lookup.update', 'target_inputs': ['function_def']}, {'source': 'code_graph', 'target': 'class_def.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_node', 'target_inputs': ['class_name', 'qualified_method_name', 'called', 'function_name']}, {'source': 'code_graph', 'target': \"class_details['method_defs'].items\", 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_edge', 'target_inputs': ['class_name', 'qualified_method_name', 'source', 'target']}, {'source': 'code_graph', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'code_graph', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\", 'class_def.keys()', 'G.nodes']}, {'source': 'code_graph', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'code_graph', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target', 'target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'code_graph', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'code_graph', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'code_graph', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'code_graph', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'code_graph', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'code_graph', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'code_graph', 'target': 'function_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'add_edges_for_calls', 'target_inputs': ['func_name', \"details['calls']\", 'qualified_method_name', \"details['calls']\"], 'target_returns': []}, {'source': 'code_graph', 'target': 'class_method_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G[source][target].update', 'target_inputs': ['edge_data']}, {'source': 'code_graph', 'target': 'G.edges.data', 'target_inputs': []}, {'source': 'code_graph', 'target': 'nodes_to_remove.append', 'target_inputs': ['node']}, {'source': 'get_edge_data_from_details', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'get_edge_data_from_details', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\"]}, {'source': 'get_edge_data_from_details', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'add_edge_with_data', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source']}, {'source': 'add_edge_with_data', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source']}, {'source': 'add_edge_with_data', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'add_edge_with_data', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'add_edges_for_calls', 'target': 'list', 'target_inputs': ['class_def.keys()']}, {'source': 'add_edges_for_calls', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'add_edges_for_calls', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'add_edges_for_calls', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'add_edges_for_calls', 'target': 'G.add_node', 'target_inputs': ['called']}, {'source': 'extract_control_flow_tree', 'target': 'type', 'target_inputs': ['node']}, {'source': 'extract_control_flow_tree', 'target': 'control_flow_tree.append', 'target_inputs': ['ast.unparse(node)', '{key: value}', '{key: value}', '{key: value}', '{key: value}', '{key: value}', '{key: value}', 'if_block', 'control_flow_dict', 'ast.unparse(node)']}, {'source': 'extract_control_flow_tree', 'target': 'ast.unparse', 'target_inputs': ['node', 'arg', 'node.test', 'node.target', 'node.iter', 'item', 'node.value', 'node.test', 'orelse[0].test', 'handler.type', 'handler.name', 'node']}, {'source': 'extract_control_flow_tree', 'target': \"', '.join\", 'target_inputs': ['[ast.unparse(arg) for arg in node.args.args]', '[ast.unparse(item) for item in node.items]']}, {'source': 'extract_control_flow_tree', 'target': 'extract_control_flow_tree', 'target_inputs': ['node.body', 'node.body', 'node.body', 'node.body', 'node.body', 'node.body', 'orelse[0].body', 'orelse', 'node.body', 'handler.body', 'node.orelse', 'node.finalbody'], 'target_returns': ['control_flow_tree']}, {'source': 'extract_control_flow_tree', 'target': 'isinstance', 'target_inputs': ['orelse[0]', 'ast.If', 'handler.name', 'ast.Name']}, {'source': 'extract_control_flow_tree', 'target': 'except_block.append', 'target_inputs': ['{key: value}']}, {'source': 'reorganize_control_flow', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_control_flow', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_control_flow', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_control_flow', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_control_flow', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_control_flow', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_control_flow', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_control_flow', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'reorganize_control_flow', 'target': 'reorganize_structure', 'target_inputs': ['control_flow_structure', 'starting_points'], 'target_returns': ['organized']}, {'source': 'reorganize_structure', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_structure', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_structure', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_structure', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_structure', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_structure', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_structure', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_structure', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'get_plantUML_element', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'value', 'list', 'element', 'str']}, {'source': 'get_plantUML_element', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'get_plantUML_element', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'get_plantUML_element', 'target': 'key.startswith', 'target_inputs': [\"'def '\", \"'async def '\", \"'class '\", \"'if '\", \"'for '\", \"'while '\", \"'asyncfor '\", \"'try '\", \"'except '\", \"'def '\", \"'class '\", \"'if '\", \"'for '\", \"'while '\", \"'asyncfor '\", \"'try '\", \"'except '\"]}, {'source': 'get_plantUML_element', 'target': 'get_plantUML_element', 'target_inputs': ['child', 'inner_indentation'], 'target_returns': ['plantuml_str']}, {'source': 'get_plantUML', 'target': 'get_plantUML_element', 'target_inputs': ['element', \"'  '\"], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'code_graph', 'target_inputs': ['file_summary'], 'target_returns': [\"{'nodes': nodes, 'edges': edges}\", 'edge_data']}, {'source': 'get_code_graph', 'target': 'extract_control_flow_tree', 'target_inputs': ['file_ast.body'], 'target_returns': ['control_flow_tree']}, {'source': 'get_code_graph', 'target': 'reorganize_control_flow', 'target_inputs': ['entire_code_graph', 'control_flow_tree'], 'target_returns': ['reorganize_structure(control_flow_structure, starting_points)', 'organized']}, {'source': 'get_code_graph', 'target': 'get_plantUML', 'target_inputs': ['control_flow_structure'], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'str', 'target_inputs': ['e', 'e']}]}"
    },
    {
        "instruction": "Functions in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "'code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'extract_control_flow_tree', 'reorganize_control_flow', 'reorganize_structure', 'get_plantUML_element', 'get_plantUML', 'get_code_graph'\n\nPurpose and Significance:\n1. Purpose & Significance of Functions:\n   a) code_graph(): This function plays a central role by creating a graphical representation of the code structure from extracted file details stored in 'file_summary'. It organizes nodes for functions, classes along with their method calls as edges adding data to edges accordingly. It returns node and edge lists useful later.\n   b) get_edge_data_from_details(): An auxiliary function utilized by code_graph(), it fetches information about targets & sources based on related details and populates graph edges with the relevant data.\n   c) add_edge_with_data(): Adds directed edges to the code graph considering source nodes connecting to target nodes in a meaningful way.\n   d) add_edges_for_calls(): Parses function definitions and class method calls as nodes in the graph while linking them appropriately if necessary.\n   e) extract_control_flow_tree(): Breaks down Abstract Syntax Tree (AST) nodes into a control flow structure representing the program logic, generating dictionary elements.\n   f) reorganize_control_flow(): Identifies starting points from the generated graph and rearranges the control flow structure to match it for better understanding.\n   g) reorganize_structure(): A recursive helper function within reorganize_control_flow(), responsible for sorting elements based on given start points.\n   h) get_plantUML_element(): Generates PlantUML code for each element in the control flow structure with custom indentation levels.\n   i) get_plantUMLe(): Concatenates PlantUML codes from reorganized control flow structure to form an overall activity diagram representation of the source code logic visualization.\n   j) get_code_graph(): Combines all these processes, extracting code graph with control flow details while producing PlantUML output as a result. Each function serves as a step towards creating structured software documentation for analyzed Python files."
    },
    {
        "instruction": "1) Describe the overall Purpose and Processing Approach of Python file: `py2dataset\\get_code_graph.py`; 2) Define API Signatures for each applicable Function and Class Method; 3) Derive Functional Requirements to specify the code's behavior and purpose; 4) Explain what each variable does in the code.",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "1) Description: The given Python file 'get_code_graph.py' aims to analyze source code details extracted from a file summarized as dictionary format, generate a directed graph representing relationships among functions and classes within it, extract control flow tree from Abstract Syntax Tree (AST), reorganize the control flow structure according to the generated graph, and produce PlantUML activity diagram code for visualization purposes. It consists of several interconnected functions that perform specific tasks related to creating a code graph, parsing AST nodes for control flow extraction, restructuring control flow based on the graph, and generating PlantUML representation from the extracted elements.\n\n2) API Signatures:\n- `code_graph(file_summary: Dict[str, Union[Dict, str]] -> Dict[str, Union[List[str], Dict[str, List[str]]]:` Extracts function and class method details from the file summary dictionary, creates a directed graph representing code relationships using NetworkX DiGraph, adds nodes and edges with related data. Returns a dictionary containing nodes and edges representing the code structure.\n- `get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict`: Extracts edge data from details of targeted and source objects based on their information retrieved during graph construction.\n- `add_edge_with_data(source: str, target: str, init_method: Optional[str] = None) -> None`: Adds edges to the graph with associated data between nodes in the code graph.\n- `add_edges_for_calls(source_name: str, calls: List[Any]) -> None`: Iterates through function definitions and class method calls adding them as nodes and edges if applicable.\n- `extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]`: Parses AST nodes to create a control flow tree structure representation of the code logic.\n- `reorganize_control_flow(code_graph: Dict[str, Union[List[str], Dict[str, List[str]], control_flow_structure) -> List[dict]]`: Gets starting points from the code graph and recursively rearranges the control flow structure to match it.\n- `get_plantUML_element(element, indentation=\"\") -> str`: Generates PlantUML code for each element in the control flow structure with given indentation level.\n- `get_plantUML(control_flow_structure) -> str`: Produces overall PlantUML activity diagram code from the reorganized control flow structure.\n- `get_code_graph(file_summary: Dict[str, Union[Dict, str], file_ast) -> Tuple[Dict[str, List[dict], List[dict], str]`: Combines entire code graph creation with control flow extraction and PlantUML generation.\n\n3) Functional Requirements:\n- [req01] `code_graph()` creates a lookup dictionary for function and class method details from file summary, builds a directed graph with nodes representing classes/functions as sources/targets of method calls adding edges with data where needed; generates node list and edge list for later usage.\n- [req02] `extract_control_flow_tree()` traverses AST nodes extracting code structure information in terms of 'if', 'while', 'try-catch' blocks, etc., producing control flow tree elements.\n- [req03] `reorganize_control_flow()` locates starting points from the generated graph and restructures control flow elements accordingly.\n- [req04] `get_plantUML_element()` generates PlantUML code for each element recursively with indentation levels, forming activity diagrams for visualization purposes.\n- [req05] `get_plantUML()` collects all PlantUML codes from reorganized control flow structure elements and concatenates them into a single string representation.\n- [req06] `get_code_graph()` invokes code graph creation, control flow extraction using AST traversal, control flow reorganization, and PlantUML generation altogether returning results as tuples.\n\n4) Variables Explanation:\n- `function_details_lookup`, `class_method_details_lookup`: Dictionaries storing function/class method details for graph construction.\n- `G`: NetworkX DiGraph object representing the code relationships.\n- `nodes`, `edges`: Lists containing nodes and edges in the generated graph.\n- `source_name`, `target`, `init_method`: Identifiers referring to function/class names for edge building.\n- `starting_points`, `control_flow_tree`, `code_graph`, `plantUML`, `element`, `indentation`: Used in different functions for specific purposes related to graph traversal, control flow manipulation and PlantUML generation.\n- `node_keywords_map`: Mapping Python keywords to their respective PlantUML representations."
    },
    {
        "instruction": "Inputs to `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'file_summary'\n\nPurpose and Significance:\nPurpose & Significance of 'file_summary' input in `code_graph():`\nThe given input parameter named 'file_summary' primarily carries comprehensive data extracts derived from analysis or parsed form a programming source file into dictionary format. In Python file 'get_code_graph.py', this dictionary acts as the foundation for constructing code relationships among functions and classes within the analyzed file content. It holds crucial information such as function definitions ('function_defs'), class definitions ('class_defs'), method details ('method_defs') for both classes and functions which further enables `code_graph()` to generate an accurate Directed Graph representation of their connections and interactions. Each segment of 'file_summary' is employed individually by different functionalities within the function such as adding nodes (classes/functions) in the graph, establishing edges based on method calls or defining edge data according to associated details for those nodes. In essence, 'file_summary' serves as a vital source containing comprehensive metadata necessary to construct a structured representation of the code under analysis and drive further operations within `code_graph()`."
    },
    {
        "instruction": "Docstring of `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code."
    },
    {
        "instruction": "Calls made in `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', 'class_details['method_defs'].items', 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'get_edge_data_from_details', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'add_edge_with_data', 'function_details_lookup.items', 'add_edges_for_calls', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'nodes_to_remove.append'\n\nPurpose and Significance:\nIn the `code_graph` function within the given Python script 'get_code_graph.py', several operations are executed to construct a directed graph representing relationships among functions and classes in source code using NetworkX DiGraph object named 'nx.DiGraph'. These calls serve specific purposes as follows:\n\n1. `function_details_lookup.update()`: Updates the function details lookup dictionary with extracted information from file summary for further processing in building the graph connections.\n2. `class_def.items()`: Retrieves tuples of keys and corresponding values (classes with their properties) from each class definition to proceed with adding nodes for classes.\n3. `G.add_node()`: Inserts node/classes obtained in the previous step as elements of 'nx.DiGraph', mapping graph vertex names and relationships ahead.\n4. `class_details['method_defs'].items()`: Gains method details per class instance for linking class nodes to respective function methods as graph edges later on.\n5. `G.add_edge()`: Connects source classes with target methods/functions in the code graph using the provided parameters based on the relationships retrieved during loop iterations over file details and adds related metadata via 'get_edge_data_from_details' results to the edge connections.\n6. `target_details.get()`, `function_details_lookup.get()`: Fetch details for targeted or source entities to prepare data required for edges between nodes in the graph structure.\n7. `list()`, `set()`: Creates empty lists for storing nodes and edges, while managing unique node occurrences during processing.\n8. `class_method_details_lookup.get()`: Retrieves method details from class lookup dictionary if needed for edge creation purposes.\n9. `add_edge_with_data()`: Adds edges to the graph with metadata related to their respective nodes (functions or methods).\n10. `function_details_lookup.items()`, `add_edges_for_calls()`, `class_method_details_lookup.items()`: Assist in discovering and handling function/method calls across classes to generate further edges as necessary for a comprehensive graph.\n11. `G[source][target].update()`: Modifies an edge object of the DiGraph based on extracted information during edge addition with corresponding data updating operation.\n12. `G.edges.data()`: Gets raw information regarding current nodes/edge properties before necessary alterations such as removal unused graph components in final preparation stages.\n13. `nodes_to_remove.append()`: Eliminates superfluous elements present only as edge targets or sources but not both, cleaning up the graph for better representation."
    },
    {
        "instruction": "Variables in `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'function_details_lookup', 'G', 'source_details', 'class_names', 'fully_qualified_name', 'init_method', 'method_name', 'called_class_name', 'file_summary', 'class_method_details_lookup', 'edges', 'init_method_name', 'nodes', 'nodes_to_remove', 'edge_data', 'target_details', 'qualified_method_name'\n\nPurpose and Significance:\n1. function_details_lookup & class_method_details_lookup: These dictionaries store extracted details about functions and class methods respectively for creating connections within the directed graph. Function_details_lookup keeps information of Python functions while class_method_details_lookup contains Class definitions and their related method data from provided file summary. They are essential in identifying nodes during graph construction.\n\n2. G (NetworkX DiGraph): It represents the code relationships as a directed graph where nodes represent classes/functions, edges depict method calls between them with additional data about inputs/returns associated with each connection. This object is central to building the overall structure of the code graph.\n\n3. source_details & target_details: These temporary variables hold specific details of source and target nodes during edge creation in `code_graph`. They are used to fetch relevant information for adding data to edges between nodes.\n\n4. class_names: A list obtained from file summary containing names of all classes defined within the code, utilized while identifying valid method calls within class definitions.\n\n5. fully_qualified_name & init_method_name: 'fully_qualified_name' creates a combined string for representing complete class name along with its method when needed in graph edges formation. 'init_method_name' stores the constructor method name of a class temporarily during edge creation.\n\n6. file_summary: It is the input dictionary containing overall details extracted from the analyzed Python file, including function_defs and class_defs which are used to initialize lookup dictionaries and construct graph nodes/edges accordingly.\n\n7. edges: A list of edges in the code graph consisting of source, target node pairs along with associated data for input/return relationships between them. This information helps in understanding the dependencies within functions and classes.\n\n8. init_method & method_name: These variables assist in differentiating class constructor methods from other regular ones during edge building when dealing with class instances calls. 'init_method' refers to the constructor method while 'method_name' stores temporary values related to function/class method names.\n\n9. nodes & nodes_to_remove: 'nodes' is an initial list of all nodes present in the graph including classes, functions and methods. 'nodes_to_remove' holds nodes that do not serve as edge source or target thereby can be ignored in the final graph output ensuring minimal data for a lean structure.\n\n10. edge_data: Contains extracted data like inputs and returns of a method call edge which is later added to edges during graph construction. It helps annotate connections with relevant information about dependencies between nodes.\n\n11. target & source: These variables are used while iterating through edges in the NetworkX DiGraph for adding edge data according to their relationships in Python code logic."
    },
    {
        "instruction": "Returns from `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'{'nodes': nodes, 'edges': edges}', 'edge_data'\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py', the function `code_graph(file_summary: Dict[str, Union[Dict, str]) -> Dict[str, Union[List[str], Dict[str, List[str]]]' plays a pivotal role in developing software documentation relating to a code structure representation. Its primary purpose is to extract function and class method details from the given file summary dictionary and construct a directed graph depicting relationships within the codebase. The returned output consists of three significant elements as follows:\n\n1. 'nodes': This segment comprises an enumeration of nodes (classes, functions, etc.) involved in the generated graphical representation. Each node corresponds to entities like class instances or function definitions serving as sources/targets for method calls within the codebase.\n\n2. 'edges': It represents a list containing edge information between various nodes in the directed graph. Each entry holds source and target pairs alongside relevant metadata acquired from associated functions or methods during graph development. The data added to edges aids further understanding of call relations in the program's execution flow.\n\n3. Additionally, there exists an optional third component 'edge_data', but it is not consistently returned by `code_graph`. This element gets instantiated during graph creation yet remains absent when generating final output due to exclusion in the main return statement. However, it serves as a helper function ('get_edge_data_from_details') to fetch details about target and source entities while constructing edges within the code graph. The omission of 'edge_data' may infer an oversimplification aiming brevity for structured documentation purpose in this particular context rather than representing missing functionality within code operations.'"
    },
    {
        "instruction": "Inputs to `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'nodes'\n\nPurpose and Significance:\nPurpose & Significance of 'nodes' Input in `extract_control_flow_tree` Function:\nIn the given Python script 'get_code_graph.py', the `nodes` parameter holds a list comprising Abstract Syntax Tree (AST) nodes from the source code under analysis. This input plays a crucial role within the `extract_control_flow_tree()` function, where it acts as an entry point to parse each node in the code and create a hierarchical representation of control flow structures present throughout the program logic. As `extract_control_flow_tree()` navigates through these nodes, it categorizes different code constructs like functions ('def' statements), classes ('class' declarations), conditional statements ('if', 'while'), exception handling blocks ('try-catch') and more into a control flow tree format for further processing. This tree structure helps in understanding the program flow better by mapping distinct parts of the source code as parent nodes with their nested components as child nodes under them. In essence, `nodes` are instrumental in determining how diverse sections interact within the program flow leading to its comprehension and eventual PlantUML rendering using specific methods defined previously for constructive modeling visualizations (as stated by other API descriptions such as 'get_plantUML_element()'). It primarily provides actionable insights facilitating program structuring."
    },
    {
        "instruction": "Docstring of `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree"
    },
    {
        "instruction": "Calls made in `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'type', 'control_flow_tree.append', 'ast.unparse', '', '.join', 'extract_control_flow_tree', 'isinstance', 'except_block.append'\n\nPurpose and Significance:\nIn `extract_control_flow_tree`, several key operations are performed to extract a control flow tree structure from Abstract Syntax Tree (AST) nodes within Python code. The mentioned calls contribute significantly towards achieving this goal. Their purpose and roles can be elaborated as follows:\n\n1. 'type(node)' or 'ast.unparse(node)' - These calls help retrieve relevant information about the node type or unparse its string representation respectively. They assist in identifying different programming constructs such as functions, classes, loops, exceptions handling blocks, etc., which are essential for building the control flow tree structure accurately.\n\n2. '.join([...])' - This built-in Python method concatenates elements of an iterable (list or string) into a single string separated by a specified delimiter ('', in this case). It is used to create readable strings representing loops or conditions in the control flow tree structure for PlantUML representation.\n\n3. 'extract_control_flow_tree' - This function call initiates the extraction process itself as part of the larger algorithm flow. It traverses through AST nodes, extracting their logic into a list/dict format that forms the core elements of control flow structure further manipulated for plantUML representation or analysis.\n\n4. 'isinstance(element, [...]') - Python's built-in isinstance() checks whether an object is an instance of a specific class type (here, either dictionary or string). This validation helps differentiate between nested elements in the control flow tree construction process by distinguishing dictionaries representing complex structures from plain strings denoting individual nodes.\n\n5. 'control_flow_tree.append([...])' - During traversal of AST nodes, whenever a matching structure is identified and processed (like functions or loops), its PlantUML representation gets added to the 'control_flow_tree' list using this append call. This accumulates all parsed elements into a single data structure for further processing.\n\n6. 'except_block.append([...])' - When encountering an exception handling block ('except') in AST traversal, its details are stored temporarily in 'except_block'. Once finished with the current try block parsing, this list is appended to the control flow tree structure for complete representation of exception handling logic within try-catch blocks."
    },
    {
        "instruction": "Variables in `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'key', 'if_block', 'except_block', 'keyword', 'h_name', 'try_block', 'control_flow_tree', 'value', 'else_block', 'h_type', 'nodes', 'orelse', 'finally_block', 'control_flow_dict', 'node_type', 'args_str', 'node_keywords_map'\n\nPurpose and Significance:\n1. Purpose & Significance: In `extract_control_flow_tree`, these variables contribute towards extracting the control flow structure from Python Abstract Syntax Tree (AST) nodes, forming a comprehensible hierarchy representing program logic for further analysis or visualization purposes.\n\n2. Variable Details:\n   a) 'key': Stores current keyword parsed during AST traversal as dictionary keys indicating type of node encountered (e.g., 'def', 'if', 'class', 'try', etc.). Helps distinguish control flow constructs like functions, classes, conditional statements or exception handling in the code while forming tree elements.\n   b) 'if_block': Stores subordinate dictionary containing all child nodes corresponding to an if statement, utilized during recursive traversal within 'if' blocks.\n   c) 'except_block': Holds a list of dictionaries representing exception handling sections in the control flow tree structure.\n   d) 'keyword': Temporarily captures extracted node type to process next in iterative loops before parsing the whole statement recursively for building corresponding structures within `control_flow_tree`. It aids code understanding based on given node instances in AST traversal.\n   e) 'h_name': Refers to exception handler name when encountered during exception block extraction from AST nodes.\n   f) 'try_block': Represents Python's 'try...' syntax holding exceptions processing instructions (includes children of the original node); also expanded via recursive methodology inside tree structures.\n   g) 'control_flow_tree': Stores nested dict-list representing entire control flow structure extracted from AST nodes, which is returned as final output by this function.\n   h) 'value': Holds parsed values associated with each keyword encountered during traversal; may be string elements or other nested structures in the tree formation process.\n   i) 'else_block': Stores else statement children within `control_flow_tree` if found during recursive traversal of AST nodes.\n   j) 'h_type': Maps extracted type info attached with except clauses containing identifier ('baseclass', 'exceptionclass'), identifying respective Python Exception catching details for comprehensive handling portrayals.\n   k) 'nodes': Initially holds all parsed AST nodes but later filtered as starting points in `reorganize_control_flow()`.\n   l) 'orelse': Retrieves optional else-if statements associated with an if clause or try statement to enrich the control flow structure within the tree construction.\n   m) 'finally_block': Denotes 'finally' section contents during exception handling parsing from AST nodes added as a dictionary in `control_flow_dict`.\n   n) 'control_flow_dict': Temporary storage for try-except-finally blocks with nested child elements.\n   o) 'node_type': Identifies node type during traversal to differentiate between function/class definitions, loops or conditional statements while processing AST nodes.\n   p) 'args_str': Concatenates arguments string representation for function definition in PlantUML generation (used in `get_plantUML_element`).\n   q) 'node_keywords_map': Maps Python keywords to their respective PlantUML representations for visualization consistency. This mapping helps convert syntax into understandable diagrams later during PlantUML code generation."
    },
    {
        "instruction": "Returns from `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'control_flow_tree'\n\nPurpose and Significance:\n1) Purpose of 'control_flow_tree': In the context of 'get_code_graph.py', `control_flow_tree` holds the extracted control flow structure obtained after traversing Abstract Syntax Tree (AST) nodes during execution of the `extract_control_flow_tree()` function. It represents the logical sequence of statements in a Python file as a list containing dictionaries or strings representing various code elements such as functions, classes, loops ('if', 'while'), exceptions ('try-catch') blocks, etc. Understanding and mapping relationships amongst them contributes toward analysis tasks or generation of plantUML representation required to visually model source codes execution.\n\n2) Key Tasks within `extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]] function include parsing each given node (of AST):\n   a) Recognizing keywords ('def', 'class', 'if', 'for', 'while', 'try', 'except') to identify code blocks and create corresponding dictionary entries or string representations.\n   b) For strings encountered directly, adding them as they are without further processing.\n   c) Handling nested structures like functions ('def'), classes ('class'), loops ('if', 'while'), exceptions ('try') with appropriate indentations ('startuml..'). Once AST nodes analysis finishes entirely `control_flow_tree` constitutes whole plantUML structure details representing source code actions leading toward accurate execution behavior elucidation.'''"
    },
    {
        "instruction": "Inputs to `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'element', 'indentation'\n\nPurpose and Significance:\nIn the function `get_plantUML_element`, parameters ['element' and 'indentation'] play crucial roles in generating PlantUML activity diagram codes for individual elements extracted from the control flow structure. These inputs contribute to constructing visually understandable representations of program logic within the overall PlantUML output.\n\n1) Purpose of 'element': This parameter represents an element from the control flow structure obtained after traversing and analyzing Abstract Syntax Tree (AST). It can be either a dictionary containing nested elements or a string representing standalone statements like 'if', 'def', 'class', etc., in the code. The `get_plantUML_element` function processes this element to create PlantUML formatted text for visualization purposes.\n\n2) Significance of 'indentation': It is an optional string specifying the current indentation level used during recursive traversal of the control flow structure. Indentation helps maintain readability in PlantUML representation by structuring codes vertically based on nested scopes in Python programs, allowing easier understanding of their logical groupings. When 'element' is a dictionary denoting complex code blocks such as 'def', 'try', or exception handling sections ('except'), indentation adjusts accordingly to align nested statements within PlantUML output properly. While dealing with strings representing standalone statements like ':' (colon), it serves no specific nesting purpose but preserves uniform formatting across the diagram for readability.'"
    },
    {
        "instruction": "Docstring of `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element"
    },
    {
        "instruction": "Calls made in `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'isinstance', 'next', 'iter', 'key.startswith', 'get_plantUML_element'\n\nPurpose and Significance:\n1. Purpose and Significance of Called Functions in `get_plantUML_element` within GetCodeGraph Module:\n   In the `get_plantUML_element` function, four major calls serve different purposes crucial to creating PlantUML representations from given elements of the control flow structure:\n\n   a) instanceof(`element`, type(element)) - Determines the kind or class identity of each encountered item (either dict representing method declarations/conditions etc. or plain strings holding instructions like 'if', 'for' statements in control flow) prior to building PlantUML code snippets. This allows tailoring PlantUML formatting accordingly.\n\n   b) next(iter(element)) - Retrieves the first key from a dictionary element (method name/condition keyword) when iterating over its contents, facilitating the generation of PlantUML syntax for method definitions ('def', 'class', 'if', etc.) or exception handling blocks ('catch').\n\n   c) iter(`control_flow_structure`) - Provides an iterator object over elements in the control flow structure to traverse it sequentially while generating PlantUML code.\n\n   d) key.startswith('keyword') - Checks if a specific keyword prefix is present in each encountered element's key (e.g., 'def', 'class', 'if', 'for', 'while', 'try', or 'except'). This enables conditionally formatting PlantUML code based on the control flow structure type.\n\n   e) `get_plantUML_element` itself - Generates PlantUML activity diagram code for each element in the control flow structure with appropriate indentation levels, creating a readable visual representation of program logic using the '@startuml', '@enduml' tags as well as symbols corresponding to different Python statements or keywords encountered during traversal."
    },
    {
        "instruction": "Variables in `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'key', 'value', 'indentation', 'inner_indentation', 'plantuml_str', 'element'\n\nPurpose and Significance:\nIn `get_plantUML_element`, these variables hold crucial roles during the generation of PlantUML activity diagram code for individual elements within the control flow structure. Their purposes are as follows:\n\n1. `key`: Represents the current key extracted from a dictionary element in the control flow tree as Node Types that denote the flow operation (\"def\", \"if\", \"for\", etc.), providing important details while shaping the visual structure on the activity diagram like methods ('functions', if condition checks). During each loop cycle, `next(iter(element))` fetches the first key of a dictionary element.\n\n2. `value`: Represents either a nested list containing child elements (for recursive calls) or a string representing single operations in control flow tree structure. Depending on whether 'element' is a dictionary or not, `next(iter(element))` retrieves it for further PlantUML formatting.\n\n3. `indentation`: Denotes the current indentation level used to format PlantUML code lines with proper spacing while creating activity diagrams. It helps in structuring nested elements correctly within the diagram. Initially set as an empty string (\"\") but gets updated when generating subordinate element's PlantUML representation with 'inner_indentation'.\n\n4. `inner_indentation`: Serves as a modified version of indentation level used for child elements in nested control flow operations (like 'if', 'for', 'while', 'try-catch') where more indentation is required compared to single line statements like methods or exceptions. It gets incremented by adding two spaces (\" \") from the original indentation value ('indentation + \"  \") when processing subordinate elements recursively.\n\n5. `plantuml_str`: An accumulating string used as an interim repository holding each generated PlantUML fragment obtained via get_plantUML_element(). At completion, all generated elements from `control_flow_structure`, merged PlantUML snippets produce the final diagram code representation.\n\n6. `element`: Represents a single element from the control flow structure passed to `get_plantUML_element()`. It can be either a dictionary (containing nested operations) or a string representing a simple operation within the flow tree, and PlantUML formatting depends on its type ('dict' or 'str').''"
    },
    {
        "instruction": "Returns from `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'plantuml_str'\n\nPurpose and Significance:\nIn the given Python script 'get_code_graph.py', the variable '_plantuml_str'_ holds a significant role within the function `get_plantUML()`. This string serves as an accumulator for generating PlantUML activity diagram codes during the analysis of parsed source code details extracted from Abstract Syntax Tree (AST) nodes. The `get_plantUML()` method concatenates all generated PlantUML codes resulting from calling `get_plantUML_element()` function recursively on each element within the reorganized control flow structure. Each invocation of `get_plantUML_element()` creates PlantUML representation for individual code fragments with proper indentation levels, eventually forming a comprehensive visualization diagram representing the entire file's logic flow. Thus, '_plantuml_str'_ collects all these fragmented PlantUML codes into one string output that can be utilized externally to visualize the program's control flow using tools like PlantUML viewer applications or other software compatible with this format."
    },
    {
        "instruction": "Inputs to `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'code_graph', 'control_flow_structure'\n\nPurpose and Significance:\n1) Purpose of Inputs in `reorganize_control_flow` Function:\n   The `reorganize_control_flow` function within 'get_code_graph.py' plays a crucial role in restructuring and managing control flow extracted from Abstract Syntax Tree (AST), adhering to the architecture present in generated Code Graph information for enhanced logical flow analysis. Its inputs have the following key objectives:\n\n    a) 'code_graph': This input provides the entire directed graph representation of relationships among functions, classes, and their respective method calls within the source code. It serves as a reference point for determining starting points in the control flow structure reorganization process. The graph helps identify nodes that act as entry points to traverse the control flow tree more efficiently.\n\n    b) 'control_flow_structure': This input represents the extracted control flow tree from AST nodes, which is initially unordered and may not align with the code graph relationships. `reorganize_control_flow` aims to reshape this structure by utilizing the code graph's starting points to establish a logical order. As a result, the function ensures that the rearranged control flow matches the actual code flow more accurately.\n\n   Together, these inputs facilitate creating a coherent visualization of the program logic using PlantUML activity diagrams by aligning extracted control flow with the underlying code graph relationships for better comprehension and debugging purposes."
    },
    {
        "instruction": "Docstring of `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure"
    },
    {
        "instruction": "Calls made in `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'set', 'isinstance', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend', 'reorganize_structure'\n\nPurpose and Significance:\nIn `reorganize_control_flow`, these distinct calls serve different purposes that collectively enable proper structuring of the control flow tree to match the relationships established by the generated code graph.\n\n1. 'set()': An instance of built-in Python collection used in creating a Set object called 'seen', responsible for storing elements processed earlier to ensure recursion does not include any redundant nodes during traversal through the control flow structure. This prevents duplication while reorganizing the tree.\n\n2. 'isinstance()': A built-in function checking if an object belongs to a specific class or derives from it. It helps verify whether the current element being processed is a dictionary type (indicating a node in the control flow structure). If not, the code skips ahead to handle string elements as standalone statements without further recursion.\n\n3. 'next()': A function utilized within iterators to fetch the next item from an iterable object such as dictionaries during traversal of keys in each element encountered during reorganization. It ensures moving through control flow structure keys sequentially until finding a match with any starting point identified from the code graph nodes.\n\n4. 'iter()': A built-in function that returns an iterator over the given object's elements or attributes, enabling traversal of keys in each dictionary element within the control flow structure for processing purposes in `reorganize_control_flow`.\n\n5. 'json.dumps()': Serializes Python objects into a JSON string representation that becomes handy as ID for recognition within already encountered entities preventing loops or additional visits of matched structures ahead while arranging nodes sequentially, indicating identification confirmation inside recursive logic flow control checks. This call guarantees efficient execution when comparing elements during reorganization.\n\n6. 'organized.append()': Appends validated elements to a list named 'organized', which stores the restructured control flow tree parts that align with starting points from the code graph. It collects elements deemed relevant for the final output after verification and processing.\n\n7. 'seen.add()': Adds processed elements into the 'Set' object 'seen', marking them as visited nodes, maintaining uniqueness of recursively iterated parts while discovering potential subsequent links within control flow structure sections during structuring tasks in `reorganize_control_flow`. This excludes already dealt entries avoiding circular calls for effective exploration and rearrangement.\n\n8. 'organized.extend()': Extends the 'organized' list with remaining elements not included in previous iterations but still part of the control flow structure. It ensures comprehensive coverage of all relevant nodes during structuring regardless of encountered matches within code graph starting points.\n\n9. Lastly, 'reorganize_structure()': The top-level function defining recursive logic in `reorganize_control_flow`, iterating through each element in the control flow structure and invoking the nested functions to carry out rearrangement as per code graph starting points. It coordinates all aforementioned operations to create a revised tree layout that aligns with graph relationships."
    },
    {
        "instruction": "Variables in `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'key', 'element_id', 'code_graph', 'starting_points', 'targets', 'remaining', 'control_flow_structure'\n\nPurpose and Significance:\n1) Purpose and Significance of Variables in `reorganize_control_flow` Function:\n   a. 'key': Used during recursive traversal through control flow structure dictionary elements to identify the current key being processed, essential for matching starting points comparison with graph nodes later on.\n   b. 'element_id': Temporary identifier generated by JSON serialization of each element in the control flow structure as it gets added to organized list to avoid duplication during recursion. This ensures unique identifiers are assigned for each node when reconstructing reorganized flow without repeating nodes already encountered.\n   c. 'code_graph': A prerequisite argument supplying relationships within the code through nodes and edges that direct `reorganize_control_flow` in rebuilding the control flow structure based on the given graph hierarchy.\n   d. 'starting_points': Resulting from graph analysis to discover entry points within the control flow tree, these nodes serve as references for initiating recursion in the function to reconstruct the flow according to code relationships.\n   e. 'targets': Initially contains edges' targets extracted from `code_graph`, but later transformed into starting points after filtering out nodes matching with 'starting_points'. It helps in identifying nodes that don't have incoming edges, indicating potential starting points for traversal.\n   f. 'remaining': Stores elements remaining in the control flow structure after adding elements to organized list ('organized'), containing parts of the original structure not yet considered during recursion.\n   g. 'control_flow_structure': Argument carrying entire inputted control flow tree as a list of nested dictionaries and strings representing code logic for restructuring according to the generated graph hierarchy in `reorganize_control_flow`. This variable undergoes transformation into a rearranged version reflecting relationships found in the code graph."
    },
    {
        "instruction": "Returns from `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'reorganize_structure(control_flow_structure', 'starting_points)', 'organized'\n\nPurpose and Significance:\nPurpose & Significance of `reorganize_structure(control_flow_structure, starting_points) Returns ['organized'] in get_code_graph.py:\nThis function within 'get_code_graph.py' plays a crucial role in rearranging the control flow structure extracted from Abstract Syntax Tree (AST) to align with the generated code graph relationships obtained through `code_graph()`. Its primary objective is to ensure that the control flow elements are organized according to the established nodes and edges within the directed graph created earlier. The provided signature takes two arguments: 'control_flow_structure' containing parsed control flow tree data and 'starting_points', a list of nodes identified as initiation points in the code graph where no incoming edges exist. After restructuring, it returns an organized version of the control flow structure represented by ['organized'] list containing elements arranged as per the code graph connectivity. This rearrangement is significant for further processing such as PlantUML generation in `get_plantUML()` function to create accurate visual representations of program logic flow."
    },
    {
        "instruction": "Inputs to `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "'source_name', 'calls'\n\nPurpose and Significance:\nIn the context of the 'get_code_graph.py' script, within the 'add_edges_for_calls' function, '[source_name', 'calls'] holds critical inputs that impact the addition of nodes and edges into the created NetworkX DiGraph object (G). These variables serve to facilitate connecting functions and class methods in a meaningful manner while constructing the code graph.\n\n1) Purpose of 'source_name':\n   - 'source_name' represents either a function name or a qualified class method name (class_name + method_name), acting as an origin point for potential edges within the code graph creation process. It helps identify nodes that might have calls to other functions or methods, allowing connections between them in the directed graph representation of relationships among different parts of the source code.\n\n2) Purpose of 'calls':\n   - 'calls' refers to a list containing target function/method names that are invoked by the current node ('source_name'). It collects data on where a particular function or class method is being utilized, leading to edge generation between different nodes in the graph structure. By traversing this list for each source node during graph formation, relationships between functions and methods are accurately depicted through directed edges."
    },
    {
        "instruction": "Calls made in `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "'list', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'add_edge_with_data', 'G.add_node'\n\nPurpose and Significance:\nIn `add_edges_for_calls`, situated within the 'code_graph' function in 'get_code_graph.py', several list manipulations and string operations are performed to construct a directed graph representing relationships among functions and classes within a given Python file summary. These calls play crucial roles in building edges between nodes (functions or class methods) with respective attributes carried by data as part of NetworkX DiGraph processing:\n\n1. `class_def.keys()` extracts lists containing the class definitions available within `file_summary`, further allowing traversal across 'function_defs' and 'class_defs'. This helps identify classes for method call analysis.\n2. `called.split('.')[0]` separates a fully qualified method name into its class name when dealing with instance methods. If a node refers to a class method invocation ('called' denotes the target), this function retrieves its root class part necessary for creating appropriate graph edges.\n3. `called.startswith('self.')` verifies whether a string 'called' contains an initialization call. In Python syntax, instance methods always start with 'self.' and checking it confirms if current method access is referring to one of those instances in the graph structure creation process.\n4. `called.replace('self.', '')` removes the leading 'self.' prefix from a string when dealing with class methods invocation ('called') to maintain consistency in edge labeling during graph formation.\n5. `add_edge_with_data(source_name, called)` adds edges between nodes (functions or classes) in the NetworkX DiGraph object 'G', passing relevant data related to their relationships. This function utilizes information gathered from previous operations in its parameters, attaching data elements derived through graph edges appropriately.\n6. Lastly but notably significant is `G.add_node(source_name)`, `G.add_node(qualified_method_name)` and `G.add_edge(source, target)`. These NetworkX DiGraph methods add nodes (functions or classes) to the graph as sources/targets of method calls, establishing edges between them with data attributes derived from function/class details lookup dictionaries. They are essential for constructing a comprehensive code graph representation.'"
    },
    {
        "instruction": "Variables in `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "'source_name', 'class_names', 'init_method', 'fully_qualified_name', 'method_name', 'called_class_name', 'init_method_name', 'calls'\n\nPurpose and Significance:\nIn the `add_edges_for_calls` function within the get_code_graph.py module, several variables play crucial roles to establish edges between nodes representing functions and classes during the generation of the directed graph indicating dependencies and calls relations. These variables help trace program logic for efficient structure development as outlined below:\n\n1. `source_name`: Temporarily holds the current function or class method name being processed while adding edges in the code graph. It acts as a reference point to identify where an edge originates from during node connection.\n\n2. `class_names`: A list containing class names extracted from file summary details, used to determine if a called node belongs to any class definition when handling 'with', 'try-except' blocks in the control flow tree extraction phase. This helps maintain accurate relationships in the final code graph representation.\n\n3. `init_method`: In cases of initialization methods (class __init__, acts as a temporary variable that holds its fully qualified name (i.e., combining class and method) when creating edges between classes and their initializers. It assists in connecting classes to their respective constructors accurately.\n\n4. `fully_qualified_name`: Combines the class name with the method name while handling method calls resulting from __init__ for more precise connections between a constructor (initializer) node in the code graph construction. This enables recognizing method relationships clearly as a part of specific classes when forming dependencies within the graph structure.\n\n5. `method_name`: Identifies the specific function or class method being referenced during edge formation within class methods for establishing method call relations. It ensures appropriate linkage in the code graph while considering class scopes.\n\n6. `called_class_name`: Indicates the targeted class name when examining nodes involving exception handling blocks (try-except), which are not explicitly part of function or method names but still require proper association with their respective classes in the graph representation. This variable helps maintain accurate relationships between exception handlers and their parent classes.\n\n7. `init_method_name`: Similar to init_method, but narrows down specifically to initialization methods (__init__) within classes while connecting them with their associated class nodes during edge building processes.\n\n8. `calls`: List of function or method names that serve as call targets in the code graph generation phase. It helps track where a function or method is being invoked from other parts of the program, enabling precise edge addition to the directed graph reflecting dependencies and flow within the source code accurately."
    },
    {
        "instruction": "Inputs to `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'structure', 'start_points'\n\nPurpose and Significance:\n1) Purpose and Significance of Inputs in `reorganize_structure(structure, start_points) Function:\n   The `reorganize_structure` function within 'get_code_graph.py' aims to rearrange the control flow structure obtained from parsing Abstract Syntax Tree (AST) nodes according to the generated code graph relationships. It takes two primary inputs - `structure` and `start_points`.\n\n   a) 'structure': This input represents the extracted control flow tree data after traversing Python code elements such as functions, loops ('if', 'while', 'try-catch' blocks, etc., organized as a list of dictionaries or strings. It holds information about conditional statements, exception handling sections, iterations, function definitions, class declarations, etc., essential for constructing the program flow diagram. The reordering intends to bring semantic correlation in the presentation order consistent with relationships revealed in code_graph's Node/Edge scheme (derived node hierarchies from filesummary['nodes']). This structural consistency aligns program comprehensibility and aids further analysis or visualization processes like PlantUML generation.\n\n   b) 'start_points': These are nodes identified as starting points in the code graph where execution begins without any incoming edges (no preceding function calls). They serve as entry points for traversal within the control flow structure during reorganization. The `reorganize_structure` function filters these nodes from the entire structure list and adds them first to maintain logical order while reconstructing the control flow tree. This ensures that execution begins at the correct locations in the PlantUML diagram generated later by `get_plantUML()`."
    },
    {
        "instruction": "Calls made in `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'set', 'isinstance', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend'\n\nPurpose and Significance:\nIn the function `reorganize_structure` within `get_code_graph.py`, these specific calls serve crucial purposes to achieve effective rearrangement of the control flow structure based on the generated code graph for better visualization. Their roles are outlined as follows:\n\n1. 'set': A built-in Python data type utilized to create a set 'seen' which keeps track of elements already processed during recursion in `reorganize_structure`. This helps avoid duplication while traversing the control flow structure and ensures each element is added only once in the organized output list.\n\n2. 'isinstance': An integral part of determining what action should be taken during each traversal of nested 'elements'. Based on data type verification via 'isinstance()', specific behavior takes effect i.e., creating separate code paths for dictionary elements or string occurrences within the control flow structure.\n\n3. 'next': Used in conjunction with 'iter()' function to extract the first key from a dictionary element during traversal of nested structures like 'dict'. It enables cycling through iterables ensuring iteration till required elements are obtained in desired formats (mainly for recursion convenience).\n\n4. 'iter()': Python language function yielding an iterator object that produces consecutive keys/items for each passable object in `control_flow_structure`, useful with 'next()' call for selecting appropriate parts within dictionary or list structures while handling multiple types encountered during recursion process.\n\n5. 'json.dumps(): A built-in Python library function converting a Python object into a JSON encoded string representation. It is employed to create unique identifiers ('element_id') for each element in the organized structure by serializing them before adding these distinct ids into set 'seen', avoiding repeated processing while ensuring their occurrence tracking during recursive calls within `reorganize_structure`.\n\n6. 'organized.append()': An inbuilt append function which adds elements to a list named 'organized'. This operation accumulates rearranged control flow structure parts as they are identified and processed recursively, eventually forming the final output after traversing the entire tree.\n\n7. 'seen.add()': Adds an element's unique identifier ('element_id') into set 'seen', ensuring that particular elements aren't repeated during recursion and maintaining a record of visited nodes to prevent infinite loops in `reorganize_structure`.\n\n8. 'organized.extend()': This list method extends the 'organized' list with remaining unprocessed elements from the original control flow structure after processing distinct parts, completing the final restructured output formation.'"
    },
    {
        "instruction": "Variables in `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'structure', 'key', 'element_id', 'start_points', 'remaining'\n\nPurpose and Significance:\nIn the function `reorganize_structure` within the 'get_code_graph.py' module, four distinct variables play crucial roles in rearranging the control flow structure according to the generated code graph. These variables are as follows:\n\n1. `structure`: This parameter represents the input control flow tree obtained from parsing Abstract Syntax Tree (AST) nodes. Its content mainly includes different code segments represented by Python dictionaries holding information on nested block constructs such as function definitions ('def' or 'class'), conditionals ('if', 'try', etc.) and loops ('for', 'while'). This variable serves as the primary input for reorganization in order to align it with the graph-based starting points identified later.\n\n2. `key`: As an iterable obtained from `next(iter(element))`, it refers to a unique identifier representing the key or type of each element within the `structure`. The loop extracts keys such as 'def', 'if', 'try', etc., indicating the nature of the code block encountered during traversal. This variable helps in determining how to handle different control flow elements while generating the reorganized structure.\n\n3. `element_id`: A temporary identifier assigned when organizing nested items. Its assignment relates to a json-serialised string version (`json.dumps()`) of the element in the process to distinguish its unique position among recurrent patterns such as method names, ensuring no duplication occurs during reorganization. This variable helps track elements already added to the organized list and avoids repetition while traversing `structure`.\n\n4. `starting_points`: A list of nodes from the code graph that don't have incoming edges (targets). These nodes act as starting points for traversal in the control flow structure rearrangement process since they are not connected to any other elements yet. They initiate the recursive visitation to discover all reachable nodes logically sequenced following dependencies specified by the graph relationships.\n\n5. `remaining`: It holds remaining unvisited items in the `structure`, which couldn't match starting points during traversal. These elements are appended after processing starting points ensuring complete coverage of control flow structure reorganization. The variable 'remaining' is utilized to ensure exhaustive exploration and proper arrangement of all code segments according to graph dependencies."
    },
    {
        "instruction": "Returns from `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'organized'\n\nPurpose and Significance:\nIn the given Python script 'get_code_graph.py', the function 'reorganize_structure' forms a core portion while shaping the outcome leading up to generate a neat and coordinated layout out of Control Flow elements with regard to its linkages within the Code Graph. Its primary purpose lies in rearranging the extracted control flow structure according to the connections established by the code graph. This function plays an instrumental role in ensuring that the Control Flow Tree aligns with the relationships present in the actual codebase, making it easier for visualization and analysis purposes.\n\nThe 'reorganize_structure' returns a list named ['organized'] after its execution which embodies reordered elements derived from input parameters provided: primarily two parameters, 'control_flow_structure', which denotes the extracted Control Flow Tree of program logic in list form and 'starting_points', encompassing all graph nodes devoid of dependencies - the root or initiators that can directly begin processes within this context. Within this process, the function goes recursively deep into every constituent part of input Control Flow Tree by filtering out elements based on their interconnections with starting points identified from the Code Graph. This results in a restructured Control Flow Tree where each element's position reflects its actual placement in the codebase graphically. Thus, this organized representation can be used for visualizations like PlantUML diagrams that exhibit clear relationships among different programming blocks (definitions, loops, conditionals, exceptions handling etc.) within the source code."
    },
    {
        "instruction": "Inputs to `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'file_summary', 'file_ast'\n\nPurpose and Significance:\n1) Purpose and Significance of 'file_summary' in get_code_graph():\n   - File summary refers to the structured dictionary extracted from the Python source file which consists of necessary information like function definitions, class declarations with methods and other vital aspects. This data acts as a foundation for creating a directed graph representing relationships among functions and classes within the codebase. 'file_summary' plays a crucial role in defining nodes (classes/functions) and edges (method calls) in the generated code graph while fetching related details required for edge attributes such as inputs, returns etc., necessary for its formation within `code_graph()` function.\n\n2) Purpose and Significance of 'file_ast' in get_code_graph():\n   - 'file_ast' symbolizes Abstract Syntax Tree or a Python representation of source code where elements such as keywords (like class definition, method invocation statements), flow control nodes etc., are hierarchically organized. This input is used by `extract_control_flow_tree()` function to parse the AST nodes and extract control flow tree structure for further analysis. In conjunction with 'file_summary', it helps in building a comprehensive understanding of the code logic for generating PlantUML diagrams as well as reorganizing control flow according to the generated graph using `get_code_graph()`."
    },
    {
        "instruction": "Docstring of `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details"
    },
    {
        "instruction": "Calls made in `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'code_graph', 'extract_control_flow_tree', 'reorganize_control_flow', 'get_plantUML', 'str'\n\nPurpose and Significance:\nIn the `get_code_graph` function within the 'get_code_graph.py' script, several crucial calls are executed to achieve comprehensive analysis and visualization of a Python source file's structure. Each call serves a distinct purpose that collectively constructs Code Graph, extracts control flow tree from Abstract Syntax Tree (AST), reorganizes the control flow structure based on the graph formed, and generates PlantUML representation for visual representation purposes. Here is an elaboration of each significant call:\n\n1. `code_graph(file_summary)`: This call initiates the process by creating a lookup dictionary containing function and class method details extracted from the given file summary dictionary. It further builds a directed graph using NetworkX DiGraph to represent relationships among classes, functions as sources/targets of method calls in Python code. It adds nodes for these entities, constructs edges with associated data representing function or class method invocations. Finally, it returns a dictionary containing nodes and edges representing the code structure.\n\n2. `extract_control_flow_tree(nodes)`: This call traverses Abstract Syntax Tree (AST) nodes to extract control flow tree elements like 'def', 'if', 'while', 'try-catch' blocks, etc., thereby building a hierarchical representation of the code logic in Python programs. It helps understand the sequential order and conditional statements within the codebase.\n\n3. `reorganize_control_flow(code_graph, control_flow_structure)`: This call identifies starting points from the generated Code Graph's nodes and subsequently rearranges the extracted control flow structure in a way that matches its orderings, improving its clarity by adhering to code relationships established previously. The structured reorganized form improves visual understanding.\n\n4. `get_plantUML('control_flow_structure')`: Starting with building '@startuml', @enduml at the start/end, it uses generated code flow details extracted into elements along with get_plantUML_element(). For every control structure instance like def blocks ('class','function' etc., PlantUML formatting happens within its recursive manner utilizing indented representations as described by indentations in each element. Finally, the entire PlantUML activity diagram code is produced for visualization purposes.\n\n5. `str`: Although not explicitly a call within `get_code_graph`, it's worth mentioning that str represents error string output handling while extracting Control Flow Structure and generating PlantUML code in case of any exception encountered during process execution. The respective calls throw an exception instance converted to a string which gets caught, turning errors into meaningful messages for debugging purposes."
    },
    {
        "instruction": "Variables in `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'control_flow_tree', 'plantUML', 'file_summary', 'entire_code_graph', 'file_ast', 'control_flow_structure'\n\nPurpose and Significance:\n1. control_flow_tree: Holds the extracted control flow tree structure obtained from parsing Abstract Syntax Tree (AST) nodes during the code analysis. Its content signifies logical relationships such as functions calls ('if', 'for' loops, try-except statements that are encountered within a source code representation helpful to illustrate software operation behavior flow visually through PlantUML diagrams.\n\n2. plantUML: Represents generated PlantUML activity diagram code consolidating PlantUML representations for each element from the rearranged control flow structure resulting from `get_plantUML()` function invocation in `get_code_graph`. This finalizes PlantUML presentation required by developers for comprehending system functionalities within given file or code snippets easily.\n\n3. file_summary: Serves as an input argument containing details extracted from a specific file summarized as dictionary format to `get_code_graph()`. It comprises crucial information about functions, classes, method definitions, calls which are utilized in constructing the code graph and control flow tree. This data source is essential for understanding program structure before further processing.\n\n4. entire_code_graph: Refers to the overall result after invoking `code_graph()` within `get_code_graph()`. It's a combination of nodes and edges derived from parsed function/class method details forming relationships between entities in code which aid developers in visualizing call hierarchy in software systems.\n\n5. file_ast: Indicates Abstract Syntax Tree object acting as input argument to extract_control_flow_tree(). This tree-like data structure enables analyzing Python program syntax allowing `get_code_graph()` to decipher logic sequences accurately while restructuring the control flow for visual representation via PlantUML. This helps understand software functioning at a deeper level.\n\n6. control_flow_structure: Outcomes from `reorganize_control_flow()`, where starting points are fetched from entire_code_graph and recursively sorted to match graph relationships. It becomes an organized version of the initial control flow tree that better aligns with the actual code structure for better understanding through PlantUML diagrams. This structured format facilitates comprehension by developers when examining software logic patterns."
    },
    {
        "instruction": "Returns from `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'(entire_code_graph', 'control_flow_structure', 'plantUML)'\n\nPurpose and Significance:\nIn the context of 'get_code_graph' function within the given Python script 'get_code_graph.py', the returned tuple ['entire_code_graph', 'control_flow_structure', 'plantUML'] holds crucial outputs that represent different aspects of code analysis and visualization for better understanding of a source file's organization, flow, and relationships between functions or methods in an encoded manner.\n\n1) 'entire_code_graph': This variable is the core result encompassing generated code graph extracted from supplied file details contained in 'file_summary'. It signifies a dictionary with nodes (functions or classes) along with their respective edges illustrating interdependencies within the program's logic flow. EntireCodeGraph denotes nodes representing methods, functions as well as connections between them, containing additional edge data to show inputs and outputs involved in calls or returns between entities.\n\n2) 'control_flow_structure': This output reflects the extracted control flow tree from Abstract Syntax Tree (AST) traversal. It is a list of elements derived from parsing Python code logic into a hierarchical structure comprising keywords like 'def', 'if', 'while', 'try-catch' blocks, etc., which helps in understanding program execution order and decision making paths. This structured representation assists developers to visualize the flow of control within the source file more comprehensively.\n\n3) 'plantUML': As the final element in the returned tuple from get_code_graph(), 'plantUML' encapsulates a string containing PlantUML activity diagram code generated from the reorganized control flow structure ('control_flow_structure'). This textual representation is utilized for visualization purposes, enabling developers to create graphical representations of program behavior using PlantUML tools. It helps in comprehending complex logic flows more intuitively by presenting a visual layout of functions, methods calls, conditional statements, loops, exceptions handling, etc., making code debugging and optimization easier."
    },
    {
        "instruction": "Inputs to `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'target_details', 'source_details', 'target'\n\nPurpose and Significance:\nIn the context of 'get_edge_data_from_details' function within the 'get_code_graph.py', variables '_target_details', '_source_details', and '_target' serve crucial purposes that contribute towards enriching edges in the created directed graph with necessary information while building code relationships. These inputs help to retrieve data required for associating relevant details to nodes connecting in the network structure.\n\n1) 'target_details': This parameter represents the details of a target node in the NetworkX DiGraph (generated by code_graph function), either extracted from function or class method definitions stored in '_class_method_details_lookup' dictionary for classes or '_function_details_lookup' dictionary for functions. It contains crucial information such as inputs and returns needed to annotate edges with pertinent data related to their respective targets during graph formation.\n\n2) 'source_details': Correspondingly, '_source_details' holds the details of a source node in the directed graph, obtained from '_function_details_lookup' dictionary for functions or '_class_method_details_lookup' dictionary for class methods. It is used to extract call inputs information related to edges originating from these nodes during edge data creation.\n\n3) '_target': Primarily acts as a reference to the current target node being processed in 'get_edge_data_from_details'. Its significance lies in providing a clear understanding of which specific node's relationship needs enhancement with edge details, sourced from either '_function_defs', '_class_defs', or combined results from both dictionaries when building the directed graph. In brief, this parameter refers to a specific target for better attributing appropriate edge information retrieved via associated lookup dictionary data pairings of 'source' and 'target'."
    },
    {
        "instruction": "Calls made in `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'target_details.get', 'list', 'set'\n\nPurpose and Significance:\nIn `get_edge_data_from_details` function within the 'get_code_graph.py' module, three built-in Python operations ('target_details.get', 'list', and 'set') play significant roles to fetch necessary information for creating edges with associated data in the generated code graph. These elements are utilized as follows:\n\n1. `target_details.get`: This call retrieves details related to the target node from either function or class method lookup dictionaries (function_details_lookup and class_method_details_lookup) during edge formation. It helps populate essential information like inputs, returns, which will later be included in edges' data as metadata when creating the NetworkX DiGraph object.\n\n2. 'list': It represents Python's fundamental data type utilized in several scenarios within the code graph creation process but particularly important in `extract_control_flow_tree()` function for collecting nested structures such as elements under each control flow key encountered during AST traversal. Here, it collectively stores extracted strings or dictionaries representing different nodes/blocks of the code logic (e.g., 'if', 'while', 'try-catch' blocks).\n\n3. 'set': This data structure is employed in `reorganize_control_flow()` function to maintain a track of already processed elements in the control flow restructuring process. It helps identify starting points from the code graph (nodes not targeted by any edge) and prevent duplication while traversing the organized control flow structure recursively. This ensures unique elements are considered only once during the reorganization phase, ensuring efficient execution."
    },
    {
        "instruction": "Variables in `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'target_details', 'source_details', 'target', 'edge_data'\n\nPurpose and Significance:\nIn the context of function `get_edge_data_from_details` within the 'get_code_graph.py', variables ['target_details', 'source_details', 'target', and 'edge_data'] play crucial roles to gather essential information for constructing edges in the code graph with relevant data attached. These variables serve as follows:\n\n1. `target_details`: This variable holds details of the target node (function or class method) being connected by an edge in the graph. It helps retrieve specific attributes like inputs and returns required to create edge data for better understanding of dependencies between nodes during graph formation.\n\n2. `source_details`: Represents details of the source node connecting to the target node through an edge. It assists in extracting call input information from the source function or class method that invokes the target element, thus contributing to accurate edge data creation.\n\n3. `target`: Identifies the current node being connected by an edge in the graph. This variable helps determine the specific node where edge attributes need to be added based on its relationship with the source node.\n\n4. `edge_data`: An empty dictionary initially, it gets updated with relevant information from 'target_details' and 'source_details', along with target inputs collected when applicable. Finally, this variable contains complete data for each edge in the graph, which includes target inputs and returns of connected nodes as well as source call inputs when available. It is returned alongside source and target nodes to create edges with associated attributes in NetworkX DiGraph object 'G'."
    },
    {
        "instruction": "Returns from `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'edge_data'\n\nPurpose and Significance:\n1) Edge Data Object Purpose and Significance in get_code_graph.py:\n   The 'edge_data' object, returned by `get_edge_data_from_details()`, contains important attributes assigned during network connections discovery in a directed graph depicting the software code structure within functions or classes relationships. As Python moves through edges of Node relationships creation stage (using 'code_graph()'), this function extracts crucial information from target and source nodes' details, which are later attached to each edge as metadata. These attributes include input arguments ('target_inputs') and return values ('target_returns') for further analysis or visualization purposes. In essence, `get_edge_data_from_details()` collects necessary data required to annotate edges with functional aspects, enriching the graph representation with valuable contextual information about function calls and method invocations."
    },
    {
        "instruction": "Inputs to `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'control_flow_structure'\n\nPurpose and Significance:\nControl Flow Structure in the given context primarily functions as crucial data to generate PlantUML diagram code for visual representation purposes within `get_plantUML`. After undergoing thorough analyses over a provided source file summary and Abstract Syntax Tree (AST), this structure is reorganized according to the generated code graph using `reorganize_control_flow()` function. The resulting control flow tree serves as an intermediate step in producing PlantUML activity diagrams that illustrate the program's logic flow more comprehensively. In `get_plantUML`, it acts as a central input holding rearranged elements from diverse code constructs such as 'def', 'if', 'while', 'try-catch' blocks, etc., ensuring readability in terms of their hierarchy and sequential execution order within the application workflow.\n\nEach element present in this structure holds one portion of control flow logic, where keys may indicate Python keywords representing control statements ('def', 'if', 'for', 'while', 'try') while values correspond to subordinate details nested within the same level in a dictionary format or standalone strings like method calls/return values. When fed into `get_plantUML`, it traverses each element and converts them into PlantUML formatted codes using `get_plantUML_element()` with proper indentation levels, ultimately generating an overall PlantUML string representation for the entire file's control flow. This visualization aids developers in understanding complex code structures more efficiently by providing a graphical layout of program execution paths and decision points."
    },
    {
        "instruction": "Docstring of `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file"
    },
    {
        "instruction": "Calls made in `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'get_plantUML_element'\n\nPurpose and Significance:\n1) Purpose of 'get_plantUML_element': This function serves as a crucial component within the 'get_plantUML' method to generate PlantUML activity diagram code for each individual element extracted from the control flow structure. It takes two arguments - an element and indentation level ('indentation') which helps in formatting the PlantUML representation of code elements neatly. Its primary role is to convert each element into a corresponding PlantUML code string. By traversing nested dictionary-style key-value pairs in 'control_flow_structure' data format (which might consist of methods, statements or blocks such as if, try, while), it indents relevant content for clarity during visualization through the generated activity diagram. The method adds required colon symbols followed by element contents on each newline while increasing indentation for subelements nested deeper within code blocks ('def', 'class', 'if', 'for', 'while', 'try', and 'except'). If an element is a string (i.e., simple statements), it adds a colon followed by the statement without any indentation increase.\n\n2) Calls made in `get_plantUML` using 'get_plantUML_element': To generate PlantUML code for the entire file, 'get_plantUML' invokes 'get_plantUML_element' repeatedly for every element present in the reorganized control flow structure ('control_flow_structure'). It iterates through each element and calls 'get_plantUML_element', passing an increased indentation level ('indentation = \"  ') as a parameter. This ensures proper visual hierarchy is maintained within PlantUML representation for distinct blocks like functions, classes, conditions (if/else), loops (for, while) or exception handling (try-catch). With multiple levels of 'get_plantUML_element' invocations covering entire flow logic results in combined activity diagrams captured within string ('@startuml\\n' initiating & '@enduml' concluding PlantUML code). These calls ensure the final PlantUML representation is comprehensive and readable for visual analysis of the source code's control flow."
    },
    {
        "instruction": "Variables in `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'plantuml_str', 'control_flow_structure'\n\nPurpose and Significance:\n1) Purpose & Significance of Variables in get_plantUML:\n   a. `plantuml_str`: In `get_plantUML`, this string variable holds the consolidated PlantUML activity diagram code generated from the reorganized control flow structure obtained after parsing the Python source code's Abstract Syntax Tree (AST). It serves as the final output representing visualization information for program analysis or comprehension, utilizing plantuml markdown for users to review how methods relate.\n\n   b. `control_flow_structure`: Essential in generating 'plantuml_str', it stores the reorganized control flow structure extracted from the AST nodes through recursive traversal by `reorganize_control_flow()`. This variable maintains the reformatted hierarchy to align with code graph connections and ensure accurate PlantUML diagram representation reflecting program logic accurately. By arranging elements based on code dependencies, `control_flow_structure` facilitates precise PlantUML generation through `get_plantUML()`."
    },
    {
        "instruction": "Returns from `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'plantuml_str'\n\nPurpose and Significance:\nIn the context of 'get_plantUML' function within the 'get_code_graph.py', the returned variable named 'plantuml_str' holds significant value as it represents the culminating outcome generated by combining PlantUML activity diagram codes for all extracted elements in the control flow structure obtained from Python source code analysis. This output is vital as developers use PlantUML (PlantUML) for visualization purposes to represent complex algorithmic processes clearly, helping comprehend intricate relationships and logical sequences better than mere textual code representation alone can achieve. Each generated 'plantuml_str' provides an easy-to-read diagram representing program behavior while providing insights into functions, loops, conditionals, exceptions handling, and other control flow structures identified in the analyzed source file. The primary tasks executed to produce this output involve iterating through reorganized control flow elements extracted from the codebase and applying `get_plantUML_element` for PlantUML code generation at varying indentation levels according to the element type encountered during traversal. After producing codes for individual components, finally forming one cumulative activity diagram in `@startuml\\n`, end` statements along with content extracted acts as graphical description reflecting various branches or routes inside software under development to augment documentation accuracy for non-developers or better code maintenance by teammates. Hence, 'plantuml_str' plays a pivotal role in converting complex source code into comprehensible visual notations, thus simplifying the understanding of program logic."
    },
    {
        "instruction": "Inputs to `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "'source', 'target', 'init_method'\n\nPurpose and Significance:\n'Purpose & Significance of Inputs in add_edge_with_data Function within get_code_graph.py:\n\n1) 'source': This parameter represents a node acting as an origin point for an edge connection in the generated directed graph during code analysis. It could be a function or class name related to the function or class method being inspected by `code_graph()`. The value assists `add_edge_with_data()` to recognize nodes involved in direct calls relationships while shaping connections in NetworkX DiGraph (nx.DiGraph).\n\n2) 'target': It signifies a node becoming connected via an edge derived from 'source' due to function/class method call operations detected within Python source code during `code_graph()`. Depending on the context, 'target' can be either a fully qualified method name or class name. This input helps establish relationships between nodes in the graph by adding edges with relevant data using `add_edge()` function from NetworkX library.\n\n3) 'init_method': An optional parameter introduced for clarity within `add_edge_with_data()`. When given, it denotes a constructor method (__init__) being invoked by the source node during class instantiation process. In such cases, 'target' can be differentiated to mark direct linkages originating from a constructor. Initially left unset in this parameter defaults to None until relevant class initializers are determined while constructing edge associations within NetworkX DiGraph.'"
    },
    {
        "instruction": "Calls made in `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "'class_method_details_lookup.get', 'function_details_lookup.get', 'G.add_edge', 'get_edge_data_from_details'\n\nPurpose and Significance:\n1) Purpose and Significance of Calls in `add_edge_with_data` Function within `code_graph()`:\n   This function plays a crucial role in connecting nodes (functions or class methods) in the generated graph according to their relationships within the code structure. The listed calls assist in constructing the edges and associated metadata. Below is the description for each:\n\n    a. 'class_method_details_lookup.get': This lookup accesses the method details related to the called object in case of class methods to assign metadata (such as input parameters and returned values) during edge creation. The stored data facilitates populating edges with meaningful information, representing how different components communicate in the code graph.\n\n    b. 'function_details_lookup.get': Similarly, this lookup accesses function details required for retrieving related information like input arguments passed to functions when building connections between them. These details contribute to creating precise edge attributes that represent actual relationships occurring at function calls level in code dependencies.\n\n    c. 'G.add_edge': The `networkx.DiGraph().add_edge()` call connects a node with specific properties set using provided details by prior lookup operations ('class_method_details_lookup' and 'function_details_lookup') to represent directed connections in the code graph accurately. It links the related components through edges and sets additional information required for later visualization or analysis purposes.\n\n    d. 'get_edge_data_from_details': This helper function fetches appropriate edge metadata depending upon input nodes' context ('source_details' & 'target_details') for better interpretation of method relationships during edge addition (node linkages) within the generated code graph representation.'"
    },
    {
        "instruction": "Variables in `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "'source', 'source_details', 'init_method', 'target', 'target_details'\n\nPurpose and Significance:\nIn the context of 'add_edge_with_data' function within the 'get_code_graph.py', the variables ['source', 'source_details', 'init_method', 'target', and 'target_details'] play crucial roles during the development of a directed graph representing relationships among functions and classes in a given codebase. Their purpose is to help create edges between nodes in the network while adding essential data to each edge formed.\n\n1. 'source': Represents the origin node or entity invoking another function/method call within the codebase. It serves as one endpoint of an edge in the graph construction process.\n2. 'source_details': Refers to the details associated with the source node, such as input arguments and return values from a function definition stored in the 'function_details_lookup' dictionary for functions or 'class_method_details_lookup' dictionary for class methods. This information is utilized to populate edge data related to incoming connections in the graph.\n3. 'init_method': A temporary variable used when dealing with class method calls originating from a constructor (__init__). If the target node matches a class method, this variable holds its fully qualified name ('class_name.method_name') for adding edges with appropriate data. It remains optional as it may not be required in all cases.\n4. 'target': Signifies the destination node receiving input arguments from a function/method invocation or node to which an edge will connect originating from 'source'. Depending on whether the target node corresponds to a class method ('fully_qualified_name') or function definition ('target'), relevant details are fetched from either 'function_details_lookup' or 'class_method_details_lookup' dictionaries for populating edge attributes.\n   In summary, these variables contribute to establishing connections between nodes in the code graph while incorporating essential metadata about their interactions within the codebase. They ensure accurate representation of function and class method relationships with associated data in the generated directed graph."
    }
]