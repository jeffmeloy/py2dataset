[
    {
        "instruction": "Dependencies in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element: dict, indentation=\"\") -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = \"\"\n\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if \"def\" in key or \"class\" in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif \"if\" in key or \"while\" in key or \"for\" in key:\n            condition = key.replace(\"if \", \"\").replace(\"while \", \"\").replace(\"for \", \"\")\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif \"try\" in key: # Mark the start of a try block\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif \"except\" in key: # Mark the start of an except block\n            exception_condition = key.replace(\"except \", \"\")\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f\"{indentation}: {key};\\n\"\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}: {element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "ast, json, networkx, typing\n\nPurpose and Significance:\nThe given Python script 'get_code_graph.py' depends on four key libraries or modules - ast, json, networkx, and typing - each playing a significant role in accomplishing its goal of generating detailed documentation related to Python source code files including structure analysis, control flow extraction, and visual representation using PlantUML activity diagrams.\n\n1. ast (Abstract Syntax Tree): This library is essential for parsing Python code into an abstract syntax tree data structure. It allows traversing through tokens sequentially in a program, helping to identify functions, classes, statements, expressions, etc., required to extract control flow and build graph connections between different parts of the codebase. In the script, ast is used primarily in 'extract_control_flow_tree' function where it processes nodes from AST for creating control flow trees.\n\n2. json: This standard Python library facilitates encoding Python objects into JavaScript Object Notation (JSON) format as strings and vice versa - JSON objects into native Python types. It comes in handy while generating unique identifiers for organizing structures ('json.dumps'), and forming formatted representations to handle nodes efficiently without causing clashes (used mostly across recursion calls inside 'get_plantUML_element', 'reorganize_control_flow', etc.).\n\n3. networkx: This package is a Python library providing various classes of graphs and graph algorithms for analysis, visualization, etc. In the context script, it serves as a backbone for creating directed graphs representing relationships between functions/methods in code ('nx.DiGraph()') within 'code_graph' function. It helps to represent nodes (functions, methods) and edges (function calls) along with their associated data ('G', 'edges', 'nodes').\n\n4. typing: This module is Python 3's type hinting system introduced in PEP 484, enabling better readability by documenting function parameter types, return values, variable assignments, etc. While it may not have explicit usage within this specific script example given here (due to limited functionality in Python versions prior to 3.5), typing would be beneficial for improved code clarity and static analysis tools integration if used with modern Python versions.\n"
    },
    {
        "instruction": "Call code graph in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element: dict, indentation=\"\") -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = \"\"\n\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if \"def\" in key or \"class\" in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif \"if\" in key or \"while\" in key or \"for\" in key:\n            condition = key.replace(\"if \", \"\").replace(\"while \", \"\").replace(\"for \", \"\")\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif \"try\" in key: # Mark the start of a try block\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif \"except\" in key: # Mark the start of an except block\n            exception_condition = key.replace(\"except \", \"\")\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f\"{indentation}: {key};\\n\"\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}: {element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "{'nodes': ['code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'extract_control_flow_tree', 'reorganize_control_flow', 'reorganize_structure', 'get_plantUML_element', 'get_plantUML', 'get_code_graph', 'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', \"class_details['method_defs'].items\", 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'function_details_lookup.items', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'type', 'control_flow_tree.append', 'ast.unparse', \"', '.join\", 'isinstance', 'except_block.append', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend', \"key.replace('if ', '').replace('while ', '').replace\", \"key.replace('if ', '').replace\", 'key.replace', 'str'], 'edges': [{'source': 'code_graph', 'target': 'nx.DiGraph', 'target_inputs': []}, {'source': 'code_graph', 'target': 'function_details_lookup.update', 'target_inputs': ['function_def']}, {'source': 'code_graph', 'target': 'class_def.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_node', 'target_inputs': ['class_name', 'qualified_method_name', 'called', 'function_name']}, {'source': 'code_graph', 'target': \"class_details['method_defs'].items\", 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_edge', 'target_inputs': ['class_name', 'qualified_method_name', 'source', 'target']}, {'source': 'code_graph', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'code_graph', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\", 'class_def.keys()', 'G.nodes']}, {'source': 'code_graph', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'code_graph', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target', 'target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'code_graph', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'code_graph', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'code_graph', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'code_graph', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'code_graph', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'code_graph', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'code_graph', 'target': 'function_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'add_edges_for_calls', 'target_inputs': ['func_name', \"details['calls']\", 'qualified_method_name', \"details['calls']\"], 'target_returns': []}, {'source': 'code_graph', 'target': 'class_method_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G[source][target].update', 'target_inputs': ['edge_data']}, {'source': 'code_graph', 'target': 'G.edges.data', 'target_inputs': []}, {'source': 'get_edge_data_from_details', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'get_edge_data_from_details', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\"]}, {'source': 'get_edge_data_from_details', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'add_edge_with_data', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source']}, {'source': 'add_edge_with_data', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source']}, {'source': 'add_edge_with_data', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'add_edge_with_data', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'add_edges_for_calls', 'target': 'list', 'target_inputs': ['class_def.keys()']}, {'source': 'add_edges_for_calls', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'add_edges_for_calls', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'add_edges_for_calls', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'add_edges_for_calls', 'target': 'G.add_node', 'target_inputs': ['called']}, {'source': 'extract_control_flow_tree', 'target': 'type', 'target_inputs': ['node']}, {'source': 'extract_control_flow_tree', 'target': 'control_flow_tree.append', 'target_inputs': ['ast.unparse(node)', '{key: value}', '{key: value}', '{key: value}', '{key: value}', '{key: value}', '{key: value}', 'if_block', 'control_flow_dict', 'ast.unparse(node)']}, {'source': 'extract_control_flow_tree', 'target': 'ast.unparse', 'target_inputs': ['node', 'arg', 'node.test', 'node.target', 'node.iter', 'item', 'node.value', 'node.test', 'orelse[0].test', 'handler.type', 'handler.name', 'node']}, {'source': 'extract_control_flow_tree', 'target': \"', '.join\", 'target_inputs': ['[ast.unparse(arg) for arg in node.args.args]', '[ast.unparse(item) for item in node.items]']}, {'source': 'extract_control_flow_tree', 'target': 'extract_control_flow_tree', 'target_inputs': ['node.body', 'node.body', 'node.body', 'node.body', 'node.body', 'node.body', 'orelse[0].body', 'orelse', 'node.body', 'handler.body', 'node.orelse', 'node.finalbody'], 'target_returns': ['control_flow_tree']}, {'source': 'extract_control_flow_tree', 'target': 'isinstance', 'target_inputs': ['orelse[0]', 'ast.If', 'handler.name', 'ast.Name']}, {'source': 'extract_control_flow_tree', 'target': 'except_block.append', 'target_inputs': ['{key: value}']}, {'source': 'reorganize_control_flow', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_control_flow', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_control_flow', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_control_flow', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_control_flow', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_control_flow', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_control_flow', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_control_flow', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'reorganize_control_flow', 'target': 'reorganize_structure', 'target_inputs': ['control_flow_structure', 'starting_points'], 'target_returns': ['organized']}, {'source': 'reorganize_structure', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_structure', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_structure', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_structure', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_structure', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_structure', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_structure', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_structure', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'get_plantUML_element', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'get_plantUML_element', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'get_plantUML_element', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'get_plantUML_element', 'target': 'get_plantUML_element', 'target_inputs': ['item', 'inner_indentation', 'item', 'inner_indentation', 'item', 'inner_indentation', 'item', 'inner_indentation'], 'target_returns': ['plantuml_str']}, {'source': 'get_plantUML_element', 'target': \"key.replace('if ', '').replace('while ', '').replace\", 'target_inputs': [\"'for '\", \"''\"]}, {'source': 'get_plantUML_element', 'target': \"key.replace('if ', '').replace\", 'target_inputs': [\"'while '\", \"''\"]}, {'source': 'get_plantUML_element', 'target': 'key.replace', 'target_inputs': [\"'if '\", \"''\", \"'except '\", \"''\"]}, {'source': 'get_plantUML', 'target': 'get_plantUML_element', 'target_inputs': ['element', \"'  '\"], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'code_graph', 'target_inputs': ['file_summary'], 'target_returns': ['edge_data', \"{'nodes': nodes, 'edges': edges}\"]}, {'source': 'get_code_graph', 'target': 'extract_control_flow_tree', 'target_inputs': ['file_ast.body'], 'target_returns': ['control_flow_tree']}, {'source': 'get_code_graph', 'target': 'reorganize_control_flow', 'target_inputs': ['entire_code_graph', 'control_flow_tree'], 'target_returns': ['reorganize_structure(control_flow_structure, starting_points)', 'organized']}, {'source': 'get_code_graph', 'target': 'get_plantUML', 'target_inputs': ['control_flow_structure'], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'str', 'target_inputs': ['e', 'e']}]}"
    },
    {
        "instruction": "Functions in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element: dict, indentation=\"\") -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = \"\"\n\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if \"def\" in key or \"class\" in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif \"if\" in key or \"while\" in key or \"for\" in key:\n            condition = key.replace(\"if \", \"\").replace(\"while \", \"\").replace(\"for \", \"\")\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif \"try\" in key: # Mark the start of a try block\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif \"except\" in key: # Mark the start of an except block\n            exception_condition = key.replace(\"except \", \"\")\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f\"{indentation}: {key};\\n\"\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}: {element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "code_graph, get_edge_data_from_details, add_edge_with_data, add_edges_for_calls, extract_control_flow_tree, reorganize_control_flow, reorganize_structure, get_plantUML_element, get_plantUML, get_code_graph\n\nPurpose and Significance:\nThe given context consists of several key functions within 'py2dataset/get_code_graph.py' Python module that work collaboratively to analyze a Python source code file and generate detailed documentation related to its structure, control flow, and visual representation using PlantUML activity diagrams. These functions play significant roles in achieving this objective:\n\n1. 'code_graph': This function constructs a dictionary representing nodes (functions/classes) and edges (function calls) present in the codebase extracted from file summaries. It uses NetworkX package's DiGraph() to create a graph representation of relationships among functions, classes, and methods in Python files.\n\n2. 'get_edge_data_from_details': A helper function extracting edge data from target details (function return values) and source details (function call inputs). It returns a dictionary containing 'target_inputs' and 'target_returns', which are crucial for understanding the flow control within edges in the code graph.\n\n3. 'add_edge_with_data': This function adds edges to the code graph along with associated data based on node type classification. It considers functions, class methods, try/except blocks while respecting proper fully-qualified method names during program iterations and handling exceptional conditions if required.\n\n4. 'add_edges_for_calls': Identifies connections in source functions to targeted call functions from class/instance details while maintaining correct fully-qualified method names during file execution processes like iteration through classes or exception handling if applicable.\n\n5. 'extract_control_flow_tree': This function parses Abstract Syntax Tree (AST) nodes into a control flow tree representation of Python source code statements and conditional logic. It traverses the AST node by node for accurate mapping purposes.\n\n6. 'reorganize_control_flow': Modifies extracted control flow structures according to the graph obtained from 'code_graph', ensuring starting points match the code graph's nodes. This function operates recursively until all control flow parts are accounted for in an organized manner.\n\n7. 'get_plantUML_element': Prepares PlantUML representation elements individually for each element within the control flow structure with clear hints for try/except blocks. It generates plantUML code snippets helping in creating a visual depiction of Python program logic flows.\n\n8. 'get_plantUML': Assembles the complete file activity diagram's PlantUML code string using elements extracted from method calls made earlier. It combines all PlantUML code snippets created for individual elements with '@startuml' and '@enduml' markers as standard PlantUML syntax requirements.\n\n9. 'get_code_graph': Combines code graph creation, control flow extraction, and PlantUML generation into one cohesive process by calling all previously mentioned functions while handling exceptions during execution. It returns the entire code graph, reorganized control flow structure, and final PlantUML diagram code for comprehensive Python file analysis.\nEach of these functionalities are strategically tailored towards mapping interrelated data across classes/methods (data extraction & connecting functions/method calls) within files leading up to preparing visual representations through PlantUML activity diagrams for better understanding of Python program's structure and flow logic.\n"
    },
    {
        "instruction": "I) Describe the Purpose and Processing Approach for Python file: `py2dataset\\get_code_graph.py`; II) Define detailed Requirements, API Signatures, and Logic for all Functions and Class Methods; III) Explain the purpose of the inputs, variables, call, and returns in the code.",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element: dict, indentation=\"\") -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = \"\"\n\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if \"def\" in key or \"class\" in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif \"if\" in key or \"while\" in key or \"for\" in key:\n            condition = key.replace(\"if \", \"\").replace(\"while \", \"\").replace(\"for \", \"\")\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif \"try\" in key: # Mark the start of a try block\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif \"except\" in key: # Mark the start of an except block\n            exception_condition = key.replace(\"except \", \"\")\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + \"    \"\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f\"{indentation}: {key};\\n\"\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}: {element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "I) The purpose of 'py2dataset\\get_code_graph.py' is to analyze Python source code files and generate detailed documentation related to its structure, control flow, and visual representation using PlantUML activity diagrams. It primarily employs parsing through various elements from abstract syntax tree (AST) produced by python-mode analyzing token sequences obtained as output. Several distinct yet complementary functionalities serve separate yet intricate processes which interact for fulfilling overall task. Below given breakup sheds light on every component in this module:\n\n1. 'code_graph': It builds a dictionary representing nodes and edges for relationships found in Python file summaries with the aid of networkx package's DiGraph(). Nodes stand for function names, class method details, and classes themselves. Edges are formed based on calls between functions or methods within the codebase. Edge data holds input/output information for better understanding of flow control.\n\n2. 'get_edge_data_from_details': This helper function extracts edge data from target details (function return values) and source details (function call inputs). It returns a dictionary with 'target_inputs' and 'target_returns'.\n\n3. 'add_edge_with_data': Adding edges to the code graph along with associated data based on node type classification, utilizing 'get_edge_data_from_details'. It considers functions, class methods, and special control structures like try/except blocks for detailed representation.\n\n4. 'add_edges_for_calls': Determining the connections in source functions to targeted call functions from class/instance details while respecting proper fully-qualified method names during execution of program operations like file iterations & handling exceptional conditions if applicable.\n\n5. 'extract_control_flow_tree': Creates control flow trees (Python abstracted statements and conditional logic), segregated for try blocks including its sub-clauses along with handling classes/definitions in Python source code as nodes or leaf strings representing distinct activities. This traverses the AST node-by-node for proper parsing & mapping purposes.\n\n6. 'reorganize_control_flow': Modifies extracted control flow structures according to the graph obtained from 'code_graph' function, ensuring starting points match the code graph's nodes. It recursively processes elements until all control flow parts are accounted for in an organized manner.\n\n7. 'get_plantUML_element': Generates PlantUML code snippets for each element within the control flow structure with clear hints for try/except blocks, providing visual representation of Python program's logic flow.\n\n8. 'get_plantUML': Gathers all generated PlantUML elements from previous steps into a single string representing entire file activity diagram using '@startuml' and '@enduml' markers as standard PlantUML syntax requirements.\n\n9. 'get_code_graph': Combines code graph generation, control flow extraction, and PlantUML creation into one cohesive process by calling all previously mentioned functions. It handles exceptions during execution and returns the entire code graph, reorganized control flow structure, and final PlantUML diagram code.\n\nII) Requirements Summary:\n[req01] 'code_graph': Constructs file details dictionary with nodes (functions/classes) & edges (function calls).\n[req02] 'extract_control_flow_tree': Parses AST to create control flow tree representation.\n[req03] 'reorganize_control_flow': Adjusts control flow structure as per code graph's starting points for organized understanding.\n[req04] 'get_plantUML_element': Prepares plantUML representation elements individually (elements include method def, control logic and blocks).\n[req05] 'get_plantUML': Constructs comprehensive plantUML diagram code from extracted elements.\n[req06] 'get_code_graph': Integrates code graph, control flow structure & PlantUML generation for entire file analysis.\n\nAPI Signatures:\ncode_graph(file_summary): Returns a dictionary with nodes and edges representing relationships in the code.\nget_edge_data_from_details(target_details, source_details, target): Returns edge data from details of target and source elements.\nadd_edge_with_data(source, target[, init_method]): Adds an edge with data to the graph.\nadd_edges_for_calls(source_name, calls): Handles edges for function/class method calls.\nextract_control_flow_tree(nodes): Extracts control flow tree from input list of nodes extracted using AST parsing.\nreorganize_structure(structure, start_points): Organizes structured data as per given start points (mostly recursive).\nget_plantUML_element(element, indentation): Creates plantUML code for each element with clear hints for try/except blocks.\nget_plantUML(control_flow_structure): Compiles whole file activity diagram's plantUML code string using collected elements from all methods calls before.\nget_code_graph(file_summary, file_ast): Combines code graph creation, control flow extraction & PlantUML generation for entire Python file analysis while handling exceptions.\n\nIII) Inputs and Variables Description:\nDepending on context:\ncode_graph -> 'file_summary' consists of details from analyzed tokens with node separation like function definitions/calls & class structures (dictionaries), AST tree is absent here but utilized by 'extract_control_flow_tree'. It uses 'nx.DiGraph()', 'function_details_lookup', 'class_method_details_lookup', 'edges', 'nodes', 'G' as graph object, etc.\nget_edge_data_from_details -> 'target_details', 'source_details', 'target' are parsed data from function/class method details lookup dictionaries; 'edge_data' holds extracted information for edge properties.\nadd_edge_with_data -> 'source', 'target', 'init_method' represents node identities; classifications aid in connecting related functions or methods ('class_names', 'method_name', etc.).\nadd_edges_for_calls -> 'source_name', 'calls' contain function/class method names and their respective calls.\nextract_control_flow_tree -> 'nodes' are AST nodes for parsing control flow tree generation.\nreorganize_control_flow -> 'code_graph', 'control_flow_structure' is organized output after graph & flow processing, 'starting_points', 'seen', 'element_id' help in recursive structuring.\nreorganize_structure -> 'structure', 'start_points' are control flow elements to be rearranged as per starting points.\nget_plantUML_element -> 'element', 'indentation' denotes current level of indentation for plantUML code generation; 'key', 'value', 'condition', 'exception_condition', etc., are used during processing.\nget_plantUML -> 'control_flow_structure' is parsed control flow tree data, 'plantuml_str' accumulates final PlantUML diagram code string.\nget_code_graph -> 'file_summary', 'file_ast' represents Python file details & AST respectively; 'entire_code_graph', 'control_flow_structure', 'plantUML' are results of combined processing steps while handling exceptions ('Exception as e')."
    },
    {
        "instruction": "Inputs to `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "file_summary\n\nPurpose and Significance:\nIn the context given for 'get_code_graph.py', the input parameter 'file_summary' plays a crucial role within the 'code_graph' function specifically. This variable holds extracted details from analyzed tokens in a Python source code file. It contains comprehensive information about function definitions, class definitions along with their respective method details which are required to construct the code graph representation.\n\nThe 'file_summary' dictionary comprises keys such as \"function_defs\" for capturing individual function declarations and \"class_defs\" that stores data related to classes in the source code. These details further break down into nested dictionaries containing information about method definitions, calls, inputs, returns, etc., enabling 'code_graph' to create a structured network representing relationships between functions and classes present within the Python file.\n\nIn essence, 'file_summary' serves as an essential input that feeds necessary data for building nodes (functions/classes) and edges (function calls) in the code graph which is central to understanding program flow and structure. Without this input, constructing a meaningful representation of the Python file would be impossible within the 'code_graph' function.\n"
    },
    {
        "instruction": "Docstring of `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code."
    },
    {
        "instruction": "Calls made in `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "nx.DiGraph, function_details_lookup.update, class_def.items, G.add_node, class_details['method_defs'].items, G.add_edge, target_details.get, list, set, class_method_details_lookup.get, function_details_lookup.get, get_edge_data_from_details, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, function_details_lookup.items, add_edges_for_calls, class_method_details_lookup.items, G[source][target].update, G.edges.data\n\nPurpose and Significance:\nIn the context of 'code_graph' function within get_code_graphics.py, different method calls play vital roles contributing to the generation of a graph representation containing nodes (functions/classes) and edges (function calls) representing relationships in Python codebase details extracted from file summary. Let us understand each call's purpose individually:\n\n1. `nx.DiGraph()`: This imports NetworkX's DiGraph class which is used to create a directed graph data structure for storing nodes (functions/classes) and edges (function calls).\n\n2. `function_details_lookup.update()` & `class_method_details_lookup.update()`: These updates dictionary variables with extracted function or method details respectively during initial code execution phase before processing graphs or edges further in the algorithm. It collects details necessary to populate graph nodes accurately later.\n\n3. `class_def.items()`: Iterates over class definitions from file summary and returns a list of tuples containing (key, value) pairs where key is class name and value contains method details dictionary for each class definition. This helps in adding classes as nodes to the graph later on.\n\n4. `G.add_node(source)` & `G.add_edge(source, target)`: These calls add nodes (classes/functions) to the graph object 'G'. The former adds a single node while the latter creates an edge between two nodes representing function/class calls within Python code structure.\n\n5. `target_details = target_details.get(\"returns\")`, `target_details = function_details_lookup.get(target)` or `source_details = function_details_lookup.get(source)`: These fetch details related to target and source nodes respectively from lookup dictionaries created earlier. They help in extracting edge data required for the graph edges.\n\n6. `add_edge_with_data(source, target)`: This creates an edge with associated data between two nodes based on their relationship (function calls). It uses helper functions 'get_edge_data_from_details' and 'add_edge_with_data'.\n\n7. `target_details = class_method_details_lookup.get(init_method)`: Retrieves method details if called node is an initializer method of a class to add edges correctly in case of class initialization calls.\n\n8. `add_edges_for_calls(source_name, calls)`: This function iterates through call lists for functions/classes found in the file summary and establishes graph connections by creating edges representing actual call instances among functions or methods based on lookup dictionaries populated beforehand.\n\n9. `class_names = [list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]`: Extracts class names directly from summary file_defs by extracting first item ('class' keyword) present inside 'class_def'. Used in deciding which function should act as target edge initializers while processing method calls.\n\n10. `source_name.split('.')[0]` & `called_class_name = called.split(\".\")[0]`: These split string tokens at dots to isolate class names without methods in cases of function and class method calls respectively. It helps to handle nested structures properly within graph edges.\n\n11. `G[source][target].update(edge_data)` & `G.edges.data()`: The former updates edge data using 'get_edge_data_from_details' results while creating edges between nodes with required properties, and the latter returns an iterator over all edges in graph 'G', useful for later use when constructing entire code graph representation.\n\nOverall, these calls work together to create a comprehensive directed graph representing Python file relationships through nodes (functions/classes) and edges (function calls), allowing users to understand code flow patterns better visually with PlantUML representations.\n"
    },
    {
        "instruction": "Variables in `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "init_method, G, fully_qualified_name, qualified_method_name, file_summary, function_details_lookup, edges, nodes, edge_data, target_details, source_details, class_names, method_name, called_class_name, class_method_details_lookup, init_method_name\n\nPurpose and Significance:\nIn the context of 'code_graph' function within 'get_code_graph.py', several variables play crucial roles to create a dictionary representation of file details focusing on relationships between functions and classes. Let us understand their purpose one by one:\n\n1. init_method: This variable is utilized when creating edges for method calls from an object like \"class\". Its presence makes building fully-qualified names (fully_qualified_name) simpler if necessary within 'add_edge_with_data'. By storing class constructor \"__init__\", init_method provides reference during the construction of these edge connections.\n\n2. G: This symbol denotes an instance of NetworkX's DiGraph() class that represents the directed graph constructed by 'code_graph'. It holds nodes and edges depicting function/class relationships within Python codebase, with properties like adding nodes for classes, methods, creating edges between them based on calls, etc.\n\n3. fully_qualified_name: Combines class name and method name to create a unique identifier when dealing with method calls from objects. It helps in maintaining proper references while building edges within the graph structure.\n\n4. file_summary: This variable contains extracted details from analyzed tokens of Python files, including function definitions/calls and class structures stored as dictionaries. It serves as input data for 'code_graph' to create nodes and edges representing relationships between functions and classes.\n\n5. function_details_lookup and class_method_details_lookup: Both serve as mappings which keep the collected function & method details, respectably obtained from file_summary. These dictionaries enable efficient lookup for data associated with each node while building graph connections during 'code_graph'.\n\n6. edges and nodes: Returned results in dictionary format containing edges (with source/target nodes and their respective edge data) and list of nodes present in the code graph. They represent relationships between functions/classes as well as nodes forming the graph structure.\n\n7. edge_data: This temporary dictionary holds target inputs and returns extracted from 'get_edge_data_from_details' function, which helps in creating proper properties for each connection edge.\n\n8. target_details & source_details: During adding edges ('add_edge_with_data'), these variables represent method details extracted from 'function_details_lookup' and 'class_method_details_lookup'. They aid in gathering information like input parameters or returns about targeted/source functions while building edge data.\n\n9. class_names: This list holds names of classes found within file_summary['class_defs']. It assists in identifying called_class_name during handling class method calls ('add_edges_for_calls').\n\n10. method_name & called_class_name: While building edges between nodes, these variables help in creating proper references to maintain code structure accuracy within the graph. 'method_name' stores method name for a particular call, whereas 'called_class_name' refers to the class containing that method.\n\nIn summary, each variable mentioned above plays a significant role in constructing a comprehensive graph representation of Python file details by connecting functions and classes based on their relationships within code execution flow. They help create nodes, edges with relevant data, maintain proper references, and ensure accurate mapping between different elements for better understanding of the codebase structure.\n"
    },
    {
        "instruction": "Returns from `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "{'nodes': nodes, 'edges': edges}, edge_data\n\nPurpose and Significance:\nIn the context given for 'code_graph' function within 'py2dataset/get_code_graph.py', its primary purpose is to create a detailed dictionary representation of file details focusing on nodes and edges representing relationships in the Python codebase. This function returns two significant components:\n\n1. {'nodes': nodes, 'edges': edges}: This return value contains crucial information about the graph structure extracted from the analyzed Python file. The 'nodes' key holds all distinct functions and class methods present as vertices in the graph while 'edges' represents connections between these nodes based on function calls or method invocations within the codebase. These relationships are essential to understand how different parts of a program interact with each other during execution.\n\n2. edge_data: Although not directly returned by the code_graph function itself, it is relevant since this data serves an important purpose within internal implementations of other helper functions such as get_edge_data_from_details() and add_edge_with_data(). Edge data provides additional information about target inputs and returns associated with each edge in the graph. This data helps in understanding the flow of input parameters into a function or method call, along with outputs produced by them - which enhances comprehension when visualizing code dependencies and relationships.\n"
    },
    {
        "instruction": "Inputs to `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "nodes\n\nPurpose and Significance:\nIn the context given for 'get_code_graph.py', the function 'extract_control_flow_tree' plays a crucial role in extracting and structuring the control flow tree from Abstract Syntax Tree (AST) nodes obtained during Python source code analysis. The primary input to this function is ['nodes'], which represents a list containing AST nodes derived while traversing through the parsed Python file. These nodes carry significant information related to statements, control structures such as functions ('def' or 'AsyncFunctionDef'), classes ('ClassDef'), loops ('while', 'For', 'AsyncFor') and exceptions handling ('Try', 'If'). Each node contains vital program instructions like expressions or assignments necessary for the generation of a meaningful flow diagram representing logical decisions in Python programs. Within this function, other internal procedures dissect these nodes further to construct an organized hierarchical control flow tree comprising key-value pairs, strings and subordinate nested elements accordingly.\n'nodes' thus serve as essential input elements helping 'extract_control_flow_tree' effectively comprehend and translate complex program flows into manageable structural form before preparing the final visual PlantUML diagram through other connected processes.\n"
    },
    {
        "instruction": "Docstring of `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree"
    },
    {
        "instruction": "Calls made in `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "type, control_flow_tree.append, ast.unparse, .join, extract_control_flow_tree, isinstance, except_block.append\n\nPurpose and Significance:\nIn the context of 'extract_control_flow_tree' function within 'get_code_graph.py', these calls serve crucial purposes to extract and structure control flow trees from Python abstract syntax tree (AST) nodes:\n\n1. `type` is used for identifying node types in AST as part of a conditional check within loops or if statements to determine the corresponding key for forming control flow elements in the dictionary format. It helps distinguish between different programming constructs like function definitions, classes, loops, exceptions, etc., which further assists in generating meaningful PlantUML diagrams later on.\n\n2. `control_flow_tree.append` adds each parsed element into a list representing the control flow structure. This could be either a dictionary containing nested control structures or plain strings denoting simple statements like function definitions or class declarations. As the extraction progresses, this list grows to form the complete control flow tree for the given Python file.\n\n3. `ast.unparse` converts abstract syntax tree nodes into human-readable Python code snippets suitable for better understanding while analyzing AST nodes during parsing operations. This call assists in extracting meaningful information from complex data structures present within AST format.\n\n4. `.join` is utilized when concatenating strings related to function arguments list in case of function definitions ('def' or 'AsyncFunctionDef'). It combines argument names separated by commas into a single string representation for clear visualization in PlantUML diagrams.\n\n5. `extract_control_flow_tree` itself is not exactly a call but represents the primary recursive function in charge of parsing through AST nodes to construct control flow structures as discussed earlier. It iterates over each node in 'nodes' argument list and calls various other functions accordingly based on encountered keywords indicating specific Python language constructs (if conditions, loops, try blocks etc.).\n\n6. `isinstance` checks the type of parsed elements from AST nodes to decide how they should be treated further during control flow extraction - whether it's a dictionary denoting deeper control subtrees (in case of \"try\" blocks for exception handling, conditionals) or string for regular code segments representing a leaf statement execution node within this activity diagram graph hierarchy.\n\n7. Lastly, `except_block.append` appends extracted exception block details into an accumulator list if encountered during parsing loops responsible for extracting 'try', 'except' pairs in Python code. These blocks are marked separately as partitioned sections in PlantUML diagrams to highlight exceptional handling mechanisms within the program flowchart.\n"
    },
    {
        "instruction": "Variables in `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "keyword, node_keywords_map, h_type, node_type, key, try_block, else_block, control_flow_tree, value, nodes, args_str, h_name, control_flow_dict, if_block, finally_block, orelse, except_block\n\nPurpose and Significance:\nIn the 'extract_control_flow_tree' function within 'py2dataset\\get_code_graph.py', various variables play crucial roles to parse and organize Python abstract syntax tree (AST) nodes into a control flow structure representation. Here is their purpose and significance:\n\n1. keyword & node_keywords_map: These variables assist in identifying distinct blocks/statements while traversing through AST nodes during the function execution. The 'keyword' variable captures the type of statement encountered, whereas 'node_keywords_map' is a dictionary mapping Python keyword identifiers to their respective string representations used for creating control flow elements later on.\n\n2. h_type & node_type: Both these variables store string representations related to exception handling blocks within AST nodes - specifically type hints for 'except' clauses ('h_type') and general node types ('node_type'). They help differentiate between various statements during parsing.\n\n3. key: This variable holds the current key identified when traversing dictionaries containing elements inside the nested AST structures such as functions or class definitions while processing them further.\n\n4. try_block & else_block: When processing a 'try' keyword found within nodes, 'try_block' variable saves associated parts from dictionary value recursively fetched data - mimicking the Python partition structure for \"try\" block representation in PlantUML format. Similarly, 'else_block' captures control flow elements under the else statement when present after a conditional construct (if/while/for).\n\n5. control_flow_tree: It starts as an empty list that gradually builds up with control flow elements parsed from AST nodes into a hierarchical structure representing Python program logic flow. This variable serves as the output container for extracted control flow information.\n\n6. value: As the function iterates through each node in 'control_flow_tree', this variable stores the dictionary value corresponding to the current key encountered during traversal. It can be either another nested dictionary (for function/class definitions) or a string statement itself (in case of simple nodes).\n\n7. nodes: This global list contains AST nodes fed into the 'extract_control_flow_tree' function for parsing purposes - representing Python abstract syntax tree elements. However, it doesn't play an active role within this specific function but helps understand its context in the broader algorithm flow.\n\n8. args_str: Temporarily holds a string representation of arguments list for 'FunctionDef' nodes encountered during traversal; used when generating control flow structures involving functions having parameter inputs (definitions).\n\n9. h_name: During processing an exception block, 'h_name' temporarily saves identifier names present in exceptions clauses ('except') if found as a name node within the AST tree. It helps create clear PlantUML hints for visualization purposes.\n\n10. control_flow_dict: An empty dictionary created when encountering a 'try' block, which gets updated with nested dictionaries representing \"try\", \"except\", and optionally \"else\" or \"finally\" parts of the partitioned statement as control flow elements. This variable facilitates storing multi-level control flow structures encountered in exception handling code sequences within the program flow charting process.\n\n11. if_block & finally_block: If statements with related blocks under conditions (\"if\", \"while\", or \"for\") lead to creating 'if_block' dictionaries capturing conditionals and their subsequent flows (true/false paths). On the other hand, 'finally_block' saves elements associated with Python's 'finally' keyword when present in AST nodes.\n\n12. orelse & except_block: While handling nested control statements such as conditional blocks containing additional clauses like else or exceptions (\"if\", \"while\", \"for\"), these variables are utilized for iterating through 'orelse' elements if present after a base conditional construct, respectively creating additional sub-branches of \"elif\" parts in the control flow structure.\n\nIn summary, each variable mentioned above plays a specific role within the 'extract_control_flow_tree' function to parse Python AST nodes into a well-organized hierarchical representation of control flow structures that can be later visualized using PlantUML diagrams.\n"
    },
    {
        "instruction": "Returns from `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "control_flow_tree\n\nPurpose and Significance:\nThe purpose of 'extract_control_flow_tree' function within the given context ('py2dataset\\get_code_graph.py') is to extract and generate a control flow tree representation from the Abstract Syntax Tree (AST) obtained during Python source code analysis. This function parses each node in the AST and transforms it into a structured format, which represents the sequence of statements and conditional logic present within the codebase.\n\nThe 'control_flow_tree' returned by this function is essentially a list comprising elements that are either strings denoting single instructions or dictionaries containing key-value pairs representing complex blocks such as functions, classes, loops (while/for), try/except structures, etc. Each dictionary contains a 'key', which could be the identifier for that particular control flow block ('def', 'class', 'if', 'try', 'except'), and its corresponding 'value' being another nested list or string representing subordinate elements within it. This recursive approach helps in traversing through all levels of conditional statements until reaching leaf nodes in the codebase.\n\nTo elaborate further on individual returns from extract_control_flow_tree function usage in overall execution:\n1. Dictionaries as child blocks' representations like ('def', 'class') in 'control_flow_structure': They capture multiple subelements if nested conditions are encountered, maintaining hierarchy through indentation.\n2. Strings as individual atomic elements such as a simple assignment or call statements not falling into any specific control flow category are represented as single elements in 'control_flow_structure'.\n\nThis 'control_flow_tree' generated plays an important role when creating PlantUML representations as mentioned later through get_plantUML(), visualizing program activities following clear and explicit node/edges to display data processing, functions call chaining along with exceptions management or flow control decisions. It helps developers understand the underlying logic flow of a Python file easily.\n"
    },
    {
        "instruction": "Inputs to `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element: dict, indentation='') -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if 'def' in key or 'class' in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif 'if' in key or 'while' in key or 'for' in key:\n            condition = key.replace('if ', '').replace('while ', '').replace('for ', '')\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif 'try' in key:\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif 'except' in key:\n            exception_condition = key.replace('except ', '')\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f'{indentation}: {key};\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}: {element};\\n'\n    return plantuml_str\n```",
        "output": "element, indentation\n\nPurpose and Significance:\nIn the context of 'get_plantUML_element' function within 'py2dataset\\get_code_graph.py', inputs 'element' and 'indentation' serve significant roles for generating PlantUML code snippets representing individual elements in a clear and organized manner within the control flow structure.\n\nThe parameter 'element' holds distinct nodes or sub-elements extracted during parsing of Python source code's abstract syntax tree (AST). It can be either a dictionary containing nested control flow logic like function definitions, class declarations, if/while loops, try/except blocks, etc., or a string representing a single activity within the flowchart. This element helps determine what type of node needs to be represented in PlantUML format and its respective placement within the diagram.\n\nOn the other hand, 'indentation' represents the current level of indentation while generating PlantUML code. It is used to maintain proper formatting in the activity diagram visualization. When generating a plantuml representation for different nested nodes/subelements (if blocks inside if-else loops or methods under class declarations), varying indentations make the structure easily understandable and align with industry standards for better readability. Thus, 'indentation' plays a crucial role in enhancing presentation clarity.\n\nTo sum up, 'element' provides the content to be converted into PlantUML format while 'indentation' ensures proper visual organization within the diagram generated by 'get_plantUML_element'. Together they contribute towards creating an accurate and readable representation of Python program logic using PlantUML syntax.\n"
    },
    {
        "instruction": "Docstring of `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element: dict, indentation='') -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if 'def' in key or 'class' in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif 'if' in key or 'while' in key or 'for' in key:\n            condition = key.replace('if ', '').replace('while ', '').replace('for ', '')\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif 'try' in key:\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif 'except' in key:\n            exception_condition = key.replace('except ', '')\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f'{indentation}: {key};\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}: {element};\\n'\n    return plantuml_str\n```",
        "output": "Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element"
    },
    {
        "instruction": "Calls made in `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element: dict, indentation='') -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if 'def' in key or 'class' in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif 'if' in key or 'while' in key or 'for' in key:\n            condition = key.replace('if ', '').replace('while ', '').replace('for ', '')\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif 'try' in key:\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif 'except' in key:\n            exception_condition = key.replace('except ', '')\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f'{indentation}: {key};\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}: {element};\\n'\n    return plantuml_str\n```",
        "output": "isinstance, next, iter, get_plantUML_element, key.replace('if, ).replace('while, ).replace, key.replace('if, ).replace, key.replace\n\nPurpose and Significance:\nIn the context of 'get_plantUML_element' function within 'py2dataset/get_code_graph.py', several built-in Python functions are utilized to create PlantUML elements representing individual activities within a control flow structure. Let us examine each mentioned call individually with their roles:\n\n1. isinstance(element, dict): This checks if the given 'element' is an instance of dictionary data type. It helps differentiate between dictionary elements (representing blocks like def/class statements) and string elements (representing nodes within diagram). This check assists in preparing proper output based on data type for generating PlantUML representation.\n\n2. next(iter(element)): Here 'element' refers to a dictionary containing key-value pairs where the keys represent different blocks or nodes from control flow structure, and values are lists containing further nested elements if any. The 'next()' function returns an iterator over the keys of this dictionary allowing us to pick up the first key in each iteration during PlantUML generation process.\n\n3. iter(element): This creates an iterator over 'element' that helps in iterating through dictionary keys to explore each unique activity (blocks/nodes) and prepare their PlantUML code sequentially.\n\n4. get_plantUML_element(): This function is explicitly mentioned twice in the list but should be understood as one significant call with varied parameters related to 'get_plantUML_element'. It generates a single piece of plantuml output with or without any prefixes, handling unique use-cases as follows - processing an individual control structure (with varying keys). Here,'indentation' becomes increasingly used during recursion.\n   a) When generating code for dictionaries (blocks): The function returns detailed PlantUML snippet incorporating proper syntax to denote classes/definitions and their relationships.\n   b) When handling string elements (nodes): It simply adds them as they are without any additional formatting.\n\n5. key = next(iter(element)): Within get_plantUML_element() call specifically referring 'next(iter())' combo, 'key' obtains distinct nodes or blocks (dictionaries keys) after advancing through iterator each time until no more elements remain in the dictionary being processed.\n\n6. key.replace('if ', ''): This replaces a substring 'if ' from 'key', which is helpful when dealing with if statements in control flow structure. It removes 'if' keyword to generate clearer PlantUML syntax for conditional blocks representation. Similar operations are performed on other keywords like 'while', 'for'.\n\n7. key.replace('if ', '').replace('while ', ''): Combines two replace calls, stripping 'if'/'while' prefixes in 'key', offering simpler node representations for diagram readability and organization purposes within PlantUML output string creation process.\n\n8. key.replace('if ', '')/key.replace('for ', '')/key.replace('while ', ''): These calls perform similar operations as mentioned above but for different keywords ('if', 'while', 'for') to ensure uniformity in removing prefixes from keys before generating PlantUML code snippets.\n"
    },
    {
        "instruction": "Variables in `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element: dict, indentation='') -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if 'def' in key or 'class' in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif 'if' in key or 'while' in key or 'for' in key:\n            condition = key.replace('if ', '').replace('while ', '').replace('for ', '')\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif 'try' in key:\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif 'except' in key:\n            exception_condition = key.replace('except ', '')\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f'{indentation}: {key};\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}: {element};\\n'\n    return plantuml_str\n```",
        "output": "exception_condition, key, inner_indentation, value, condition, indentation, element, plantuml_str\n\nPurpose and Significance:\nIn the context of 'get_plantUML_element' function within 'py2dataset\\get_code_graph.py', several variables play crucial roles to generate PlantUML activity diagram elements representing Python program logic flow. Their purposes are as follows:\n\n1. exception_condition: This variable is specifically used when dealing with \"except\" blocks in the control flow tree extraction process. It holds the exception type name extracted from keys related to such structures. Its significance lies in creating distinct partition names within PlantUML diagrams for better representation of try/except sections during visualization.\n\n2. key: Being a variable across multiple functions like 'get_plantUML_element' and others, 'key' usually refers to a controlling statement or construct identification string such as \"if\", \"def\", \"class\", etc., extracted from control flow elements. It helps in labeling nodes accurately within PlantUML diagrams.\n\n3. inner_indentation: An internal indentation value that gets increased while traversing nested control statements inside 'get_plantUML_element'. It creates visually distinct layers of nodes in the final PlantUML diagram with an increased depth relative to higher scopes in the program structure (for instance, inner if statements or blocks).\n\n4. value: As a generic variable across various functions, 'value' represents either a dictionary containing nested control flow elements or a standalone string representing a single activity node in the PlantUML diagram. It holds parsed data from AST nodes for further processing within 'get_plantUML_element'.\n\n5. condition: This variable is derived from keys like \"if\", \"while\" and \"for\", acting as filter criteria when working on such controlling statement sections in extract_control_flow_tree. Inside 'get_plantUML_element', it defines logical tests enclosed within parentheses after \"partition if ({condition})\".\n\n6. indentation: Serving similar purposes across various functions, 'indentation' determines the initial level of white spaces required before labeling nodes in PlantUML diagrams. It helps maintain proper formatting and readability while generating activity diagram code strings.\n\n7. element: This variable represents a control flow structure element being processed within 'get_plantUML_element'. It can be either a dictionary or string type, depending on the current node level in traversal during recursion, thereby deciding visual components for PlantUML output representation.\n\n8. plantuml_str: As accumulating variable inside 'get_plantUML_element', it stores generated PlantUML code snippets for each element one by one. Eventually, this string combines all elements into a comprehensive PlantUML diagram representing the entire file's activity flow when called from 'get_plantUML'.\n"
    },
    {
        "instruction": "Returns from `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element: dict, indentation='') -> str:\n    \"\"\"\n    Get plantUML code for each element, including clear hints for try/except blocks.\n    Args: \n        element: control flow element\n        indentation: current indentation\n    Returns:\n        plantuml_str: plantUML code for each element\n    \n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if 'def' in key or 'class' in key:\n            plantuml_str += f'{indentation}: {key};\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n        elif 'if' in key or 'while' in key or 'for' in key:\n            condition = key.replace('if ', '').replace('while ', '').replace('for ', '')\n            plantuml_str += f'{indentation}if ({condition}) then (yes)\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}endif\\n'\n        elif 'try' in key:\n            plantuml_str += f'{indentation}partition \"try\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        elif 'except' in key:\n            exception_condition = key.replace('except ', '')\n            plantuml_str += f'{indentation}partition \"except {exception_condition}\" {{\\n'\n            inner_indentation = indentation + '    '\n            for item in value:\n                plantuml_str += get_plantUML_element(item, inner_indentation)\n            plantuml_str += f'{indentation}}}\\n'\n        else:\n            plantuml_str += f'{indentation}: {key};\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}: {element};\\n'\n    return plantuml_str\n```",
        "output": "plantuml_str\n\nPurpose and Significance:\nIn the given context of 'get_plantUML_element' function within 'py2dataset\\get_code_graph.py', its primary purpose is to generate PlantUML code fragments representing individual elements extracted from the control flow structure obtained during analysis of a Python source file. Each iteration over 'element' in this function produces one such fragment that contributes towards the overall PlantUML representation of the program activity diagram for improved readability. It accommodates elements including classes/methods ('if', 'def', or 'class') alongside more conditional constructions such as control loops ('while', 'for') and exception handling blocks ('try', 'except').\n\nThe significance of different return values from 'get_plantUML_element' lies in their contribution towards creating a coherent PlantUML string representation. Each time the function processes an element, it appends its corresponding PlantUML code snippet to the accumulating variable 'plantuml_str'. This way, when all elements are processed, 'plantuml_str' would hold complete PlantUML diagram code depicting Python program's flowchart in a readable manner. It utilizes indentation ('indentation') for structuring and clarity within the PlantUML syntax. Thus, each return from 'get_plantUML_element' forms a small part of the final visual representation of control flow, ultimately making sense when combined together in 'get_plantUML'.\n\nIn summary, 'get_plantUML_element', with its separate contributions in terms of return values for diverse code structures ('@startuml', indented node-related commands), creates vital fragments eventually stitched by 'get_plantUML' to build the PlantUML representation useful for comprehending complex Python logic flow patterns at a glance.\n"
    },
    {
        "instruction": "Inputs to `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "code_graph, control_flow_structure\n\nPurpose and Significance:\nIn the given context within 'get_code_graph.py', the functions 'code_graph' and 'extract_control_flow_tree' generate crucial inputs for 'reorganize_control_flow'. The primary purpose of these inputs is to provide necessary data required for structuring the control flow tree according to the code graph.\n\nThe 'code_graph' function creates a dictionary representation of file details with nodes (functions/classes) and edges representing relationships between them in Python code. It includes adding edges based on function calls and extracting edge data related to input-output information for better understanding of control flow. This helps establish the initial context for mapping control flow structure within the program logic.\n\nOn the other hand, 'extract_control_flow_tree' parses Abstract Syntax Tree (AST) nodes into a list containing Python abstracted statements and conditional logic elements like classes/definitions as nodes or leaf strings representing distinct activities. This function creates a control flow tree that represents the program's sequential execution pathways.\n\nNow, coming to 'reorganize_control_flow', its purpose is to modify extracted control flow structures according to the graph obtained from 'code_graph'. It ensures starting points match the code graph nodes by recursively processing elements until all control flow parts are accounted for in an organized manner. This function takes these two inputs - 'code_graph' and 'control_flow_structure', and rearranges them into a more comprehensible format for better understanding of program execution order.\n"
    },
    {
        "instruction": "Docstring of `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure"
    },
    {
        "instruction": "Calls made in `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend, reorganize_structure\n\nPurpose and Significance:\nIn the context of 'reorganize_control_flow' function within 'py2dataset/get_code_graph.py', various listed object usages hold significance as they participate to reshape control flow structure conforming with nodes identified from generated code graphs:\n\n1. set: This built-in Python data type is utilized in creating a set 'seen'. It helps keep track of elements already processed during recursion, preventing duplication while appending organized structures into the final result ('organized' list). In simple words, sets maintain uniqueness to optimize restructuring complexity and save processing time.\n\n2. isinstance(): A built-in function checking if an object is an instance of a specific class or derived from it. Here, it ensures whether the current element in iteration is a dictionary (representing control flow structure parts) or a string (indicating simple statements). This classification helps handle different processing logics for each type during plantUML code generation.\n\n3. next(): A built-in function used with iterable objects such as dictionaries to get their elements successively by traversing keys, particularly important while picking first key out of dict input for further actions within 'get_plantUML_element'. It helps in identifying the type of control flow element (e.g., def/class statement) during plantuml generation.\n\n4. iter(): An iterator function applied to dictionaries retrieving keys or other iterable objects allowing step-by-step access for processing each element in a loop construct like 'for element in structure'. In our context, it's used for iterating over dictionary elements in control flow structures.\n\n5. json.dumps(): This method serializes Python objects into JSON strings. Here it creates unique identifiers for already seen structured parts to maintain uniqueness in recursion during structuring 'organized'. By encoding as JSON format, Python ensures avoiding duplicates despite complex data nesting in the control flow tree.\n\n6. organized.append(): This method adds elements into a list ('organized') after checking their relevance with respect to starting points from code graphs. It helps build the final restructured control flow tree by appending each valid element one by one.\n\n7. seen.add(): A set operation adding processed elements as unique identifiers (json encoded dictionary representations) into the 'seen' set for avoiding redundancy while organizing the control flow structure.\n\n8. organized.extend(): Appends remaining elements in the original list ('remaining') to 'organized', ensuring no part of control flow tree is missed during recursion. This ensures comprehensive structuring even if some parts don't match starting points from code graphs initially.\n\n9. reorganize_structure(): It's a custom function call within 'reorganize_control_flow'. This function takes two arguments - 'structure', the control flow tree to be rearranged, and 'starting_points', nodes identified in generated code graphs as starting points for traversal. The function returns an organized version of input structure based on these starting points through recursive processing.\n"
    },
    {
        "instruction": "Variables in `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "key, control_flow_structure, targets, remaining, element_id, code_graph, starting_points\n\nPurpose and Significance:\nIn the 'reorganize_control_flow' function within 'py2dataset\\get_code_graph.py', several variables play significant roles in organizing the control flow structure to match the code graph created earlier. Let's understand each of these variables individually:\n\n1. key: This variable is primarily used during the iteration over the 'control_flow_structure' dictionary when processing elements within the function. It temporarily stores a key from the dictionary, which helps in identifying the type of control flow element encountered (e.g., if, while, for loops, try/except blocks, class definitions, etc.).\n\n2. control_flow_structure: This is an input variable that holds the entire extracted control flow tree structure created using AST traversal and processing from the Python source code. Its elements will be rearranged to match the code graph in the output of this function.\n\n3. targets: In the context of 'reorganize_control_flow', targets are edges present in the code graph representing functions or methods that do not act as starting points for further analysis or control flow iteration purposes. The objective here is to ignore such edges connected only with a terminal node from code execution viewpoints.\n\n4. remaining: This variable holds the list of elements left unprocessed after extracting all matching elements from 'control_flow_structure' based on the starting points identified in 'starting_points'. It includes those parts that do not contribute directly to the organized control flow structure but are still part of the original tree.\n\n5. element_id: A temporary identifier generated using json serialization ('json.dumps') for keeping track of unique elements within the recursive function call stack during reorganization. This helps in avoiding duplicate inclusion or processing redundant elements twice while creating the organized structure.\n\n6. code_graph: Although not directly operated upon within 'reorganize_control_flow', this variable contains the code graph constructed from parsing Python file details such as functions, classes, method calls, etc., and edge relationships between them. It acts as a reference to ensure control flow restructuring aligns with actual code representation.\n\n7. starting_points: These are nodes in the code graph that serve as initializing points for iterating through control flow elements. They represent parts of the program execution where control flow starts, such as function calls or method definitions without incoming edges from other functions/methods. Starting points guide recursive processing in the 'reorganize_structure' helper function until all significant parts of control flow structure are considered in organized form.\n"
    },
    {
        "instruction": "Returns from `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "reorganize_structure(control_flow_structure, starting_points), organized\n\nPurpose and Significance:\nThe purpose of invoking 'reorganize_control_flow' function lies primarily in structuring or rearranging the extracted control flow tree so that it aligns with the graph obtained from 'code_graph'. This alignment ensures a logical order reflecting the actual code execution sequence within Python files. The returned values after calling this function are as follows:\n\n1. `control_flow_structure` remains unchanged but represents an organized version of the initial control flow tree derived from parsing the source code using Abstract Syntax Tree (AST). It consists of dictionary elements and strings that correspond to different statements, conditions, or blocks present in Python files. These include functions, classes, conditional statements like if/while/for loops, try/except blocks, etc., arranged according to their starting points found in the code graph.\n\n2. Additionally, 'organized' is another return value from 'reorganize_structure'. It acts as an intermediate result during recursive traversal within the function and stores elements that have been processed until a certain level of depth or branching. This variable helps maintain track of elements seen during structuring without repeating them further in the control flow structure, thus preventing duplication while ensuring completeness.\n"
    },
    {
        "instruction": "Inputs to `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "source_name, calls\n\nPurpose and Significance:\nIn the context given inside 'get_code_graph.py', the function `add_edges_for_calls` is primarily concerned with handling edges for function or class method calls within a Python file's codebase. The inputs 'source_name' and 'calls' play crucial roles in this process.\n\nThe input 'source_name' refers to either an already extracted function name from function definitions within the summarized details of a file (in case of pure functions) or qualified method names in the form 'class_name.method_name' when dealing with class methods. This source node represents where the edge originates from, indicating the calling entity in the code graph.\n\nOn the other hand, 'calls' represents the list containing references to target methods (function names/class method details) which this source calls upon during program execution. By connecting these nodes accurately using the specified relations in code through edge generation between sources and their respective targets, `add_edges_for_calls` contributes significantly towards building a comprehensive graphical representation of relationships among functions and class methods within the Python file under analysis. This graphical understanding helps developers trace function dependencies more easily while analyzing or debugging complex codebases.\n"
    },
    {
        "instruction": "Calls made in `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "list, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, G.add_node\n\nPurpose and Significance:\nIn the context of 'add_edges_for_calls' function within 'get_code_graph', various operations are executed involving multiple built-in Python methods along with internal function calls for creating connections between function/method invocations in a Python codebase. Let us break down each mentioned call and its purpose:\n\n1. list: This refers to the global Python data type representing an ordered collection of elements. It is not explicitly called as a function but appears when accessing elements from containers like file_summary[\"function_defs\"] or class_method_details_lookup values which are lists containing function/class details respectively.\n\n2. class_def.keys(): This call returns an iterable containing keys present in the dictionary object 'class_def'. Since 'class_def' is a part of file_summary['class_defs'] collected while initializing 'code_graph', keys help obtain each classified item separately during process creation stages to facilitate traversing into details inside these structures when handling classes.\n\n3. called.split(\".\"): When parsing qualified method names such as \"self.someMethod\" in Python code, this split call helps segregate the class name from the actual method name for better identification and connection establishment between them. It splits the string 'called' at every occurrence of '.' character.\n\n4. called.startswith(\"self.\"): This check verifies if the current method invocation starts with \"self.\", indicating it is a call within an instance context (i.e., inside a class). If true, it proceeds to extract the actual method name by removing \"self.\" prefix from 'called'.\n\n5. called.replace(\"self.\", \"\"): This replaces all instances of \"self.\" with empty string in 'called', resulting in the pure method name when 'startswith' identified it as an instance call.\n\n6. source_name: It represents a variable holding the current function or class method identifier being processed during edge creation for connections.\n\n7. add_edge_with_data(source_name, called): This is an internal function call within 'add_edges_for_calls' responsible for adding edges to the graph object 'G'. It connects source nodes (functions/methods) with target nodes based on their relationships while incorporating edge data extracted from 'get_edge_data_from_details'.\n\n8. G.add_node(source_name): This call adds a node representing a function or class method to the networkx DiGraph object 'G', creating an identity for each distinct entity in the code graph.\n\nOverall, these calls work together within 'add_edges_for_calls' to establish connections between functions/methods based on their invocations and create a directed graph representing relationships in Python code while maintaining proper node identities with respective details extracted during analysis steps beforehand.\n"
    },
    {
        "instruction": "Variables in `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "init_method, fully_qualified_name, source_name, class_names, method_name, init_method_name, called_class_name, calls\n\nPurpose and Significance:\nIn the context of 'add_edges_for_calls' function within the given Python script ('py2dataset\\get_code_graph.py'), the listed variables play important roles to ensure adding appropriate edges corresponding to function calls within a code graph while iterating over all elements from the function or class method definitions contained in 'file_summary'. Here is their purpose and significance:\n\n1. init_method: This variable serves as an intermediate helper during edge creation for class methods where we need to define __init__ specifically, indicating its relation to initialization routines in a Class Definition context. In case the node type matches with ast.ClassDef from ast module while processing control flow tree, this variable will have assigned value based on node handling steps involving method details extracted within the 'extract_control_flow_tree'. Otherwise it remains None during other instances where this isn't relevant.\n\n2. fully_qualified_name: It represents a complete identifier for a method call in case of classes when adding edges between class names and their methods. The formation happens by appending '.__init__' to the called_class_name when 'init_method' has a non-null value (i.e., it indicates we are dealing with an initialization method). This variable helps maintain proper references in the code graph for better understanding of class relationships.\n\n3. source_name: It refers to either function names or qualified method names extracted from 'function_details_lookup' or 'class_method_details_lookup', depending upon whether node type matches ast.FunctionDef, ast.AsyncFunctionDef during the initial traversal or gets generated fully_qualified_name through the Class Definitions while forming edges involving calls related to Class instances ('qualified_method_name').\n\n4. class_names: This variable holds a list of keys extracted from 'class_defs' within 'file_summary'. It helps identify classes during edge creation when encountering method calls originating from them, ensuring accurate graph representation.\n\n5. method_name: In the context of adding edges for function or class method calls ('add_edges_for_calls'), 'method_name' serves no apparent use; its association occurs only with handling instances from another step involving nested blocks or nodes' type assignments, primarily concerning keyword mapping (node_keywords_map).\n\n6. init_method_name: Similar to 'init_method', this variable holds value only when dealing with class definitions ('ast.ClassDef'). The specific identifier becomes \"_class__.init__\", maintaining Class method relationship precision during graph formations while following edge building process around Python files control structures and functionalities.\n\n7. called_class_name: Derived from string split operations in nodes (specifically call locations where it starts with 'self.' indicating method calls inside instance blocks). In edge addition between caller/callee pairs within a class context, this variable gets involved when the called entity represents an entire class object invoking a certain operation or function.\n\n8. calls: This list holds the collected function calls details for a specific source node being processed. These calls could be originating from either functions or classes. During edge formation steps in 'add_edges_for_calls', it helps identify related targets and establish connections between them in the code graph accurately.\n"
    },
    {
        "instruction": "Inputs to `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "structure, start_points\n\nPurpose and Significance:\nIn the context given within 'get_code_graph.py', the functions 'reorganize_control_flow' plays a crucial role in arranging extracted control flow structures according to the graph obtained from 'code_graph'. This ensures consistency among all data related parts resulting after multiple code operations parse throughout program processing steps. As per implementation detail inside function itself,'structure' symbolizes segregated entities attained in various ways mainly coming as product of parsing via 'extract_control_flow_tree', representing the whole flow diagram split into subunits, i.e., each command, decision-making statements and exceptions. This array could contain nested dictionaries or strings representing distinct activities within Python codebase.\n\nOn the other hand,'start_points' refers to a list of nodes in the code graph that don't have any incoming edges (i.e., they are not targets of any function calls). These serve as entry points for traversing through the control flow structure during recursive processing within 'reorganize_structure'. It helps identify elements that mark starting conditions for execution paths and are generally methods or classes present in Python file without being called by other functions/methods. Thus, these two inputs,'structure' and 'start_points', work together to create an organized representation of control flow logic while maintaining the code graph's starting points consistency.\n"
    },
    {
        "instruction": "Calls made in `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "set, isinstance, next, iter, json.dumps, organized.append, seen.add, organized.extend\n\nPurpose and Significance:\nIn the context of 'reorganize_structure' function within 'get_code_graph.py', these mentioned calls serve significant roles during organizing and structuring the extracted control flow elements into a more logical format, aligning them with starting points from the code graph. Here is an explanation for each one:\n\n1. set: This built-in Python data type is used to create 'seen' as a set object which keeps track of elements already added in organized structure during recursion. It ensures no repetition while traversing the control flow tree.\n\n2. isinstance(): A Python function that checks if an object is an instance of a specific class or derives from it indirectly through one or more base classes. In this case, it's utilized to verify whether elements are instances of either dict type indicating nodes of different hierarchy in the tree or plain string representations corresponding to activity blocks like condition statements and leaves for atomic processes in conditional blocks like \"if\" and \"except\".\n\n3. next(): This function is part of Python's iterator protocol used when dealing with iterable objects like dictionaries ('element' variable which represents a dictionary key-value pair in the current iteration). It advances the internal position of an iterator object, returning its value on each call. In 'reorganize_structure', next() fetches the first key of element (i.e., main label) during the dictionary traversal while forming PlantUML activity diagram parts with corresponding details as value recursively.\n\n4. iter(): A built-in Python function which returns an iterator over the contents of any sequence, collection, or string object including dictionaries where key is needed repeatedly like next().\n\n5. json.dumps(): This method serializes a Python object into a JSON string representation. It's used to convert organized elements (dict objects) into unique identifiers for tracking purposes in the recursive traversal process of 'reorganize_structure'. By dumping dictionaries as strings, they can be compared later to avoid unnecessary repetition when checking if an element has been seen before adding it to the organized list.\n\n6. organized.append(): Append operation adds elements into a list named 'organized', which stores control flow parts that have been checked for duplicate occurrence and marked as processed in the traversal. Each distinct structure item (be it a dictionary or string) gets added sequentially.\n\n7. seen.add(): This call adds an element to the set object 'seen'. It ensures unique elements are only considered once during recursion, preventing duplication while constructing organized control flow structure.\n\n8. organized.extend(): Another list manipulation function which appends all elements of iterable into organized at its current position rather than inserting them one by one using 'append'. Remaining control flow elements left after handling all distinct starting points are extended here for completion.\nThese operations combined provide an optimized methodology to structure extracted control flow data as per the code graph's starting points, resulting in a more comprehensible representation of Python program logic flow.\n"
    },
    {
        "instruction": "Variables in `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "key, structure, remaining, element_id, start_points\n\nPurpose and Significance:\nIn the context of 'reorganize_structure' function within 'get_code_graph.py', the given variables hold specific roles contributing towards restructuring the control flow elements to match the code graph obtained from 'code_graph'. Here is a breakdown of each variable:\n\n1. 'key': It acts as an iterator for looping through 'structure', which contains various nested dictionary keys (mainly extracted control flow segments) when converting them into a linear form according to starting points found in the code graph ('starting_points'). This helps maintain logical order while organizing elements.\n\n2. 'structure': It represents the initial, potentially chaotic list of extracted control flow structure that needs to be organized to follow graphical starting nodes in 'code_graph'. 'reorganize_structure' aims at reshuffling this complex tree into a linearized form for better understanding and easier interpretation.\n\n3. 'remaining': As the iteration progresses over 'structure', some elements may not fit within any organized portion ('organized') as starting points match other nodes. 'remaining' keeps track of those remaining elements yet to be added at the end of the restructured list after processing all primary matching parts.\n\n4. 'element_id': This temporary identifier is used when adding organized elements into the 'organized' list during recursion. It ensures no duplication occurs while maintaining uniqueness in the final output list by converting dictionaries into JSON strings ('json.dumps') before checking for membership in 'seen'.\n\n5. 'start_points': These are nodes identified as starting points from the code graph that serve as reference anchors for reorganizing control flow elements. They help determine which segments should be grouped together based on their association with graph nodes ('nodes' from 'code_graph'). By following these starting points recursively, 'reorganize_structure' arranges extracted elements into a more coherent order representing actual code execution paths.\n"
    },
    {
        "instruction": "Returns from `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "organized\n\nPurpose and Significance:\nIn the context given within 'get_code_graph.py', the function 'reorganize_structure' plays a crucial role within the 'reorganize_control_flow' function to sort and rearrange extracted control flow elements in a more structured manner so that they align with the nodes obtained from the code graph created by 'code_graph'. The primary objective is to ensure a better understanding of the program's logic flow.\n\nThe return value of 'reorganize_structure', denoted as '[organized]', represents this organized output after processing the control flow structure according to starting points derived from the code graph. This organized list contains dictionaries or strings representing each element in a way that reflects their hierarchical relationship and position within the program's flow. It simplifies comprehension while analyzing Python files' behavior through PlantUML visualization later on.\n\nWithin 'reorganize_structure', several variables contribute to its functioning:\n1. 'element': Represents each control flow structure element being processed during recursion. It could either be a nested dictionary corresponding to control block entries such as functions ('if', 'for', or 'def'), try blocks containing child clauses of \"except\" etc., or mere string forms which act as leaf nodes in the tree representation.\n2. 'structure': Initial unorganized list of control flow elements extracted by 'extract_control_flow_tree'.\n3. 'starting_points': A set of nodes identified from the code graph that serve as starting points for rearrangement purposes during recursion. These are usually plain identifiers (not within any nested structure).\n4. 'element_id': This temporary identifier is created by json serialization ('json.dumps') of elements in the form of dictionary keys to keep track of unique occurrences and avoid repetition while adding them into organized list. It helps prevent duplication when multiple identical elements exist within control flow structure.\n\nTo summarize, '[organized]', i.e., the return value from 'reorganize_structure', presents a rearranged version of control flow structure adhering to the graph's starting points obtained through code analysis, thereby providing better insights into Python file operations in an easy-to-interpret format.\n"
    },
    {
        "instruction": "Inputs to `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "file_summary, file_ast\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py', the inputs 'file_summary' and 'file_ast' hold crucial significance when invoking the `get_code_graph` function as these values feed critical data needed to produce extensive code analysis documentation encompassing structural diagrams (i.e., control flow graph and PlantUML representation).\n\nThe 'file_summary' argument represents a dictionary containing extracted details from parsed Python source code tokens or abstract syntax tree nodes. It includes information about function definitions, class details along with their methods as separate key-value pairs within the dictionary. This allows identification of essential nodes required to establish connections and visualize their relationships within the overall structure of the codebase.\n\nOn the other hand, 'file_ast' is an abstract syntax tree representing the entire Python source code as a nested hierarchical data structure comprehensively outlining control flow constructs like loops, conditionals, exceptions, etc., along with class and function definitions. This Abstract Syntax Tree (AST) serves as a base for extracting control flow logic which will be later organized to match the graph created from 'file_summary'.\n\nIn summary, 'file_summary' provides static structural information about functions and classes while 'file_ast' delivers dynamic control flow elements of the Python program. Together, they help `get_code_graph` achieve its primary objective by integrating code graph creation, control flow extraction, and PlantUML diagram generation for entire file analysis while ensuring smooth handling of any possible exceptions during processing steps.\n"
    },
    {
        "instruction": "Docstring of `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details"
    },
    {
        "instruction": "Calls made in `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "code_graph, extract_control_flow_tree, reorganize_control_flow, get_plantUML, str\n\nPurpose and Significance:\nIn the context of 'get_code_graph', these crucial functions play significant roles to achieve its primary objective - combining code graph generation, control flow extraction, and PlantUML creation for an entire Python file analysis. Let's elaborate on each one:\n\n1. 'code_graph': This function constructs a dictionary representing nodes (functions/classes) and edges (function calls) in the Python file based on given details extracted from the analyzed tokens. It creates a directed graph using networkx package's DiGraph() to depict relationships between functions, methods, and classes within the codebase.\n\n2. 'extract_control_flow_tree': This call parses Abstract Syntax Tree (AST) nodes into a control flow tree representation of Python source code statements and conditional logic. It helps understand program flow better by segregating try blocks along with handling class/definitions as nodes or leaf strings representing distinct activities.\n\n3. 'reorganize_control_flow': Given an output generated through control flow structure extraction by `extract_control_flow_tree`, the function alters this extracted control flow data into organized form according to the code graph's starting points obtained from 'code_graph'. It recursively processes elements until all control flow parts are accounted for in a structured manner.\n\n4. 'get_plantUML': Invoked with an extracted and organized control flow structure (generated via earlier functions), this call produces plantUML activity diagram code string that visualizes the entire file's logic flow using '@startuml' and '@enduml' markers as standard PlantUML syntax requirements.\n\n5. 'str': Although not explicitly a function in `get_code_graph`, it appears in error handling within the last call sequence where control flow extraction or plantUML creation encounters exceptions ('control_flow_structure = [str(e)]', 'plantUML = str(e)'). It converts exceptions into string format for returning relevant information.\n\nTo summarize, these functions work collaboratively in `get_code_graph` to combine code graph generation, control flow extraction, and PlantUML creation for comprehensive Python file analysis while handling any potential exceptions encountered during execution. Each function has its distinct purpose yet they blend together to accomplish the main goal effectively.\n"
    },
    {
        "instruction": "Variables in `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "file_summary, control_flow_tree, control_flow_structure, plantUML, entire_code_graph, file_ast\n\nPurpose and Significance:\nIn the context of 'get_code_graph' function within 'py2dataset/get_code_graph.py', various variables play crucial roles to achieve its purpose - integrating code graph generation, control flow extraction, and PlantUML creation for an entire Python file analysis. Here's a breakdown of each variable mentioned:\n\n1. 'file_summary': It serves as initial input holding key details about analyzed tokens obtained from parsed Python files including function definitions/calls alongside class structures, enabling 'code_graph' to construct the relationship between them.\n\n2. 'control_flow_tree': This output from 'extract_control_flow_tree', represents a parsed representation of Python abstracted statements and conditional logic extracted from Abstract Syntax Tree (AST). It helps in understanding the control flow within the codebase.\n\n3. 'control_flow_structure': After processing through 'reorganize_control_flow', it becomes an organized version of 'control_flow_tree' according to the graph obtained from 'code_graph'. This ensures starting points match the code graph nodes for better comprehension.\n\n4. 'plantUML': Generated as a result of 'get_plantUML', this variable stores the final PlantUML diagram code string representing entire file activity using '@startuml' and '@enduml' markers. It visualizes Python program logic flow, aiding in easy interpretation.\n\n5. 'entire_code_graph': This temporary variable is returned by 'code_graph', containing nodes (functions/classes) and edges representing function calls within the codebase. It helps in understanding relationships between different parts of the code. However, note that this variable name is not explicitly used in 'get_code_graph'. Instead, the tuple returned by code_graph which consists of nodes and edges replaces it therein ((nodes, edges)).\n\n6. 'file_ast': Lastly, Ast tree formed after parsing Python source code serves as an input to extract control flow tree ('extract_control_flow_tree') and reorganize control flow structure ('reorganize_control_flow'). It is significant for traversing nodes and extracting meaningful control flow information.\n\nTo summarize, these variables collaborate in 'get_code_graph' function to integrate multiple steps resulting in detailed documentation regarding Python source code file analysis: building code graphs with node & edge relations, structuring control flow logic visually appealing manner using PlantUML activity diagrams and mapping it to actual source files via Abstract Syntax Tree (AST).\n"
    },
    {
        "instruction": "Returns from `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary: dict, file_ast: ast.AST) -> (dict, list, str):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "(entire_code_graph, control_flow_structure, plantUML)\n\nPurpose and Significance:\nThe purpose of invoking 'get_code_graph' function lies primarily in integrating three significant outcomes crucial for comprehensive Python file analysis. These returns serve distinct yet interconnected purposes within the overall code structure and documentation generation process:\n\n1. entire_code_graph: This return value is a dictionary resulting from 'code_graph', where nodes denote functions, class methods, and classes with their associated relationships captured through edges representing calls between them. In simple words, entire_code_graph outlines how each piece of functionality communicates with another in the source file at code-level detail. This data structure enables understanding program architecture by mapping functions and methods across the entire file scope.\n\n2. control_flow_structure: Generated via 'extract_control_flow_tree' function, this return represents the Control Flow Tree of Python abstracted statements such as class definitions, method invocations, conditional logic (if/while/for loops), exception handling blocks (try/except), and more. It provides a step-by-step flowchart view of how program execution proceeds within the file. This structured data helps visualize Python script operations in terms of decision points, sequences, iterations, error management mechanisms, etc.\n\n3. plantUML: The final output from 'get_plantUML', this return value is a string containing PlantUML code representing an activity diagram for the entire file. PlantUML is a visual language used to create UML diagrams using textual notation. In our context, it illustrates the Python program's logic flow through graphical elements such as nodes (methods/classes), edges (call relationships), partitions (try blocks), etc., thereby making complex algorithms visually comprehensible at a glance. PlantUML allows developers to identify potential issues in advance or assess optimization opportunities with ease by quickly reviewing the visual representation rather than manually scanning lines of code.\n\nThus, combinedly, these returns offer multi-perspective insights into Python source files\u2014from structural connections ('entire_code_graph') to procedural execution paths ('control_flow_structure'), and a visualization aid ('plantUML')\u2014empowering developers to better analyze and improve code efficiency.\n"
    },
    {
        "instruction": "Inputs to `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "target_details, source_details, target\n\nPurpose and Significance:\nIn the context given from 'get_code_graph.py', the function 'get_edge_data_from_details' serves as a helper method within the 'code_graph' functionality to extract specific data related to edges connecting nodes in the code graph representation. Its primary purpose is to gather information about target node details (return values) and source node details (call inputs).\n\n1. 'target_details': This input represents the details of the function or class method that serves as the destination endpoint of an edge in the graph. It helps understand the relationship between a called function/method ('target') and its context within the codebase, including its return values stored in 'target_returns'.\n\n2. 'source_details': This input refers to the details of the function or class method acting as the originator of an edge in the graph. It provides information about call inputs required by the source node for making a connection with the target node.\n\n3. 'target': It is the actual identifier of the function or class method being referred to as the endpoint of an edge in the code graph. This input acts as a reference point for fetching relevant data from either 'function_details_lookup' or 'class_method_details_lookup', depending on whether it represents a function call or a class method call respectively.\n\nCombining these inputs, 'get_edge_data_from_details' effectively constructs edge attributes for nodes connected in the code graph with crucial input-output data for each connection within the Python source code structure analysis. These attributes allow users to interpret relationships better among different entities during further stages like visualization using PlantUML or analysis purposes.\n"
    },
    {
        "instruction": "Calls made in `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "target_details.get, list, set\n\nPurpose and Significance:\nIn the context of 'get_edge_data_from_details' function within 'code_graph', three mentioned elements hold distinct purposes advancing the process of constructing edges with data attributes for nodes representation in a code graph.\n\n1. target_details.get: This call aims to retrieve specific information from the dictionary associated with targeted methods or classes in 'function_details_lookup' and 'class_method_details_lookup'. It helps gather details like inputs, returns required for edge data creation while connecting nodes in the code graph.\n\n2. list: Although not directly called as a function within 'get_edge_data_from_details', lists are widely used throughout the codebase to store node names, edges data, AST nodes, control flow elements, etc., which contribute to overall functionality. They serve as containers for organizing diverse data types during processing steps.\n\n3. set: Sets appear in 'seen' variable within 'reorganize_structure'. It is utilized to keep track of elements already included in the organized structure while recursively traversing control flow structures, preventing duplication and ensuring unique inclusion of elements only once. This helps maintain efficiency by tracking control elements and controlling structure loop traversals until there are no unaccounted entities remaining within given hierarchical patterns in 'reorganize_structure' method during structuring workflow manipulations.\n"
    },
    {
        "instruction": "Variables in `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "target, target_details, source_details, edge_data\n\nPurpose and Significance:\nIn the context of 'get_edge_data_from_details' function within 'code_graph', these variables hold crucial information related to extracting and preparing data for edges connecting nodes in the generated graph. Let's elaborate their purposes individually:\n\n1. target: This variable refers to a specific node in the code graph, usually representing either a method name (function or class) acting as a dependent node in terms of control flow or input/output requirements.\n\n2. target_details: This represents the detailed information related to the 'target' node, extracted from either function or class method lookup dictionaries created earlier ('function_details_lookup' or 'class_method_details_lookup'). These details can contain crucial inputs and returns lists associated with respective nodes in the graph.\n\n3. source_details: This variable holds information about the calling node in the code graph - the node invoking the operation at 'target'. It is either a function detail from 'function_details_lookup' or class method detail from 'class_method_details_lookup', depending on where the call originates.\n\n4. edge_data: This variable acts as an accumulator for extracted data required to define edges in the graph effectively. Its primary responsibility is collecting input requirements ('target_inputs') and return types ('target_returns') related to target and source nodes' operations to reflect precise dependencies among various program parts during runtime execution accurately. The dictionary containing 'source', 'target', 'target_inputs', and 'target_returns' is returned as edge data for further graph construction.\n"
    },
    {
        "instruction": "Returns from `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "edge_data\n\nPurpose and Significance:\nIn the given context of 'get_code_graph.py', the function 'get_edge_data_from_details' acts as a helper method within the 'code_graph' functionality to extract specific data related to edges connecting nodes in the code graph representation. Its primary purpose is to gather information about target node inputs and returns from both source and target details, thus enhancing edge understanding within the Python program flow.\n\nThe 'edge_data' dictionary returned by this function plays a significant role as it carries crucial metadata associated with each edge connecting nodes in the code graph. It consists of two keys - 'target_inputs' and 'target_returns'. These keys hold information about input arguments passed to the target node from its caller (source node) and return values expected or received by the target node respectively. This data helps visualize how functions interact with each other and pass parameters while executing tasks within a Python program.\n\nTo summarize, 'get_edge_data_from_details' contributes to constructing a more comprehensive graphical representation of code relationships by providing essential details about edges connecting nodes in the Python file analysis process.\n"
    },
    {
        "instruction": "Inputs to `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "control_flow_structure\n\nPurpose and Significance:\nIn the context given at 'get_code_graph.py', the 'control_flow_structure' plays a crucial role within the 'get_plantUML' function. This variable holds the organized control flow tree extracted from Python source code after processing through various steps such as parsing AST nodes, reorganizing structure according to the code graph starting points, and handling exceptions if any occur during execution. The purpose of 'control_flow_structure' is to provide a well-structured representation of Python program logic flows which will be later transformed into PlantUML format for visualization purposes.\n\nEach input element in 'control_flow_structure' represents distinct activities within the codebase, such as function definitions ('def'), classes ('class'), conditional statements ('if', 'while', 'for'), exception handling ('try', 'except') blocks or string literals signifying straightforward tasks performed during execution. This structured format is necessary for 'get_plantUML' to create an overall plantuml diagram code string representing the entire file activity diagram using '@startuml' and '@enduml' markers as standard PlantUML syntax requirements.\n"
    },
    {
        "instruction": "Docstring of `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file"
    },
    {
        "instruction": "Calls made in `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "get_plantUML_element\n\nPurpose and Significance:\nIn 'get_plantUML', the primary objective is compiling the entire PlantUML representation of a Python program's logic flow based on extracted elements from different stages of processing. It uses multiple calls to various helper functions from within itself, particularly those associated with generating individual plantUML fragments ('get_plantUML_element'). These calls contribute significantly towards creating an organized visual diagram that encapsulates the entire control flow structure in a comprehensible manner.\n\n1. Calling 'get_plantUML_element': This function generates PlantUML code snippets for each element within the control flow structure with clear hints for try/except blocks, which aid in understanding distinct activities such as method definitions, conditional logic or control structures. By iterating through every item ('control_flow_structure') of the extracted tree and invoking 'get_plantUML_element' with an appropriate indentation level (\"  \"), it collects all individual plantUML elements required for final diagram construction.\n\n2. The significance of these calls lies in their ability to provide granular PlantUML representations that are later combined into a single string representing the overall program flow using standard PlantUML syntax markers ('@startuml' and '@enduml'). Each 'get_plantUML_element' call extracts relevant details from the control flow structure while preserving crucial information like function definitions, conditional statements, etc. Their resultant string parts join seamlessly forming complete diagrammatic portrayals reflective of various logical parts that eventually result in meaningful interpretations and discussions regarding complex program functionality and debugging purposes.\n"
    },
    {
        "instruction": "Variables in `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "plantuml_str, control_flow_structure\n\nPurpose and Significance:\nIn the context of 'get_plantUML' function within 'py2dataset\\get_code_graph.py', plantuml_str and control_flow_structure hold crucial roles during the generation of PlantUML diagram code for representing Python program activity flow visually.\n\nplantuml_str serves as an accumulator variable that collects all generated PlantUML elements created by 'get_plantUML_element' function calls for each element within the control flow structure. It follows standard PlantUML syntax markers like '@startuml' and '@enduml', creating a string containing comprehensive activity diagram code of entire file operations. This string becomes readily usable once compiled with a dedicated PlantUML viewer or editor to visualize Python program logic effectively.\n\nOn the other hand, control_flow_structure is a list containing parsed control flow trees derived from AST node traversals by 'extract_control_flow_tree' function in the preceding process steps. This variable consolidates structured data pertaining to Python abstracted statements and conditional logic along with handling classes/definitions within the source code as nodes or leaf strings representing distinct activities. The 'reorganize_control_flow' function adjusts control flow structures according to the graph obtained from 'code_graph', ensuring starting points match the code graph's nodes for better understanding. By combining these organized elements, 'get_plantUML' constructs a clear visual representation of Python program's execution pathways and decision-making processes.\n\nIn summary, plantuml_str creates PlantUML diagram code string while control_flow_structure provides the necessary data points to generate meaningful visualizations for Python file analysis in 'get_plantUML'. Together they help developers comprehend complex code logic with ease.\n"
    },
    {
        "instruction": "Returns from `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "plantuml_str\n\nPurpose and Significance:\nIn the given context of 'get_code_graph.py', the function 'get_plantUML' plays a crucial role in generating PlantUML representation for visualizing Python program activity diagrams derived from extracted control flow structures. Its primary purpose is to compile all individual PlantUML elements created by 'get_plantUML_element' into a single string which portrays the entire file's logical workflow as per standard PlantUML syntax requirements. The return value '_plantuml_str'_ encloses the merged sequence that comprises starting symbol '@startuml', elements retrieved across steps within each module/file iterated throughout processes till end notation '@enduml'. Within code context,'@startuml' signals a start marker indicating flowcharts visualizations followed by successively accruing nodes & connection labels forming entire program logic in the form of edges and vertices, and '@enduml' marks conclusion of plantUML diagram generation. In essence, '_plantuml_str'_ holds PlantUML code string that encapsulates the entire visual representation for comprehending Python source code functionality more comprehensively.\n"
    },
    {
        "instruction": "Inputs to `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "source, target, init_method\n\nPurpose and Significance:\nIn the context given from 'get_code_graph.py', the function 'add_edge_with_data' plays a crucial role in creating edges between nodes representing relationships within the Python codebase. The inputs 'source', 'target', and 'init_method' are significant parameters for this function that influence its working in various manners to ensure comprehensive understanding of node connectivity during analysis:\n\n1. source: It signifies either a function or class method where a connection starts in terms of calling another element within the code graph. This input helps identify the originating point of an edge.\n\n2. target: Represents the destination node where the edge points to after being initiated from 'source'. This could be another function, class method, or even a class itself depending upon the nature of relationship in the Python program's logic flow.\n\n3. init_method (Optional): In certain scenarios, especially while dealing with classes and their methods, 'init_method' becomes necessary to clarify specific circumstances where edges need to be drawn differently compared to regular function calls or class methods without special meaning ('__init__'). In case the method in 'target' happens to be an initialization function (common in Python Classes), it denotes a constructor edge instead of an ordinary method call edge. By having this parameter as optional ('Optional[str]'), it ensures flexibility while processing diverse scenarios.\n\nThus, collectively these inputs 'source', 'target', and 'init_method' work together to define clear relationships within the Python codebase accurately using directed graphs created by networkx library through function 'add_edge_with_data'. These parameters contribute significantly towards mapping function calls, class method invocations, and constructors within a Python program to create an organized graphical representation of its logical structure.\n"
    },
    {
        "instruction": "Calls made in `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "class_method_details_lookup.get, function_details_lookup.get, G.add_edge, get_edge_data_from_details\n\nPurpose and Significance:\nIn the context of 'add_edge_with_data' function within the given Python script ('get_code_graph.py'), four major operations are invoked that play significant roles to construct a detailed representation of code relationships. These functions/calls serve distinct purposes contributing towards edge creation with data attached in the networkx DiGraph object ('G').\n\n1. class_method_details_lookup.get(init_method or target): This call helps retrieve method details for either initiated_method if passed else, tries fetching completely qualified named function from a previously extracted ClassMethodDetail lookup dictionary saved after tokenized source parsing and separation during initial function setup within the code_graph(). It ensures accurate edge connection between classes and methods.\n\n2. function_details_lookup.get(source): Similar to above but for functions instead of class methods, this call grabs source function details from a lookup dictionary built during code graph generation process.\n\n3. G.add_edge(source, target[, init_method]): This networkx Graph object method adds an edge between two nodes ('source' and 'target') in the graph with additional data obtained through other helper functions if present ('init_method'). It represents a connection between source element calling the target function or method.\n\n4. get_edge_data_from_details(target_details, source_details, target): This helper function is essential as it returns an 'edge_data' dictionary consisting of inputs used by called function/method ('target_inputs') and returned values from called ('target_returns') based on retrieved information for both target details (function/class method being called) and source element (calling entity). The data provided enriches edge properties, aiding in understanding flow control.\n\nThus, collectively these operations establish the necessary linkages within code graphs considering call relations with required inputs, outputs, and relevant function or method specifics that assist in constructing a detailed visualization of Python file's relationships.\n"
    },
    {
        "instruction": "Variables in `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "init_method, target, target_details, source_details, source\n\nPurpose and Significance:\nIn the context given from 'get_code_graph.py', specifically within the function 'add_edge_with_data', these variables hold crucial roles during edge creation in the code graph formation process. Let's break down each one:\n\n1. init_method: This variable serves as an optional parameter with a default value of None. Its primary purpose is to represent the initializer method for class instances when working with class-level method calls or self references (within try/except blocks). In most cases, this remains uninitialized in the function definition due to no such need; but when it encounters any initializer methods (__init__) while building edges within the code graph, this variable becomes significant.\n\n2. target: This variable represents the destination node or method name that receives an edge connection from another source node in the graph. It could be a function call target or class method invoked somewhere in the codebase. Its inclusion in the add_edge_with_data helps build edges reflecting dependencies among different program entities accurately.\n\n3. target_details: Target details are fetched either from 'function_details_lookup' (if 'target' is a function) or 'class_method_details_lookup' dictionary (for class methods). This information enables us to append additional edge data specific to the connected nodes based on their nature. Edge data might include inputs expected by target functions and outputs generated after execution ('target_inputs', 'target_returns').\n\n4. source_details: Similar to target_details, source_details extracts details about the source node where a call originates from either 'function_details_lookup' or 'class_method_details_lookup'. It helps add edge data pertaining to calls made by this source node ('call_inputs') while creating edges between nodes in the graph.\n\n5. source: This variable signifies the initiating node or method invoking another function/method call within the codebase. Its role is complementary to 'target', as it establishes a connection with the target node by adding an edge between them along with data related to the call originating from this node.\n\nTo sum up, variables init_method, target, target_details, source_details, and source collaboratively ensure proper mapping of edges in the code graph representing function/class method dependencies and their associated input-output relationships within Python programs.\n"
    }
]