[
    {
        "instruction": "Dependencies in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "'json', 'ast', 'typing', 'networkx'\n\nPurpose and Significance:\n1. json: Json library plays a crucial role in handling Python objects as strings during data exchange between functions within 'get_code_graph.py'. It ensures serialized data compatibility across different stages, enabling seamless integration of various data types into structured formats such as JSON while serializing/deserializing information like element identifiers and exceptions during recursive processing of code structures. This aids in manipulating dynamic inputs throughout the script.\n\n2. ast (Abstract Syntax Tree module): Ast is an integral part of Python's 'pyparse' library, providing access to parse tree representations of Python code. In this context, it extracts control flow trees from Abstract Syntax Tree nodes, allowing for detailed analysis and interpretation of complex programming logic for constructing a control flow diagram in an organized manner. It transforms programmatic syntax into more readable format useful for generating plantUML activity diagrams.\n\n3. typing: The 'typing' module facilitates advanced type hinting capabilities within Python codebase, enhancing clarity and accuracy of function signatures in 'get_code_graph.py'. It defines generic types like Union[str, dict], List[Union[str, dict]], Optional[str] for precise input/output handling across diverse data types encountered during execution - from strings to complex nested structures. This promotes type safety and readability throughout the script's operations.\n\n4. networkx: NetworkX library serves as a powerful package in the given codebase responsible for graph construction (nx.DiGraph) with nodes representing functions, classes, methods and edges connecting them according to dependencies within extracted file summaries. Its utilization creates directed graphs essential for visually comprehensible relations and efficient extraction of underlying call interactions during the overall program run.'''"
    },
    {
        "instruction": "Call code graph in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "{'nodes': ['code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'extract_control_flow_tree', 'reorganize_control_flow', 'reorganize_structure', 'get_plantUML_element', 'get_plantUML', 'get_code_graph', 'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', \"class_details['method_defs'].items\", 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'function_details_lookup.items', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'nodes_to_remove.append', 'type', 'control_flow_tree.append', 'ast.unparse', \"', '.join\", 'isinstance', 'except_block.append', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend', 'key.startswith', 'str'], 'edges': [{'source': 'code_graph', 'target': 'nx.DiGraph', 'target_inputs': []}, {'source': 'code_graph', 'target': 'function_details_lookup.update', 'target_inputs': ['function_def']}, {'source': 'code_graph', 'target': 'class_def.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_node', 'target_inputs': ['class_name', 'qualified_method_name', 'called', 'function_name']}, {'source': 'code_graph', 'target': \"class_details['method_defs'].items\", 'target_inputs': []}, {'source': 'code_graph', 'target': 'G.add_edge', 'target_inputs': ['class_name', 'qualified_method_name', 'source', 'target']}, {'source': 'code_graph', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'code_graph', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\", 'class_def.keys()', 'G.nodes']}, {'source': 'code_graph', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'code_graph', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source', 'target', 'source']}, {'source': 'code_graph', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target', 'target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'code_graph', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'code_graph', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'code_graph', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'code_graph', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'code_graph', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'code_graph', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'code_graph', 'target': 'function_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'add_edges_for_calls', 'target_inputs': ['func_name', \"details['calls']\", 'qualified_method_name', \"details['calls']\"], 'target_returns': []}, {'source': 'code_graph', 'target': 'class_method_details_lookup.items', 'target_inputs': []}, {'source': 'code_graph', 'target': 'G[source][target].update', 'target_inputs': ['edge_data']}, {'source': 'code_graph', 'target': 'G.edges.data', 'target_inputs': []}, {'source': 'code_graph', 'target': 'nodes_to_remove.append', 'target_inputs': ['node']}, {'source': 'get_edge_data_from_details', 'target': 'target_details.get', 'target_inputs': [\"'inputs'\", \"'returns'\", '[]']}, {'source': 'get_edge_data_from_details', 'target': 'list', 'target_inputs': [\"set(target_details.get('returns', []))\"]}, {'source': 'get_edge_data_from_details', 'target': 'set', 'target_inputs': [\"target_details.get('returns', [])\"]}, {'source': 'add_edge_with_data', 'target': 'class_method_details_lookup.get', 'target_inputs': ['init_method or target', 'source']}, {'source': 'add_edge_with_data', 'target': 'function_details_lookup.get', 'target_inputs': ['target', 'source']}, {'source': 'add_edge_with_data', 'target': 'G.add_edge', 'target_inputs': ['source', 'target']}, {'source': 'add_edge_with_data', 'target': 'get_edge_data_from_details', 'target_inputs': ['target_details', 'source_details', 'target'], 'target_returns': ['edge_data']}, {'source': 'add_edges_for_calls', 'target': 'list', 'target_inputs': ['class_def.keys()']}, {'source': 'add_edges_for_calls', 'target': 'class_def.keys', 'target_inputs': []}, {'source': 'add_edges_for_calls', 'target': 'called.split', 'target_inputs': [\"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.startswith', 'target_inputs': [\"'self.'\"]}, {'source': 'add_edges_for_calls', 'target': 'called.replace', 'target_inputs': [\"'self.'\", \"''\"]}, {'source': 'add_edges_for_calls', 'target': 'source_name.split', 'target_inputs': [\"'.'\", \"'.'\"]}, {'source': 'add_edges_for_calls', 'target': 'add_edge_with_data', 'target_inputs': ['source_name', 'fully_qualified_name', 'source_name', 'called', 'source_name', 'called', 'init_method', 'source_name', 'called'], 'target_returns': []}, {'source': 'add_edges_for_calls', 'target': 'G.add_node', 'target_inputs': ['called']}, {'source': 'extract_control_flow_tree', 'target': 'type', 'target_inputs': ['node']}, {'source': 'extract_control_flow_tree', 'target': 'control_flow_tree.append', 'target_inputs': ['ast.unparse(node)', '{key: value}', '{key: value}', '{key: value}', '{key: value}', '{key: value}', '{key: value}', 'if_block', 'control_flow_dict', 'ast.unparse(node)']}, {'source': 'extract_control_flow_tree', 'target': 'ast.unparse', 'target_inputs': ['node', 'arg', 'node.test', 'node.target', 'node.iter', 'item', 'node.value', 'node.test', 'orelse[0].test', 'handler.type', 'handler.name', 'node']}, {'source': 'extract_control_flow_tree', 'target': \"', '.join\", 'target_inputs': ['[ast.unparse(arg) for arg in node.args.args]', '[ast.unparse(item) for item in node.items]']}, {'source': 'extract_control_flow_tree', 'target': 'extract_control_flow_tree', 'target_inputs': ['node.body', 'node.body', 'node.body', 'node.body', 'node.body', 'node.body', 'orelse[0].body', 'orelse', 'node.body', 'handler.body', 'node.orelse', 'node.finalbody'], 'target_returns': ['control_flow_tree']}, {'source': 'extract_control_flow_tree', 'target': 'isinstance', 'target_inputs': ['orelse[0]', 'ast.If', 'handler.name', 'ast.Name']}, {'source': 'extract_control_flow_tree', 'target': 'except_block.append', 'target_inputs': ['{key: value}']}, {'source': 'reorganize_control_flow', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_control_flow', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_control_flow', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_control_flow', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_control_flow', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_control_flow', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_control_flow', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_control_flow', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'reorganize_control_flow', 'target': 'reorganize_structure', 'target_inputs': ['control_flow_structure', 'starting_points'], 'target_returns': ['organized']}, {'source': 'reorganize_structure', 'target': 'set', 'target_inputs': []}, {'source': 'reorganize_structure', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'element', 'str']}, {'source': 'reorganize_structure', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'reorganize_structure', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'reorganize_structure', 'target': 'json.dumps', 'target_inputs': ['element', 'elem']}, {'source': 'reorganize_structure', 'target': 'organized.append', 'target_inputs': ['element', 'element']}, {'source': 'reorganize_structure', 'target': 'seen.add', 'target_inputs': ['element_id']}, {'source': 'reorganize_structure', 'target': 'organized.extend', 'target_inputs': ['remaining']}, {'source': 'get_plantUML_element', 'target': 'isinstance', 'target_inputs': ['element', 'dict', 'value', 'list', 'element', 'str']}, {'source': 'get_plantUML_element', 'target': 'next', 'target_inputs': ['iter(element)']}, {'source': 'get_plantUML_element', 'target': 'iter', 'target_inputs': ['element']}, {'source': 'get_plantUML_element', 'target': 'key.startswith', 'target_inputs': [\"'def '\", \"'async def '\", \"'class '\", \"'if '\", \"'for '\", \"'while '\", \"'asyncfor '\", \"'try '\", \"'except '\", \"'def '\", \"'class '\", \"'if '\", \"'for '\", \"'while '\", \"'asyncfor '\", \"'try '\", \"'except '\"]}, {'source': 'get_plantUML_element', 'target': 'get_plantUML_element', 'target_inputs': ['child', 'inner_indentation'], 'target_returns': ['plantuml_str']}, {'source': 'get_plantUML', 'target': 'get_plantUML_element', 'target_inputs': ['element', \"'  '\"], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'code_graph', 'target_inputs': ['file_summary'], 'target_returns': [\"{'nodes': nodes, 'edges': edges}\", 'edge_data']}, {'source': 'get_code_graph', 'target': 'extract_control_flow_tree', 'target_inputs': ['file_ast.body'], 'target_returns': ['control_flow_tree']}, {'source': 'get_code_graph', 'target': 'reorganize_control_flow', 'target_inputs': ['entire_code_graph', 'control_flow_tree'], 'target_returns': ['reorganize_structure(control_flow_structure, starting_points)', 'organized']}, {'source': 'get_code_graph', 'target': 'get_plantUML', 'target_inputs': ['control_flow_structure'], 'target_returns': ['plantuml_str']}, {'source': 'get_code_graph', 'target': 'str', 'target_inputs': ['e', 'e']}]}"
    },
    {
        "instruction": "Functions in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "'code_graph', 'get_edge_data_from_details', 'add_edge_with_data', 'add_edges_for_calls', 'extract_control_flow_tree', 'reorganize_control_flow', 'reorganize_structure', 'get_plantUML_element', 'get_plantUML', 'get_code_graph'\n\nPurpose and Significance:\n1. code_graph: Serves as the main module handling a code graph creation based on file summaries with its dependency structures extracted for functions/classes in the form of NodeXL's directed graph ('nx.DiGraph'). This function defines node associations alongside processing function and method call details by retrieving appropriate information from related dictionaries within file_summary input. Its output consists of nodes and edges representing relationships in the code as a structured dictionary format.\n   - Significance: Enables visualization of software architecture through graph representation for better understanding of code dependencies among functions, methods, and classes.\n\n2. get_edge_data_from_details: Derives edge data from target method details using source method details obtained from function/class lookup dictionaries ('function_details_lookup', 'class_method_details_lookup'). Returns a dictionary comprising source inputs ('target_inputs') and targeted return values ('target_returns') linked with an edge connection.\n   - Significance: Gathers information to attach essential details (like arguments) related to each relationship edge for code graph understanding.\n\n3. add_edge_with_data: Constructs edges between nodes within the code graph by incorporating edge data generated through 'get_edge_data_from_details'. This function adds nodes from function/class method lookup sources ('function_details', 'class_method_details') into the directed graph.\n   - Significance: Connects functions/methods according to their dependencies, making clearer relationships among different parts of the code structure.\n\n4. add_edges_for_calls: Processes calls made by given nodes/elements (specifically function names), refines edges, and updates nodes as per dependency hierarchy within graph formats ('call_defs'). It supports a deeper analysis of nested structures present in source method call connections.\n   - Significance: Illustrates methodologies and interaction details in Python functions that form crucial connections during code interpretation.\n\n5. extract_control_flow_tree: Extracts control flow trees from Abstract Syntax Tree (AST) nodes converting them into a list of nested dictionaries or strings representing various Python programming elements.\n   - Significance: Provides an organized representation of program execution flow for better comprehension and debugging purposes.\n\n6. reorganize_control_flow: Reorders extracted control flow structure ('control_flow_tree') to align with code graph starting points by traversing recursively through each element. Output is a restructured list of elements in a logical order.\n   - Significance: Improves readability by arranging control flow according to main functions initiating certain branches of program logic flows within a clear hierarchical representation.\n\n7. reorganize_structure (particular to reorganize_control_flow): Iterates each element from a control flow structure list recursively and filters starting points matching the code graph nodes ('starting_points'). Output is an organized set of elements that can be easily followed in execution order.\n   - Significance: Streamlines complex nested structures for easier understanding of program flow within visualization tools like plantUML.\n\n8. get_plantUML_element: Generates plantUML visualizations for each element considering indentation levels ('indentation') from the control flow structure list obtained earlier.\n   - Significance: Visualizes Python code elements in a graphical format, making it easier to understand program flow through diagrammatic representation.\n\n9. get_plantUMLe: Creates an overall plantUML activity diagram incorporating entire control flow structure ('control_flow_structure') generated from previous functions.\n   - Significance: Provides a comprehensive view of the software's workflow for debugging and documentation purposes in visual form.\n\n10. get_code_graph: Consolidates all functionalities by combining code graph creation with control flow extraction ('extract_control_flow_tree') and plantUML generation ('get_plantUMLe'). It takes file summary ('file_summary') along with Abstract Syntax Tree ('file_ast') as inputs. Outputs entire code graph, reorganized control flow structure, and plantUML representation in a tuple format.\n   - Significance: Offers a complete package of code analysis tools for software documentation and debugging purposes by combining various functionalities into one function call."
    },
    {
        "instruction": "1) Describe the overall Purpose and Processing Approach of Python file: `py2dataset\\get_code_graph.py`; 2) Define API Signatures for each applicable Function and Class Method; 3) Derive Functional Requirements to specify the code's behavior and purpose; 4) Explain what each variable does in the code.",
        "input": "```python\n\"\"\"\nRequirements\n[req01] The code_graph function performs the following:\n        a. Extracts the function and class method details from the file summary.\n        b. Creates a lookup dictionary for function and class method details.\n        c. Creates a directed graph with nodes and edges representing the relationships in the code.\n        d. Adds edges for function and class method calls.\n        e. Adds edge data to edges.\n        f. Returns a dictionary with nodes and edges representing the relationships in the code.\n[req02] The extract_control_flow_tree function performs the following:\n        a. Extracts control flow tree from AST.\n        b. Returns control flow tree.\n[req03] The reorganize_control_flow function performs the following:\n        a. Gets starting points from the code graph.\n        b. Reorganizes the control flow structure recursively.\n        c. Returns reorganized control flow structure.\n[req04] The get_plantUML_element function performs the following:\n        a. Gets plantUML code for each element.\n        b. Returns plantUML code for each element.\n[req05] The get_plantUML function performs the following: \n        a. Gets plantUML code for entire file.\n        b. Returns plantUML code for entire file.\n[req06] The get_code_graph function performs the following:\n        a. Gets the entire code graph\n        b. Gets the control flow structure\n        c. Gets the plantUML code\n        d. Returns entire code graph, control flow structure and plantUML code\n\"\"\"\nimport ast\nimport json\nfrom typing import Dict, List, Optional, Union\nimport networkx as nx\n\n\ndef code_graph(\n    file_summary: Dict[str, Union[Dict, str]],\n) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n\n    # Create lookup dictionaries for function and class method details\n    function_details_lookup = {}\n    for function_def in file_summary[\"function_defs\"]:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary[\"class_defs\"]:\n        for (\n            class_name,\n            class_details,\n        ) in class_def.items():  # Extract class name and details\n            G.add_node(class_name)  # Add class as a graph node\n            for method_name, method_details in class_details[\"method_defs\"].items():\n                qualified_method_name = (\n                    f\"{class_name}.{method_name}\"  # Create method fully qualified name\n                )\n                G.add_node(qualified_method_name)  # Add method as a graph node\n                class_method_details_lookup[\n                    qualified_method_name\n                ] = method_details  # Store method details\n                G.add_edge(\n                    class_name, qualified_method_name\n                )  # Add edge from class to method\n\n    # Helper function to extract edge data from target details\n    def get_edge_data_from_details(\n        target_details: dict, source_details: dict, target: str\n    ) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data[\"target_inputs\"] = target_details.get(\"inputs\")\n            edge_data[\"target_returns\"] = list(set(target_details.get(\"returns\", [])))\n        if (\n            source_details\n            and \"call_inputs\" in source_details\n            and target in source_details[\"call_inputs\"]\n        ):\n            edge_data[\"target_inputs\"] = source_details[\"call_inputs\"][target]\n        return edge_data\n\n    # Helper function to add edge with data\n    def add_edge_with_data(\n        source: str, target: str, init_method: Optional[str] = None\n    ) -> None:\n        target_details = class_method_details_lookup.get(\n            init_method or target\n        ) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        G.add_edge(\n            source,\n            target,\n            **get_edge_data_from_details(target_details, source_details, target),\n        )\n\n    # Helper function to add edges for function or class method calls\n    def add_edges_for_calls(source_name, calls):\n        class_names = [\n            list(class_def.keys())[0] for class_def in file_summary[\"class_defs\"]\n        ]\n        for called in calls:\n            called_class_name = called.split(\".\")[0]\n            if called.startswith(\"self.\"):\n                method_name = called.replace(\"self.\", \"\")\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if (\n                called in function_details_lookup\n                or called in class_method_details_lookup\n                or f\"{source_name.split('.')[0]}.{called}\"\n                in class_method_details_lookup\n            ):\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f\"{called}.__init__\"\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n\n    # Add function nodes to graph and edges for function calls\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details[\"calls\"])\n\n    # Add edges for method calls\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details[\"calls\"])\n\n    # Add edge data to edges and create node and edges to return\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(\n            target\n        ) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(\n            source\n        ) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [\n        {\"source\": edge[0], \"target\": edge[1], **edge[2]} for edge in G.edges.data()\n    ]\n\n    # remove any nodes that are not either a source of an edge or a target of an edge\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge[\"source\"] for edge in edges] and node not in [\n            edge[\"target\"] for edge in edges\n        ]:\n            nodes_to_remove.append(node)\n\n    return {\"nodes\": nodes, \"edges\": edges}\n\n\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {\n        ast.FunctionDef: \"def\",\n        ast.AsyncFunctionDef: \"def\",\n        ast.ClassDef: \"class\",\n        ast.While: \"while\",\n        ast.For: \"for\",\n        ast.AsyncFor: \"for\",\n        ast.With: \"with\",\n        ast.AsyncWith: \"with\",\n        ast.Return: \"return\",\n        ast.If: \"if\",\n        ast.Try: \"try\",\n    }\n\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n\n        if keyword == \"def\":\n            args_str = \", \".join([ast.unparse(arg) for arg in node.args.args])\n            key = f\"def {node.name}({args_str})\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"class\":\n            key = f\"class {node.name}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"while\":\n            key = f\"while {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"for\":\n            key = f\"for {ast.unparse(node.target)} in {ast.unparse(node.iter)}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"with\":\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == \"return\":\n            key = \"return\"\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == \"if\":\n            key = f\"if {ast.unparse(node.test)}\"\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f\"elif {ast.unparse(orelse[0].test)}\"\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = \"else\"\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == \"try\":\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else \"\"\n                h_name = (\n                    ast.unparse(handler.name)\n                    if isinstance(handler.name, ast.Name)\n                    else \"\"\n                )\n                key = f\"except {h_type} as {h_name}:\"\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {\"try\": try_block, \"except\": except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict[\"else\"] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict[\"finally\"] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n\n    return control_flow_tree\n\n\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    # Get starting points from the code graph as those\n    targets = [edge[\"target\"] for edge in code_graph[\"edges\"]]\n    starting_points = [node for node in code_graph[\"nodes\"] if node not in targets]\n\n    # Define a function to reorganize the structure recursively\n    def reorganize_structure(structure, start_points):\n        organized, seen = [], set()\n\n        # Iterate through each start point and find matching elements in structure\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))  # Get the first key of the dictionary\n                    if (\n                        start in key\n                    ):  # Add element if it matches the start point and hasn't been seen\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif (\n                    isinstance(element, str) and start in element\n                ):  # Handle string elements\n                    organized.append(element)\n\n        # Append elements not included in the organized list\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n\n    # Reorganize the control flow structure recursively\n    return reorganize_structure(control_flow_structure, starting_points)\n\n\ndef get_plantUML_element(element, indentation=\"\"):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = \"\"\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith(\"def \") or key.startswith(\"async def \"):\n            plantuml_str += f\"{indentation}def {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}class {value} {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"if \"):\n            plantuml_str += f\"{indentation}if ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif (\n            key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n        ):\n            plantuml_str += f\"{indentation}while ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"try \"):\n            plantuml_str += f\"{indentation}try {{\\n\"\n            inner_indentation = indentation + \"  \"\n        elif key.startswith(\"except \"):\n            plantuml_str += f\"{indentation}catch ({value}) {{\\n\"\n            inner_indentation = indentation + \"  \"\n        else:\n            plantuml_str += f\"{indentation}:{key};\\n\"\n            inner_indentation = indentation\n\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n\n        if key.startswith(\"def \") or key.startswith(\"class \"):\n            plantuml_str += f\"{indentation}}}\\n\"\n        elif (\n            key.startswith(\"if \")\n            or key.startswith(\"for \")\n            or key.startswith(\"while \")\n            or key.startswith(\"asyncfor \")\n            or key.startswith(\"try \")\n            or key.startswith(\"except \")\n        ):\n            plantuml_str += f\"{indentation}}}\\n\"\n\n    elif isinstance(element, str):\n        plantuml_str += f\"{indentation}:{element};\\n\"\n\n    return plantuml_str\n\n\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = \"@startuml\\n\"\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, \"  \")\n    plantuml_str += \"end\\n@enduml\"\n    return plantuml_str\n\n\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(\n            entire_code_graph, control_flow_tree\n        )\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n\n    #print('file_summary:', file_summary)\n    #print('entire_code_graph:', entire_code_graph)\n    #print('control_flow_structure:', control_flow_structure)\n    #print('plantUML:', plantUML)\n\n    return entire_code_graph, control_flow_structure, plantUML\n\n```",
        "output": "1) Overview and Approach of get_code_graph.py:\nThe 'get_code_graph.py' file primarily focuses on generating a graph representation of software code details extracted from given file summaries with NodeXL's networkx library alongside producing plantUML representations of its corresponding control flow tree visualization for enhanced readability. Its purpose consists of creating dictionary-structured files based upon functions and classes in terms of dependencies (NodeXL Directed Graph), extracting control flow trees from Abstract Syntax Tree (AST) nodes, reorganizing the control flow structure to match code graph starting points, and generating plantUML activity diagrams for each element.\n\n2) API Signatures with Inputs/Outputs:\na. `code_graph(file_summary: Dict[str, Union[Dict, str]] -> Dict[str, Union[List[str], Dict[str, List[str]]]:`\n- Processes file details stored in 'file_summary' dictionary containing function and class method definitions. It constructs a networkx Directed Graph (nx.DiGraph) with nodes representing functions, classes, and methods as well as edges signifying their relationships. Edge data is derived from target method details. Output returns nodes and edges representation of the code in formatted dictionary format.\nb. `get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:`\n- Retrieves edge data by extracting information from target method details given source method details. Returns a dictionary containing 'source inputs' and 'target returns'.\nc. `add_edge_with_data(source: str, target: str, init_method: Optional[str] ) -> None:`\n- Adds an edge with associated data to the graph by accessing function or class method details from lookup dictionaries.\nd. `add_edges_for_calls(source_name: str, calls: List[ast.AST]) -> None:`\n- Processes calls from given nodes/elements (function names for functions, methods), builds the edges and updates nodes according to dependency tree while connecting with proper function lookup sources in a directed graph format.\ne. `extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:`\n- Extracts control flow trees from Abstract Syntax Tree (AST) nodes into list form containing nested dictionaries and strings representing Python code elements.\nf. `reorganize_control_flow(code_graph: Dict[str, Union[List[str], Dict[str, List[str]], control_flow_structure: List[Union[str, dict]]) -> List[dict]:`\n- Reorders the extracted control flow structure to match code graph starting points by traversing through each element recursively. Output is a reorganized list of elements.\ng. `get_plantUML_element(element: Union[dict, str, List[str]], indentation: str=\"\") -> str:`\n- Generates plantUML code for each element in the control flow structure with given indentation level. Returns plantUML representation of elements.\nh. `get_plantUML(control_flow_structure: List[Union[str, dict]]) -> str:`\n- Produces overall plantUML activity diagram code from the entire control flow structure list obtained earlier.\ni. `get_code_graph(file_summary: Dict[str, Union[Dict, str], file_ast: ast.AST) -> Tuple[Dict[str, List[Union[str, dict]], List[Union[str, dict]], str:`\n- Combines code graph generation with control flow extraction and plantUML creation for given 'file_summary' dictionary and Abstract Syntax Tree ('file_ast'). Outputs entire code graph, reorganized control flow structure, and plantUML representation as a tuple.\n\n3) Functional Requirements Breakdown:\n- Function `code_graph()` focuses on parsing file summary for class methods & functions (with node creations), determining call relations in graphs. Edge details come from lookup dictionaries (class/function).\n- `get_edge_data_from_details()` derives edge data from target method info while handling inputs and returns related to sources.\n- `add_edge_with_data()` establishes directed edges using the gathered data within function details lookup sources/targets.\n- `add_edges_for_calls()` navigates call nodes recursively based on functions and class dependencies, constructing edge relations accordingly.\n- `extract_control_flow_tree()` breaks down AST into control flow structure by parsing nodes & generating dictionary tree.\n- `reorganize_control_flow()` sorts control flow structure elements in a way that matches the code graph's starting points for readability purposes.\n- `get_plantUML_element()` creates plantUML visualization of each element considering indentation levels.\n- `get_plantUML()` assembles comprehensive plantUML activity diagrams from the reorganized control flow structure.\n- `get_code_graph()` consolidates all these processes, merging code graph creation with control flow extraction and plantUML generation for a given file summary & AST input.\n\n4) Variables Description:\na. G (networkx Directed Graph): Represents the code relationships with nodes for classes, methods and functions\nb. function_details_lookup / class_method_details_lookup (dictionary): Stored data associated to specific elements/keys as detailed summary nodes ('class_defs' & 'function_defs')\nc. nodes / edges: Used within code graph construction, holding node list and edge data for representation output\nd. source / target / init_method / fully_qualified_name / keyword / node_type / element / remaining / organized / starting_points / targets / control_flow_tree / indentation / value / try_block / except_block / else_block / finally_block: Intermediate variables during function execution\ne. nodes_to_remove: Removes unnecessary nodes without graph connections\nf. node_keywords_map (dict): Maps Python keywords to their respective types ('def', 'class', etc.)\ng. control_flow_structure: Control flow tree list from AST traversal\nh. plantuml_str / indentation: String buffers for plantUML code generation"
    },
    {
        "instruction": "Inputs to `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'file_summary'\n\nPurpose and Significance:\nIn the 'get_code_graph.py' script, the parameter 'file_summary' holds critical significance within the function 'code_graph'. This dictionary contains vital details extracted from an analyzed Python file serving as fundamental inputs to build the code graph representation using NetworkX Directed Graph library. Primarily composed of keys like 'function_defs', representing functions and 'class_defs' capturing class definitions along with their associated methods. These components help create node entities in the graph structure, establishing relationships between them through function calls or inheritance. In essence, 'file_summary' acts as a foundation for understanding software code dependencies and constructing an organized representation of its internal logic flow."
    },
    {
        "instruction": "Docstring of `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code."
    },
    {
        "instruction": "Calls made in `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'nx.DiGraph', 'function_details_lookup.update', 'class_def.items', 'G.add_node', 'class_details['method_defs'].items', 'G.add_edge', 'target_details.get', 'list', 'set', 'class_method_details_lookup.get', 'function_details_lookup.get', 'get_edge_data_from_details', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'add_edge_with_data', 'function_details_lookup.items', 'add_edges_for_calls', 'class_method_details_lookup.items', 'G[source][target].update', 'G.edges.data', 'nodes_to_remove.append'\n\nPurpose and Significance:\nThe purpose of `code_graph` primarily centers around building a structural representation of a given file's code details using NetworkX's directed graph (nx.DiGraph) to visualize relationships between functions, classes, and methods within it. This function plays a crucial role in software documentation by mapping dependencies among these elements through various calls made internally:\n\n1. `nx.DiGraph()`: Initializes an empty Directed Graph object for storing nodes (classes/functions/methods) and edges representing their connections.\n2. `function_details_lookup.update(function_def)` updates lookup dictionary by integrating function details within its storage container while constructing a code graph later. Similar treatment applies to `class_method_details_lookup`.\n3. `for class_def in file_summary[\"class_defs\"]:` Iterates through class definitions for adding classes as nodes into the graph using `G.add_node()`.\n4. `for method_name, method_details in class_details[\"method_defs\"].items():` Extracts methods under each class and adds them as nodes too while creating edges from parent classes to child methods.\n5. `add_edge_with_data(source_name, called)` links functions or methods with their corresponding sources using extracted data derived from function/class details lookup dictionaries.\n6. `for edge in G.edges:` Processes graph edges and appends relevant data to them by calling `get_edge_data_from_details()`.\n7. `nodes = list(G.nodes)` & `edges = [{\"source\": edge[\"source\"], \"target\": edge[1]} for edge in G.edges.data():` prepare nodes and edges for returning the final code graph dictionary output format.\n8. `nodes_to_remove = []` stores unwanted nodes outside connections identified from `code_graph[\"edges\"] iteration.\n9. `nodes_to_remove.append(node)` eliminates these nodes from further processing.\n\nThe subsequent calls are involved in traversing and populating the graph with details:\n10. `function_details_lookup.items()` & `class_method_details_lookup.items()` fetch function/class method pairs for edge creation purposes.\n11. `add_edges_for_calls(func_name, details[\"calls\"])` examines calls made within functions and methods recursively adding edges based on their dependencies in the code structure.\n12. `G.add_node(called)` creates nodes when necessary call targets are found outside initial function/class definitions.\n13. `class_method_details_lookup.get(target)` & `function_details_lookup.get(source)` retrieve details for edge data extraction during call connections.\n14. `get_edge_data_from_details(target_details, source_details, target)` fetches input/return values to enrich edges with information related to methods calls.\n15. `G[source][target].update(edge_data)` updates edge data with extracted details from method calls.\n16. `nodes_to_remove.append(node)` eliminates redundant nodes if not serving as sources or targets of edges within the graph.\n\nThe primary purpose of these actions is to establish a coherent relationship model of software code dependencies for easy visualization and understanding of methodologies employed in `code_graph`."
    },
    {
        "instruction": "Variables in `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'target_details', 'called_class_name', 'edge_data', 'edges', 'class_method_details_lookup', 'nodes', 'source_details', 'nodes_to_remove', 'function_details_lookup', 'G', 'init_method', 'fully_qualified_name', 'init_method_name', 'class_names', 'qualified_method_name', 'file_summary', 'method_name'\n\nPurpose and Significance:\nIn the `code_graph` function within get_code_graph.py, several variables play crucial roles to achieve its objective of constructing a dictionary representation of file details with nodes and edges representing relationships in the code. These variables are as follows:\n\n1. **target_details**: Holds target method details extracted from lookup dictionaries during edge data extraction for further processing. It helps determine input/output parameters associated with each method call in the code graph creation process.\n\n2. **called_class_name**: Used when dealing with class methods, indicating the class name involved in a particular function invocation for qualifying fully qualified names. This assists in building directed edges correctly within the graph.\n\n3. **edge_data**: Stores collected data for edges connecting nodes after extracting relevant information from source and target method details. It helps to represent each edge with its specific attributes like input requirements and return values.\n\n4. **edges**: Represents a list of edges in the code graph format containing source, target pairs along with their associated data gathered through `get_edge_data_from_details()`.\n\n5. **class_method_details_lookup**: A dictionary that stores detailed information about class methods extracted from file summary data for effective node addition and edge establishment in the directed graph (nx.DiGraph).\n\n6. **nodes**: Represents nodes of the code graph that act as central points connected through edges signifying dependencies between functions, classes, or their respective methods. These are crucial components while formulating graph structure.\n\n7. **source_details**: Stores details about a specific source element to match it with target elements and obtain relevant information during edge generation within `code_graph`.\n\n8. **nodes_to_remove**: A list of nodes that do not serve as either an edge source or target, eventually removed from the graph for better representation accuracy.\n\n9. **function_details_lookup**: Similar to class_method_details_lookup but dedicated to function definitions in the file summary. It helps identify and connect functions within the code graph construction process.\n\n10. **G** (networkx DiGraph): This variable represents the core data structure for creating a directed graph containing nodes (functions, classes, methods) and edges between them according to their dependencies. NetworkX library is used for graph generation purposes.\n\n11. **init_method**: Temporary variable when working with class method calls, referring to the initialization method (__init__) if found in class definitions.\n\n12. **fully_qualified_name**: Composed during class method invocation identification by combining class name and method name for proper graph edge creation.\n\n13. **init_method_name**: Refers to the initialization method name within a class definition when required for edge formation in the directed graph.\n\n14. **class_names**: Derived list of classes from file summary serving as an auxiliary data structure during class identification while examining node types and dependencies.\n\n15. **qualified_method_name**: Represents a fully qualified method name to distinguish function or class methods for appropriate graph connection purposes.\n\n16. **file_summary**: Original input dictionary containing details about file extracted functions and classes serving as the primary source of information for code graph construction.\n\n17. **method_name**: Used when dealing with function definitions, identifying individual method names within function lookup dictionaries."
    },
    {
        "instruction": "Returns from `code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef code_graph(file_summary: Dict[str, Union[Dict, str]]) -> Dict[str, Union[List[str], Dict[str, List[str]]]]:\n    \"\"\"\n    Create a dictionary representation of file details.\n    Args:\n        file_summary: Dict[str, Union[Dict, str]]: The details extracted from the file.\n    Returns:\n        dict: A dictionary with nodes and edges representing the relationships in the code.\n    \"\"\"\n    G = nx.DiGraph()\n    function_details_lookup = {}\n    for function_def in file_summary['function_defs']:\n        function_details_lookup.update(function_def)\n    class_method_details_lookup = {}\n    for class_def in file_summary['class_defs']:\n        for class_name, class_details in class_def.items():\n            G.add_node(class_name)\n            for method_name, method_details in class_details['method_defs'].items():\n                qualified_method_name = f'{class_name}.{method_name}'\n                G.add_node(qualified_method_name)\n                class_method_details_lookup[qualified_method_name] = method_details\n                G.add_edge(class_name, qualified_method_name)\n\n    def get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n        edge_data = {}\n        if target_details:\n            edge_data['target_inputs'] = target_details.get('inputs')\n            edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n        if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n            edge_data['target_inputs'] = source_details['call_inputs'][target]\n        return edge_data\n\n    def add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n        target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n\n    def add_edges_for_calls(source_name, calls):\n        class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n        for called in calls:\n            called_class_name = called.split('.')[0]\n            if called.startswith('self.'):\n                method_name = called.replace('self.', '')\n                fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n                if fully_qualified_name in class_method_details_lookup:\n                    add_edge_with_data(source_name, fully_qualified_name)\n                    continue\n            if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n                add_edge_with_data(source_name, called)\n            elif called_class_name in class_names:\n                init_method = None\n                init_method_name = f'{called}.__init__'\n                if init_method_name in class_method_details_lookup:\n                    init_method = init_method_name\n                add_edge_with_data(source_name, called, init_method)\n            else:\n                G.add_node(called)\n                add_edge_with_data(source_name, called)\n    for function_name in function_details_lookup:\n        G.add_node(function_name)\n    for func_name, details in function_details_lookup.items():\n        add_edges_for_calls(func_name, details['calls'])\n    for qualified_method_name, details in class_method_details_lookup.items():\n        add_edges_for_calls(qualified_method_name, details['calls'])\n    for edge in G.edges:\n        source, target = edge\n        target_details = function_details_lookup.get(target) or class_method_details_lookup.get(target)\n        source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n        edge_data = get_edge_data_from_details(target_details, source_details, target)\n        G[source][target].update(edge_data)\n    nodes = list(G.nodes)\n    edges = [{'source': edge[0], 'target': edge[1], **edge[2]} for edge in G.edges.data()]\n    nodes_to_remove = []\n    for node in nodes:\n        if node not in [edge['source'] for edge in edges] and node not in [edge['target'] for edge in edges]:\n            nodes_to_remove.append(node)\n    return {'nodes': nodes, 'edges': edges}\n```",
        "output": "'{'nodes': nodes, 'edges': edges}', 'edge_data'\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py', the `code_graph` function plays a crucial role in generating structured data representing relationships within software source codes utilizing Python networkX directed graphs ('nodes' and 'edges') format extracted from a supplied 'file_summary' object. These significant outputs allow easier interpretation by visualizing program functionalities, interconnections, dependencies, and relationships among defined classes/methods through node creations correspondingly in a NetworkX graph layout. More specifically, the returns comprise of two main sections as follows:\n\n1. 'nodes': This return value holds a list containing all detected nodes from the code analysis process, including function names, class names, methods etc., which act as vertices in the constructed graphical representation. These nodes signify various elements within the program flow and help comprehend their existence in the codebase.\n\n2. 'edges': A list of dictionaries containing edge information with 'source' and 'target' keys along with additional data related to method calls between them ('edge[2]'). Edge attributes depict the interactions among functions or methods, assisting users to understand the program flow directionality and interdependencies better. Additionally, 'edge_data' carries critical input-output information linked with a source element connected to a target method for improved code understanding.\n\nCombinedly, ['nodes', 'edges'] outputs deliver comprehensive insight into a graphical interpretation of function and class method associations, thereby assisting developers in grasping complex dependencies more effectively while debugging or maintaining software codes. The additional variable 'edge_data' facilitates the depiction of essential method invocations during execution which are necessary to trace for error rectification purposes or improving readability during reviewals."
    },
    {
        "instruction": "Inputs to `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'nodes'\n\nPurpose and Significance:\nIn 'get_code_graph.py', within the function `extract_control_flow_tree`, the input argument named 'nodes' holds significant value as it represents Abstract Syntax Tree (AST) nodes retrieved from Python code analysis. These nodes serve as building blocks for constructing the control flow tree by traversing through different programming elements such as functions ('def', classes ('class'), loops ('for', 'while'), exception handling ('try', 'except'), and other statements like 'if'. This input is crucial to extracting a hierarchical representation of Python code's logical flow in terms of nested dictionaries and strings. The extracted control flow tree aids understanding program execution sequences better than linear syntax viewing. In the context of `extract_control_flow_tree`, nodes function as key entities from where subsequent processes initiate control flow extraction. Their breakdown results in comprehending how Python statements interrelate, enabling further manipulation and visualization through plantUML activity diagrams for enhanced readability."
    },
    {
        "instruction": "Docstring of `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree"
    },
    {
        "instruction": "Calls made in `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'type', 'control_flow_tree.append', 'ast.unparse', '', '.join', 'extract_control_flow_tree', 'isinstance', 'except_block.append'\n\nPurpose and Significance:\nIn the context of `extract_control_flow_tree`, these prominent calls hold particular importance while transforming Abstract Syntax Tree nodes into a structured control flow representation. Their roles are as follows:\n\n1. 'type': This built-in Python function is utilized within conditional statements to identify node types during traversal in the Abstract Syntax Tree (AST). It helps categorize different code elements like functions, classes, loops, exceptions, etc., allowing appropriate handling and formatting of plantUML visualizations later on.\n\n2. 'control_flow_tree.append': This list append operation adds each processed element into the control flow tree structure as it traverses through AST nodes. It stores various Python code elements such as functions ('def'), classes ('class'), loops ('if', 'while', 'for', 'asyncfor'), exceptions ('try', 'except') and strings in a nested dictionary format.\n\n3. 'ast.unparse': This function converts abstract syntax tree nodes into human-readable Python code strings by traversing the AST data structure. It facilitates capturing node content for generating plantUML diagrams later on.\n\n4. '.join': String concatenation method employed when handling loop structures ('for', 'while', 'asyncfor') in the control flow tree formation process. It merges elements into a single string separated by commas to represent iterable constructs like loops' initialization, target variables, and iteration expressions accurately.\n\n5. `extract_control_flow_tree`: Serves as the primary function under discussion here. It recursively traverses AST nodes, extracting control flow structures from Python code elements into a list containing nested dictionaries representing distinct programming constructs in hierarchical form for plantUML activity diagram generation purposes.\n\n6. 'isinstance': A built-in Python method determining if an object is an instance of a given class (or subclass thereof). It verifies whether the current traversed node matches expected types like exceptions ('except') to append them into respective categories in control flow structure correctly.\n\n7. 'except_block.append': Appends exception handling blocks within the control flow tree when encountered during AST traversal. This call adds 'catch' nodes with their associated details (exception type and handler name) into the control flow structure list for plantUML visualization generation."
    },
    {
        "instruction": "Variables in `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'if_block', 'key', 'try_block', 'control_flow_tree', 'nodes', 'except_block', 'node_type', 'keyword', 'h_name', 'node_keywords_map', 'else_block', 'orelse', 'args_str', 'control_flow_dict', 'value', 'finally_block', 'h_type'\n\nPurpose and Significance:\nIn the `extract_control_flow_tree` function within the get_code_graph.py script, several key variables are employed to traverse and shape the control flow structure extraction process from Abstract Syntax Tree (AST) nodes. These variables have crucial roles in breaking down Python code elements into a comprehensible tree format for further analysis:\n\n1. if_block & try_block: Temporary buffers used when handling conditional statements like 'if', 'while', or 'try' blocks during AST traversal. They store nested control flow structures to be appended later in the control flow tree list.\n2. control_flow_tree: The primary output variable holding the entire extracted and formatted control flow tree comprising nested dictionaries for each code element - creating an understandable Python control structure hierarchy representation.\n3. nodes: While not specific to extract_control_flow_tree(), this variable stores AST nodes required for traversal within the function scope. It is initially passed as an argument and helps identify distinct elements in the code flow.\n4. except_block & else_block: Similar to if_block and try_block, these buffers store exceptions handling ('except') and optional else statements respectively during AST traversal.\n5. node_type & keyword: Identify the type of current parsed element (e.g., 'def', 'class', etc.) alongside a string key beginning relevant for each specific syntax like 'if', 'while' while analyzing Abstract Syntax Tree nodes in the `extract_control_flow_tree`.\n6. h_name & h_type: Particularly seen during exception handling ('except') extraction from AST where they capture exception names ('h_name') and type information ('h_type').\n7. node_keywords_map: This dictionary maps Python keywords to their respective types, enabling the function to distinguish different control structures for better interpretation in code traversal.\n8. orelse: Representing the else clause associated with 'if' blocks (when present) that directs towards optional nested control flow sections to analyze.\n9. args_str: Temporarily joins argument list strings while generating Python function definitions ('def') during `code_graph` execution before passing it to `extract_control_flow_tree`.\n10. control_flow_dict: A dictionary created when handling 'try' blocks with nested exception sections, encapsulating both catch ('except') and finally blocks in one entity within the control flow tree structure.\n11. value & value (duplicate): Capture the extracted details for a specific element while parsing its nested children recursively through `get_plantUML_element` function call inside `extract_control_flow_tree`. If an element is not a dictionary ('if', 'while', etc.), these variables hold string representations of Python code snippets."
    },
    {
        "instruction": "Returns from `extract_control_flow_tree` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef extract_control_flow_tree(nodes: List[ast.AST]) -> List[Union[str, dict]]:\n    \"\"\"\n    Extract control flow tree from AST.\n    Args:\n        nodes: AST nodes\n    Returns:\n        control_flow_tree: control flow tree\n    \"\"\"\n    control_flow_tree = []\n    node_keywords_map = {ast.FunctionDef: 'def', ast.AsyncFunctionDef: 'def', ast.ClassDef: 'class', ast.While: 'while', ast.For: 'for', ast.AsyncFor: 'for', ast.With: 'with', ast.AsyncWith: 'with', ast.Return: 'return', ast.If: 'if', ast.Try: 'try'}\n    for node in nodes:\n        node_type = type(node)\n        if node_type not in node_keywords_map:\n            control_flow_tree.append(ast.unparse(node))\n            continue\n        keyword = node_keywords_map[node_type]\n        if keyword == 'def':\n            args_str = ', '.join([ast.unparse(arg) for arg in node.args.args])\n            key = f'def {node.name}({args_str})'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'class':\n            key = f'class {node.name}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'while':\n            key = f'while {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'for':\n            key = f'for {ast.unparse(node.target)} in {ast.unparse(node.iter)}'\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'with':\n            key = f\"with {', '.join([ast.unparse(item) for item in node.items])}\"\n            value = extract_control_flow_tree(node.body)\n            control_flow_tree.append({key: value})\n        elif keyword == 'return':\n            key = 'return'\n            value = [ast.unparse(node.value)] if node.value is not None else []\n            control_flow_tree.append({key: value})\n        elif keyword == 'if':\n            key = f'if {ast.unparse(node.test)}'\n            value = extract_control_flow_tree(node.body)\n            if_block = {key: value}\n            orelse = node.orelse\n            while orelse and isinstance(orelse[0], ast.If):\n                key = f'elif {ast.unparse(orelse[0].test)}'\n                value = extract_control_flow_tree(orelse[0].body)\n                if_block[key] = value\n                orelse = orelse[0].orelse\n            if orelse:\n                key = 'else'\n                value = extract_control_flow_tree(orelse)\n                if_block[key] = value\n            control_flow_tree.append(if_block)\n        elif keyword == 'try':\n            try_block = extract_control_flow_tree(node.body)\n            except_block = []\n            for handler in node.handlers:\n                h_type = ast.unparse(handler.type) if handler.type is not None else ''\n                h_name = ast.unparse(handler.name) if isinstance(handler.name, ast.Name) else ''\n                key = f'except {h_type} as {h_name}:'\n                value = extract_control_flow_tree(handler.body)\n                except_block.append({key: value})\n            control_flow_dict = {'try': try_block, 'except': except_block}\n            if node.orelse:\n                else_block = extract_control_flow_tree(node.orelse)\n                control_flow_dict['else'] = else_block\n            if node.finalbody:\n                finally_block = extract_control_flow_tree(node.finalbody)\n                control_flow_dict['finally'] = finally_block\n            control_flow_tree.append(control_flow_dict)\n        else:\n            control_flow_tree.append(ast.unparse(node))\n    return control_flow_tree\n```",
        "output": "'control_flow_tree'\n\nPurpose and Significance:\nThe 'extract_control_flow_tree' function within get_code_graph.py primarily focuses on extracting a control flow tree representation from Abstract Syntax Tree (AST) nodes encountered during Python code analysis. Its main objective is to organize Python code elements into a structured list containing nested dictionaries and strings, where each dictionary or string signifies various code segments. This process allows developers to comprehend program flow logically with detailed information on conditional statements, loops, exception handling blocks (try-catch), functions/methods definitions ('def', 'class'), etc., enabling better understanding of the overall algorithmic structure.\n\nThe function returns a list ['control_flow_tree'] consisting of these parsed elements in a hierarchical manner:\n1. Dictionary representation for Python keywords such as 'def' indicating function definition along with their nested contents. These dictionaries further hold key-value pairs with corresponding code snippets within curly braces ({}) and indentation levels ('if', 'while', 'for', 'try', 'except').\n2. Strings representing standalone statements or elements without any nested structure (':<statement>;').\n\nIn summary, the 'control_flow_tree' output serves as a visual aid for developers to analyze Python code flow by breaking down complex structures into comprehensible segments through nested dictionaries and strings in list format. This facilitates easy identification of sequential control flows while simplifying program analysis and debugging processes."
    },
    {
        "instruction": "Inputs to `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'element', 'indentation'\n\nPurpose and Significance:\nIn the context of 'get_plantUML_element' function within get_code_graph.py, the inputs 'element' and 'indentation' play crucial roles in generating PlantUML activity diagram representations for individual elements within a control flow structure extracted from Python source code. Their purposes are outlined as follows:\n\n1. 'element': This input represents each node or sub-component of the control flow tree that requires transformation into its respective PlantUML syntax within a structured formatted code fragment. When the get_plantUML_element is called upon either dictionaries generated by control_flow tree parsing, nested element values within or flat string type variables referring to instructions without internal complexities ('if', 'else', method calls - def, async def,'class'), each contributes a visual cue essential for drawing edges between diverse coding activities and data exchange mechanisms on a PlantUML activity diagram canvas. Depending on whether it is a dictionary (for nested control structures like 'def', 'class', 'try'/'except') or simple strings (like directives - 'if', 'return', method names), the function renders its plantUML depiction with distinct notation using 'get_plantUML_element'.\n\n2. 'indentation': The string input signifies current levels of indents (e.g., initial tabulations in Python scripts). Its main goal is to render accurate representation within PlantUML by mirroring indentation style prevalent in source code and organizing readable formatting between code snippets as it recursively travels down nested constructs within control flow structures during function execution. By employing an increased 'indentation' level, get_plantUML_element ensures proper visual alignment of elements on the PlantUML diagram, reflecting their original Python script indentations for better comprehension and interpretation by developers or analysts examining code behavior graphically. This aids in deciphering the hierarchical order between parent blocks (if/else clauses) and nested statements in control flow."
    },
    {
        "instruction": "Docstring of `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element"
    },
    {
        "instruction": "Calls made in `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'isinstance', 'next', 'iter', 'key.startswith', 'get_plantUML_element'\n\nPurpose and Significance:\nIn `get_plantUML_element` function within 'get_code_graph.py', four primary internal calls are executed to generate plantUML representations for each element within the control flow structure. These calls play a crucial role in creating visualizations that enhance software readability by translating Python code into Activity Diagram notation.\n\n1. `isinstance(element, str)`: This built-in Python function checks if an object is an instance of a given data type (here 'str'). In `get_plantUML_element`, it ensures whether the current element is a string or not before processing further operations. If not a string, subsequent steps proceed with generating plantUML code for nested dictionary elements.\n\n2. `next(iter(element))`: The built-in 'next' function along with 'iter()' combination returns an iterator over the given object ('element') in this context. Since Python dictionaries are iterable, 'next()' fetches the first key from the dictionary element during plantUML generation to determine its type (function name/class definition/condition keywords).\n\n3. `key.startswith('def ')` / `key.startswith('async def ')` / `key.startswith('class ')` / `key.startswith('if ')` / `key.startswith('for ')` / `key.startswith('while ')` / `key.startswith('asyncfor ')` / `key.startswith('try ')` / `key.startswith('except ')`: These string method checks identify the element type within the control flow structure dictionary elements. They assist in generating appropriate plantUML syntax based on Python keywords ('def', 'class', 'if', 'for', 'while', 'async def', 'async for', 'try', and 'except'). For instance, if an element starts with 'def ', it indicates a function definition requiring specific plantUML formatting.\n\n4. `get_plantUML_element(element=..., indentation=' ')`: This function call generates plantUML code for each individual element within the control flow structure recursively. It handles various cases - defining functions/classes, conditions (if statements), loops (for & while), exceptions ('try', 'catch'), and strings representing elements with unique formatting approaches accordingly using provided indentation levels. These distinct formattings create readable Activity Diagrams in plantUML format for easy understanding of the software's flow."
    },
    {
        "instruction": "Variables in `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'key', 'plantuml_str', 'element', 'inner_indentation', 'value', 'indentation'\n\nPurpose and Significance:\nIn the `get_plantUML_element` function within 'get_code_graph.py', these variables play crucial roles to generate PlantUML activity diagram representations for each individual element in the control flow structure obtained during code analysis. Their purpose and operations are elaborated below:\n\n1. 'key': It captures the key identifier extracted from the dictionary passed as 'element'. Depending on its prefix ('def', 'class', 'if', 'for', 'while', 'asyncfor', or 'try'/'except', it signifies the type of Python code construct being handled while forming PlantUML code accordingly. This assists in understanding distinct visual representations based on syntactic features present within code segments.\n\n2. 'plantuml_str': A cumulative string buffer primarily initialized as \"@startuml\\n\" at function entrypoint, collecting PlantUML code snippets generated for each element during recursive traversal. It eventually holds the entire PlantUML diagram representation of the control flow structure when combined with other elements' representations.\n\n3. 'element': Represents the current processing entity in `get_plantUML_element`, which can be either a dictionary or string type derived from the control flow tree list. This variable undergoes transformation into PlantUML notation through nested function calls, contributing to the final diagram construction.\n\n4. 'inner_indentation': An intermediate indentation level incremented by two spaces ('  ') for every nested structure encountered within a dictionary element (definitions or exceptions). It helps maintain consistent formatting and readability in PlantUML layout generation throughout hierarchy depths by indenti- fying consecutive children beneath each control block properly.\n    a. As methods like def and classes expand over more levels ('{' for method definitions and ':' at beginning & ending braces), indentation is increased to maintain visual clarity.\n    b. Strings representing standalone statements (if/else conditions) receive single colon indentation without any nested elements.\n\n5. 'value': This variable stores the content associated with a specific key in the dictionary element being processed ('def', 'class', etc.). It can be either a list of child elements or a string for standalone statements. For nested structures like methods, it holds subordinate control flow elements to be further processed by `get_plantUML_element`.\n    a. If 'value' is a dictionary (method definition), inner indentation level ('inner_indentation') gets invoked repeatedly on subsequent elements inside this key:('def' or 'class'), building hierarchical representations with sub-statements inside method blocks until returning brace.\n    b. When 'value' represents an exceptional standalone statement without children nodes ('else', nested loops or conditional checks), only single colon ('(:') preceded by respective indentaion marks is generated at once with `element` handling each of these independent syntax instances."
    },
    {
        "instruction": "Returns from `get_plantUML_element` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML_element(element, indentation=''):\n    \"\"\"\n    Get plantUML code for each element.\n    Args:\n        element: element\n        indentation: current indentation level\n    Returns:\n        plantuml_str: plantUML code for each element\n    \"\"\"\n    plantuml_str = ''\n    if isinstance(element, dict):\n        key = next(iter(element))\n        value = element[key]\n        if key.startswith('def ') or key.startswith('async def '):\n            plantuml_str += f'{indentation}def {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('class '):\n            plantuml_str += f'{indentation}class {value} {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('if '):\n            plantuml_str += f'{indentation}if ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor '):\n            plantuml_str += f'{indentation}while ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('try '):\n            plantuml_str += f'{indentation}try {{\\n'\n            inner_indentation = indentation + '  '\n        elif key.startswith('except '):\n            plantuml_str += f'{indentation}catch ({value}) {{\\n'\n            inner_indentation = indentation + '  '\n        else:\n            plantuml_str += f'{indentation}:{key};\\n'\n            inner_indentation = indentation\n        if isinstance(value, list):\n            for child in value:\n                plantuml_str += get_plantUML_element(child, inner_indentation)\n        if key.startswith('def ') or key.startswith('class '):\n            plantuml_str += f'{indentation}}}\\n'\n        elif key.startswith('if ') or key.startswith('for ') or key.startswith('while ') or key.startswith('asyncfor ') or key.startswith('try ') or key.startswith('except '):\n            plantuml_str += f'{indentation}}}\\n'\n    elif isinstance(element, str):\n        plantuml_str += f'{indentation}:{element};\\n'\n    return plantuml_str\n```",
        "output": "'plantuml_str'\n\nPurpose and Significance:\nIn 'get_plantUML.py', the `get_plantUML_element` function plays a crucial role within the codebase to generate individual elements' plantUML representation in relation to creating visually readable activity diagrams. This functionality generates plantUML output strings corresponding to various code snippets by traversing through each element within the control flow structure while managing indentation levels. Its primary responsibilities include:\n\n1. Identifying different Python element types based on keys (such as functions, classes, conditions, loops, exceptions) extracted from the control flow tree and assigning appropriate plantUML syntax accordingly.\n2. Constructing plantUML activity diagram code snippets for each identified element by considering indentation depth ('indentation') for organized layout purposes. This includes methods such as function definitions (\"def\"), classes (\"class\"), conditionals (\"if\"), loops (\"for\"/\"while\"), try blocks (\"try\"), and exception handling sections (\"except\").\n3. Handling strings directly without nested structures in a separate case.\n4. The final `plantuml_str` variable accumulates all generated plantUML representations for each element throughout the control flow structure traversal, ultimately contributing to the overall plantUML diagram code generation performed by `get_plantUML()`. This string buffer holds every individual element's visualization output before combining them into a comprehensive activity diagram using '@startuml', '@enduml' markers in the final step."
    },
    {
        "instruction": "Inputs to `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'code_graph', 'control_flow_structure'\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py', the inputs 'code_graph' and 'control_flow_structure' play crucial roles within the function 'reorganize_control_flow'. This particular function aims to rearrange the extracted control flow structure in a manner that aligns with the established code graph starting points for enhanced comprehension of dependencies. Both these parameters contribute significantly towards this goal as follows:\n\n1. 'code_graph': This input consists of the entire networkx Directed Graph representing software relationships among functions, classes, and methods derived from the given file summary details. It serves as a foundation to identify starting points for reorganizing control flow structure in a logical order. The code graph helps determine nodes that act as entry points for traversal within the control flow tree.\n\n2. 'control_flow_structure': This input represents the extracted control flow tree from Abstract Syntax Tree (AST) nodes, which is initially unordered and may contain nested dictionaries and strings representing Python code elements such as functions, classes, loops ('if', 'for'), exception handling ('try'/'except') statements. As an essential raw material for rearrangement by `reorganize_control_flow`, it allows visualizing how each code block interconnects and flows sequentially in the program logic.\n\nThe combination of these inputs enables 'reorganize_control_flow()' to create a more readable representation of control flow structure that aligns with the code graph starting points, ultimately improving understanding of the overall software design. It does so by iterating through each element recursively, selecting those corresponding to initializing nodes from the code graph ('starting_points') and sorting them in an organized fashion within a new list ('organized'). This refined structure facilitates better analysis of dependencies among various Python statements or blocks in the program flow."
    },
    {
        "instruction": "Docstring of `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure"
    },
    {
        "instruction": "Calls made in `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'set', 'isinstance', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend', 'reorganize_structure'\n\nPurpose and Significance:\nIn the function `reorganize_control_flow`, these key method calls play integral roles in structuring the control flow tree obtained from extracted code details to align with the graph starting points found during code graph generation. They contribute to better comprehension of relationships among different program elements and streamline its representation. Detailed explanation follows:\n\n1. 'set()': A built-in Python data type representing a collection without duplicate items that is used here to create 'seen', tracking processed elements in the control flow structure recursion process. This ensures no repeated occurrences during reorganization, improving efficiency and accuracy.\n\n2. 'isinstance(element, type)' checks if an object belongs to a specific class or inherits from it. In this context, it confirms whether an element is a dictionary ('dict') type required for further processing in the control flow structure.\n\n3. 'next(iterable)' retrieves the next item from an iterator object such as 'element keys' iterable in 'get_plantUML_element'. It helps to progress through each key of a dictionary during traversal.\n\n4. 'json.dumps(object)' converts Python objects into JSON encoded strings ensuring serialization compatibility for later comparison in the reorganizing process. It is utilized to identify elements encountered earlier while building the organized list.\n\n5. 'organized.append(value)' adds processed elements into the list 'organized', maintaining an ordered structure with relevant subelements obtained from control flow tree recursion.\n\n6. 'seen.add(element_id)' marks elements already visited during traversal to avoid repetition in the organized list creation, ensuring unique entries only. This prevents redundancy and improves efficiency while reorganizing the control flow structure.\n\n7. 'organized.extend(remaining)' concatenates unprocessed elements from the original control flow tree into the organized list when no further matching is found during recursion. It helps in adding all remaining parts of the control flow structure to avoid losing any information.\n\n8. Lastly, 'reorganize_structure(control_flow_tree, starting_points)' is a custom function call within `reorganize_control_flow` that triggers the actual restructuring process. It recursively iterates through elements in the control flow structure, aligning them with graph starting points resulting in an organized version of the control flow tree for better understanding."
    },
    {
        "instruction": "Variables in `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'key', 'code_graph', 'control_flow_structure', 'remaining', 'starting_points', 'element_id', 'targets'\n\nPurpose and Significance:\nIn the `reorganize_control_flow` function within the get_code_graph.py script, several variables play integral roles that collaborate in shaping its functional execution concerning structuring extracted Control Flow Trees as per obtained Code Graph patterns (coming from the code_graph operation results). Let us review these distinct components along with their purpose and contribution to the process:\n\n1. 'key': Acting as an iterative identifier within a nested dictionary during recursive traversal over 'control_flow_structure', 'key' acquires initial access to each element inside the dictionary while reorganizing the structure. It helps in determining whether the current element matches any starting points from the Code Graph's targets and filters elements accordingly.\n\n2. 'code_graph': Serving as an input argument, this variable represents the entire Code Graph constructed by `code_graph()`. Its details are utilized to find the graphical starting points that aid in rearranging the Control Flow Structure logically.\n\n3. 'control_flow_structure': Represents the extracted Control Flow Tree obtained from Abstract Syntax Tree nodes (AST). This variable undergoes reorganization by `reorganize_control_flow()` to align with Code Graph starting points for better readability and comprehension of dependencies.\n\n4. 'remaining': A temporary list holding elements that haven't been included in the organized list yet. It accumulates elements not matching the starting points during recursive traversal, ensuring a thorough reordering process of the Control Flow Structure.\n\n5. 'starting_points': The core result acquired after iterating over elements inside 'code_graph' with distinct entry vertices extracted. It carries notable points leading other constituents of 'control_flow_structure' that shall become anchor elements within organized structures.\n\n6. 'element_id': This temporary identifier assists in marking unique positions during recursion to avoid duplication while inserting elements into the 'organized' list without repetition. It is primarily used with JSON serialization ('json.dumps') to track processed nodes for prevention of duplicate additions.\n\n7. 'targets': An intermediate variable that collects target nodes from the Code Graph's edges. These targets are significant in identifying starting points for reorganizing Control Flow Structure elements according to graphical dependencies."
    },
    {
        "instruction": "Returns from `reorganize_control_flow` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_control_flow(code_graph, control_flow_structure):\n    \"\"\"\n    Reorganize control flow structure to match the code graph.\n    Args:\n        file_details: file details\n        control_flow_structure: control flow structure\n    Returns:\n        reorganized_control_flow_structure: reorganized control flow structure\n    \"\"\"\n    targets = [edge['target'] for edge in code_graph['edges']]\n    starting_points = [node for node in code_graph['nodes'] if node not in targets]\n\n    def reorganize_structure(structure, start_points):\n        organized, seen = ([], set())\n        for start in start_points:\n            for element in structure:\n                if isinstance(element, dict):\n                    key = next(iter(element))\n                    if start in key:\n                        element_id = json.dumps(element)\n                        if element_id not in seen:\n                            organized.append(element)\n                            seen.add(element_id)\n                elif isinstance(element, str) and start in element:\n                    organized.append(element)\n        remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n        organized.extend(remaining)\n        return organized\n    return reorganize_structure(control_flow_structure, starting_points)\n```",
        "output": "'reorganize_structure(control_flow_structure', 'starting_points)', 'organized'\n\nPurpose and Significance:\nThe `reorganize_structure` function within the 'get_code_graph.py' script plays a crucial role in refining the extracted control flow structure obtained from parsing Abstract Syntax Tree (AST) nodes to align it with the given software file's code graph starting points. This reordering facilitates comprehension by ensuring all elements follow an organized layout reflecting how the code actually functions. It forms part of the overall process aimed at generating plantUML activity diagrams for visual representation purposes.\n\nThe primary purpose of `reorganize_structure` lies in traversing through each element within the control flow structure recursively and segregating them into two distinct outputs:\n1. 'starting_points': A list containing nodes that serve as entry points in the code graph but are not connected to any other elements in the current control flow tree. These act as starting nodes for further processing.\n2. 'organized': A rearranged list of elements from the initial control flow structure where matching elements corresponding to the starting points have been added after verification against seen instances (inclusion within structured flow already collected), yielding an intuitive format facilitating downstream use by associated tools and programs dealing with such representation of flow processes in programming codes. By incorporating both sets, `reorganize_control_flow` enables effective handling and utilization of extracted data in further operations like generating plantUML activity diagrams or additional analyses required on code understanding and interpretation."
    },
    {
        "instruction": "Inputs to `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "'source_name', 'calls'\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py' script, the function `add_edges_for_calls()` primarily deals with processing call relations among functions and class methods within a given file summary. Its two critical inputs - 'source_name' and 'calls', play crucial roles in establishing edges between nodes representing dependencies in the directed graph (nx.DiGraph).\n\n1) Purpose of Inputs:\n   a. `source_name` refers to a function or class name acting as an origin point for potential calls in the codebase. This identifier helps track and trace relationships between various elements while building up the dependency tree during edge formation.\n   b. `calls` contains lists of targeted functions/methods called by the specified 'source_name'. It collects data regarding dependencies and enables establishing edges based on method invocations in the file summary details.\n\n2) Significance of each Input to `add_edges_for_calls()`:\n   a. `source_name` is essential for adding nodes corresponding to functions or classes serving as sources for calls in the code graph construction. By having these nodes, edges can be connected correctly reflecting the flow between them.\n   b. `calls`, being a list of strings related to method invocations, assists in navigating dependencies within the codebase by identifying methods invoked from a particular source ('source_name'). This input facilitates the addition of edges representing call relationships among functions and class methods in the graph structure."
    },
    {
        "instruction": "Calls made in `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "'list', 'class_def.keys', 'called.split', 'called.startswith', 'called.replace', 'source_name.split', 'add_edge_with_data', 'G.add_node'\n\nPurpose and Significance:\nIn the `add_edges_for_calls()` function within the 'get_code_graph.py' script, several calls are utilized to process function and class method dependencies in Python code during graph creation. These operations are essential for building a networkx Directed Graph representing relationships among functions, classes, and methods within a given file summary. Below is an explanation of each call's purpose:\n\n1. 'list': This built-in Python data type acts as input argument to store Abstract Syntax Tree (AST) nodes containing relevant code elements required for extracting function calls during the graph construction process. It holds information about functions and classes from which edges are derived later on.\n2. 'class_def.keys()': Returns a list of class names present in file summaries under `file_summary[\"class_defs\"] attribute. This call helps identify target classes for creating node connections with their respective methods in the graph.\n3. 'called.split('.'): Splits strings containing method calls into class name and method name portions, facilitating determination of fully qualified names required for graph edges establishment.\n4. 'called.startswith(\"self.\")' & 'called.startswith(\"<some string>\")': These conditional checks determine whether a given method call refers to an instance attribute ('self') or belongs to other categories (class methods). They aid in creating accurate connections between classes and methods during graph construction.\n5. 'called.replace(\"<source_substring>\", \"<target_substring>\"): Changes the targeted strings if required in creating a correct name with updated substrings before connecting edges properly within networkx DiGraph 'G'. It might substitute characters relevant for accurate class hierarchy reference, specifically moving between full module/class notation.\n6. 'add_edge_with_data(source_name, called)': Invokes another function responsible for adding nodes to the graph with corresponding edge data from lookup dictionaries and their dependencies (function or class method details). This call ensures edges are added with relevant information extracted earlier.\n7. 'G.add_node(source_name)' & 'G.add_edge(source, target)': These networkx methods create nodes for functions/classes in the graph structure while connecting them through edges according to their dependencies as defined by function details lookup ('function_details_lookup' and 'class_method_details_lookup'). They are essential for constructing the code graph representation with valid links among different components of a program. ''"
    },
    {
        "instruction": "Variables in `add_edges_for_calls` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edges_for_calls(source_name, calls):\n    class_names = [list(class_def.keys())[0] for class_def in file_summary['class_defs']]\n    for called in calls:\n        called_class_name = called.split('.')[0]\n        if called.startswith('self.'):\n            method_name = called.replace('self.', '')\n            fully_qualified_name = f\"{source_name.split('.')[0]}.{method_name}\"\n            if fully_qualified_name in class_method_details_lookup:\n                add_edge_with_data(source_name, fully_qualified_name)\n                continue\n        if called in function_details_lookup or called in class_method_details_lookup or f\"{source_name.split('.')[0]}.{called}\" in class_method_details_lookup:\n            add_edge_with_data(source_name, called)\n        elif called_class_name in class_names:\n            init_method = None\n            init_method_name = f'{called}.__init__'\n            if init_method_name in class_method_details_lookup:\n                init_method = init_method_name\n            add_edge_with_data(source_name, called, init_method)\n        else:\n            G.add_node(called)\n            add_edge_with_data(source_name, called)\n```",
        "output": "'called_class_name', 'calls', 'source_name', 'init_method', 'fully_qualified_name', 'init_method_name', 'class_names', 'method_name'\n\nPurpose and Significance:\nIn the context of 'add_edges_for_calls' function within get_code_graph.py, these variables hold crucial information to establish connections between functions and classes based on their dependencies within the Python codebase. Their roles are as follows:\n\n1. `called_class_name`: Represents the class name from which a method call is being made when traversing through 'class_defs' dictionary during function execution. It helps in determining whether the call targets an instance method or a class constructor (__init__).\n2. `calls`: Stores lists of functions/methods called within each function definition, facilitating edge creation between caller and callee nodes in the code graph.\n3. `source_name`: Refers to the name of the current function or method acting as a source node while analyzing call relations in the codebase.\n4. `init_method`: Temporarily stores the constructor (__init__) name for class methods if required during edge creation between classes and their initializers.\n5. `fully_qualified_name`: Combines class name with method name to create a unique identifier for class methods in case of inheritance while generating directed edges for easy traceability across various layers in the graph construction. This string acts as an unambiguous key reference during lookups from class_method_details_lookup.\n6. `init_method_name`: Retrieves constructor names ('__init__') when needed to build edges between classes and their initializers within code graphs.\n7. `class_names`: Lists down keys from 'class_defs' dictionary used to distinguish unique classes within the given Python file.\n8. `method_name`: Keeps track of function or method name that needs connections with its parent class/function for creating graph edges as required in Python codebase understanding.\n\nEach variable contributes to establishing call relations among functions and classes effectively by determining edge creation conditions, building directed paths in the code graph accurately reflecting dependencies between them. This process helps developers visualize the program's structure and better comprehend its logic flow."
    },
    {
        "instruction": "Inputs to `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'structure', 'start_points'\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py', the function `reorganize_structure` aims to systematically align and improve the visual structure organization of an initially extracted Control Flow Tree (denoted by the input 'control_flow_structure') based upon predetermined Starting Points in the software code's Graph. These inputs serve as essential parameters facilitating better understanding of dependencies between distinct programming elements during analysis:\n\n1. 'structure': This input represents the raw control flow tree obtained after parsing Abstract Syntax Tree nodes, primarily consisting of nested dictionaries and strings representing Python code elements such as functions, classes, loops (if/while), exceptions ('try', 'except'), etc. It acts as a foundation for reorganization to match graph starting points in the codebase.\n\n2. 'start_points': A list containing nodes that serve as entry points within the Directed Graph created by `code_graph()`. These nodes don't have any incoming edges from other elements, indicating their position at the beginning of a specific path or process flow within the software architecture. By identifying these starting points, `reorganize_structure` can efficiently traverse and rearrange the control flow tree to reflect actual code execution order.\n\nWithin `reorganize_structure`, 'structure' undergoes recursive iteration wherein elements matching any given 'start_points' are picked and appended to the 'organized' list only when they haven't been seen earlier ('seen') - implying newly encountered instances in traversal order. The function ultimately returns a restructured version of the control flow tree, improving its readability for analysis purposes by preserving original syntax yet ensuring coherence with graph starting points discovered in code dependencies."
    },
    {
        "instruction": "Calls made in `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'set', 'isinstance', 'next', 'iter', 'json.dumps', 'organized.append', 'seen.add', 'organized.extend'\n\nPurpose and Significance:\nIn the `reorganize_structure` function within the get_code_graph.py script, several key operations are performed to rearrange the control flow structure according to the code graph starting points for improved clarity. Below is an elaborated description of significant method calls executed therein along with their specific purposes:\n\n1. `set()` from Python's built-in library is employed in creating a 'seen' variable used as a data type allowing tracking already incorporated elements across control flow tree iterations ensuring their one occurrence. In relation to duplicate element elimination when assembling 'organized' output. This operation provides means of retaining uniqueness amid nested data traversal within the function.\n\n2. `isinstance()` checks if a particular Python object belongs to a given class or implements certain methods and interfaces during recursive calls. In `reorganize_structure`, it is used for verifying whether an element in control flow structure is a dictionary ('element') or merely a string value (which indicates handling basic syntax tokens).\n\n3. `next()` is a built-in function utilized to acquire the first key from each dictionary encountered during traversal within nested elements of 'element'. This helps in identifying the primary key for further processing based on its pattern matching against specific keywords like 'def', 'class', 'if', 'for', 'while', 'asyncfor', or 'try'/'except'.\n\n4. `iter()` is another built-in function applied to iterate over keys within a dictionary ('element') to extract the primary key for further processing in `get_plantUML_element`. It traverses elements of dictionaries encountered during recursion, enabling extraction of relevant information from nested structures.\n\n5. `json.dumps()` is a JSON encoding function converting Python objects into a JSON string representation. This operation helps storing 'element' dictionary IDs as strings for tracking purposes in the set 'seen'. It ensures unique identification during recursive traversal, preventing duplicate entries in the organized list ('organized').\n\n6. `append()` appends elements to lists ('organized') when they meet specific criteria (matching starting points) or are basic syntax tokens. This method allows incremental building of a structured reorganized control flow tree suitable for presenting dependencies according to code graph's origins.\n\n7. `add()` belongs to Python's set class responsible for adding new items to the 'seen' collection (used for identifying distinct elements within traversal). This helps mark elements as previously seen to prevent redundant additions while collecting elements meeting specified criteria.\n\n8. `extend()` concatenates list objects ('organized') with remaining unexplored control flow tree elements when all potential starting points are processed, resulting in a complete reorganized structure after traversing the entire input control flow tree ('remaining'). It extends the organized list comprehensively."
    },
    {
        "instruction": "Variables in `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'key', 'remaining', 'element_id', 'start_points', 'structure'\n\nPurpose and Significance:\nIn the `reorganize_structure` function within get_code_graph.py, four primary variables play crucial roles to achieve effective reordering of the control flow structure according to code graph starting points for better comprehension. These variables are 'key', 'remaining', 'element_id', and 'start_points'.\n\n1. 'key': This variable acts as an iterator within the nested dictionary 'structure' while iterating through each element during recursive traversal. It extracts the first key from every dictionary encountered, which helps identify the type of Python code construct (e.g., 'def', 'if', 'try', etc.). Understanding these keys assists in handling distinct plantUML representations for different elements.\n\n2. 'remaining': A list containing elements that haven't been added to the organized output yet due to not matching any starting points from 'start_points'. It holds unprocessed parts of the control flow structure, ensuring comprehensive traversal through the entire tree until no more reorganization is possible.\n\n3. 'element_id': A temporary identifier assigned uniquely to each dictionary element being added to the organized list during recursion. This ensures that no duplicate elements are inserted multiple times in the final output by tracking elements already processed and preventing repetition. JSON serialization is used for creating a unique identifier ('json.dumps(element)').\n\n4. 'start_points': A set containing nodes from the code graph which serve as starting points for traversal within the control flow structure. These nodes act as entry points to initiate recursion in `reorganize_structure`, ensuring that elements connected to these nodes are prioritized during reordering. This variable helps maintain a logical sequence while constructing the final organized control flow representation."
    },
    {
        "instruction": "Returns from `reorganize_structure` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef reorganize_structure(structure, start_points):\n    organized, seen = ([], set())\n    for start in start_points:\n        for element in structure:\n            if isinstance(element, dict):\n                key = next(iter(element))\n                if start in key:\n                    element_id = json.dumps(element)\n                    if element_id not in seen:\n                        organized.append(element)\n                        seen.add(element_id)\n            elif isinstance(element, str) and start in element:\n                organized.append(element)\n    remaining = [elem for elem in structure if json.dumps(elem) not in seen]\n    organized.extend(remaining)\n    return organized\n```",
        "output": "'organized'\n\nPurpose and Significance:\nThe 'reorganize_structure' function within the get_code_graph.py script holds significance by rearranging the extracted control flow structure obtained through Abstract Syntax Tree traversal to align with the established code graph starting points. This realignment ensures a more comprehensible representation of Python program logic flows in software documentation. Its primary objective is to present elements in an organized manner that matches the dependencies traced through direct function/method connections present in file summary files for network analysis with Graph visualizations, streamlining visual readability between elements derived from node graph creations in Python coding modules or scripts. Its notable outcomes encompass:\n\n1. 'organized': This list serves as the rearranged control flow structure where elements are systematically arranged based on their connection to code graph starting points. Each element is sorted considering their association with graph origins for a systematic layout in documentation format. The sorted elements offer enhanced readability during visual inspection and interpretation of code behavioral patterns within a software file or project.\n\nThe key steps 'reorganize_structure' accomplishes include iterating over every structure element and classifying them as either nested dictionary objects (function definitions, class declarations) or string entries representing single-line commands (e.g conditional statements). It then checks if any of these elements match the starting points from code graph nodes. If a match occurs, it adds the element to the 'organized' list while marking its presence as seen in a set ('seen'). This ensures each item is included only once for clarity during visualization.\n\nFurthermore, when traversing nested lists within dictionary elements, 'reorganize_structure' calls itself recursively till every structure item gets considered, preserving consistent sequencing while avoiding redundancies throughout the output structure representation. It assists software engineers or developers to navigate easily through dependencies among program constructs and comprehend code flow more efficiently."
    },
    {
        "instruction": "Inputs to `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'file_summary', 'file_ast'\n\nPurpose and Significance:\nIn get_code_graph.py's context, two crucial inputs primarily influence the overall functionality - 'file_summary' and 'file_ast'. These parameters are fed into the central function `get_code_graph()`, driving its operation to generate structured software documentation comprehensively.\n\n1. file_summary ('Dict[str, Union[Dict, str]]': This input represents a dictionary containing extracted details from a specific file. It holds information about functions and classes with their respective dependencies. 'file_summary' serves as the foundation for constructing a directed graph by adding nodes (classes/methods) and determining relationships between them through function calls. Its contents are vital in shaping the code graph representation returned by `code_graph()`.\n\n2. file_ast ('ast.AST'): This input refers to an Abstract Syntax Tree of Python code, obtained from parsing a given source file. It serves as a key element for extracting control flow trees via `extract_control_flow_tree()`, which forms the basis for visualization through plantUML activity diagrams in `get_plantUML()`. Additionally, 'file_ast' contributes to building the reorganized control flow structure by following code graph starting points within `reorganize_control_flow()`.\n\nBy providing accurate file summary details ('file_summary') along with Python abstract syntax tree ('file_ast'), `get_code_graph()` accomplishes three significant tasks - generating a code graph, restructuring control flow information to fit its topology while constructing associated plantUML activity diagrams to assist readers understand and interpret program dependencies/operations intuitively. Without these inputs or insufficient information (like faulty summary), it won't yield intended outputs - thus impairing analysis capacities on complex source files accurately."
    },
    {
        "instruction": "Docstring of `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details"
    },
    {
        "instruction": "Calls made in `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'code_graph', 'extract_control_flow_tree', 'reorganize_control_flow', 'get_plantUML', 'str'\n\nPurpose and Significance:\nIn the `get_code_graph.py` script, four primary functions are crucial within its implementation process of constructing code graph representation, deriving control flow structures, and generating PlantUML activity diagram visualization from source code data - 'code_graph', 'extract_control_flow_tree', 'reorganize_control_flow', 'get_plantUML', and string manipulation for error messages ('str'). These functions work together to provide a comprehensive analysis of Python files.\n\n1) Purpose and Significance of 'code_graph':\nThis function parses given file summary details into networkx Directed Graphs representing functional dependencies within the codebase, such as class methods or functions, and creates a structured dictionary format with nodes for classes/methods alongside edges indicating their relationships. It collectively organizes function calls while extracting necessary edge data from method lookup dictionaries (function_details_lookup & class_method_details_lookup). This graph representation is vital to understand the code flow better and serve as an input for further processing steps like control flow extraction or PlantUML generation.\n\n2) Purpose and Significance of 'extract_control_flow_tree':\nThis function traverses Abstract Syntax Tree (AST) nodes, breaking them down into a control flow tree structure represented as a list containing nested dictionaries and strings representing Python code elements. This step is essential to visualize the logical order of execution within the codebase, providing deeper insights into how each statement interacts with others.\n\n3) Purpose and Significance of 'reorganize_control_flow':\nAfter deriving the control flow structure, it is vital to align starting points according to dependencies outlined in the Code Graph obtained through `code_graph()`. Here 'reorganize_control_flow' refines the existing structure into an ordered format by identifying nodes with no incoming edges as initial elements. This process ensures easier understanding and navigation within PlantUML activity diagrams for enhanced readability purposes.\n\n4) Purpose and Significance of 'get_plantUML':\nBy leveraging the reorganized control flow structure, this function generates PlantUML activity diagram code from the entire list obtained earlier. PlantUML is a graphical notation system used to describe algorithms visually; hence its creation enables developers to analyze the workflow and relationships within code with better clarity and efficiency.\n\n5) Purpose of 'str':\nWhile generating plantUML for error messages, 'str' acts as an intermediate output type. In case any exception arises during processing, this string conversion provides readable details for debugging purposes or error identification, aiding in pinpointing potential issues during execution.\nIn the `get_code_graph` function call sequence, these functions combine their functionalities to merge code graph generation with control flow extraction and PlantUML creation using provided file summary data ('file_summary') along with Abstract Syntax Tree ('file_ast'). The output includes entire code graph, reorganized control flow structure, and plantUML representation as a tuple. This consolidated approach offers developers an all-inclusive analysis of Python files' dependencies, logical order, and visualization for improved comprehension of codebase intricacies."
    },
    {
        "instruction": "Variables in `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'control_flow_structure', 'plantUML', 'control_flow_tree', 'file_ast', 'entire_code_graph', 'file_summary'\n\nPurpose and Significance:\n1. control_flow_structure: This variable holds the reorganized control flow tree after arranging it according to match the code graph starting points within the `get_code_graph` function. It represents a list containing structured elements derived from Abstract Syntax Tree nodes, which are crucial for visualizing Python code's sequential execution flow.\n\n2. plantUML: A string buffer used in generating PlantUML activity diagram code representation of the entire file's control flow structure. This visualization helps developers understand program behavior more intuitively by providing a graphical layout of functions, classes, loops, conditions, exceptions handling, etc., as part of `get_code_graph`.\n\n3. control_flow_tree: Initially extracted from Abstract Syntax Tree nodes in `extract_control_flow_tree`, it is a list comprising nested dictionaries and strings representing Python code elements. It acts as an intermediate result before being reorganized into `control_flow_structure`. This data serves as input for plantUML creation in the subsequent stages.\n\n4. file_ast: Denotes Abstract Syntax Tree (AST) input required by `get_code_graph` to extract control flow tree information and merge it with code graph generation processes. It acts as a Python program representation for analysis purposes.\n\n5. entire_code_graph: Derived from the `code_graph` function execution, this variable encapsulates nodes (functions/classes) along with edges (relationships) representing dependencies in a dictionary format. Entire code graph becomes crucial input to produce PlantUML output later in `get_code_graph`.\n\n6. file_summary: The initial file details supplied to `get_code_graph`, comprising function and class definitions extracted from file metadata. It contains essential information about the source code necessary for building directed graphs with associated lookup dictionaries ('function_defs', 'class_defs') for functions and methods interconnections."
    },
    {
        "instruction": "Returns from `get_code_graph` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_code_graph(file_summary, file_ast):\n    \"\"\"\n    Add code graph and control flow to file details.\n    Args:\n        file_details: file details\n    Returns:\n        file_details: file details\n    \"\"\"\n    try:\n        entire_code_graph = code_graph(file_summary)\n        control_flow_tree = extract_control_flow_tree(file_ast.body)\n        control_flow_structure = reorganize_control_flow(entire_code_graph, control_flow_tree)\n        plantUML = get_plantUML(control_flow_structure)\n    except Exception as e:\n        control_flow_structure = [str(e)]\n        plantUML = str(e)\n    return (entire_code_graph, control_flow_structure, plantUML)\n```",
        "output": "'(entire_code_graph', 'control_flow_structure', 'plantUML)'\n\nPurpose and Significance:\nThe primary objective of the `get_code_graph()` function lies in synthesizing crucial information related to software code analysis through three major outputs - 'entire_code_graph', 'control_flow_structure', and 'plantUML'. Each return value holds a specific role in representing various aspects of a program's characteristics:\n\n1. 'entire_code_graph': Generates an in-memory directed graph interpretation via the given 'file_summary'. NetworkX Python package is used for forming a dependency graph encompassing nodes (functions, classes, methods) and edges illustrating their relationships. This graphical representation helps visualize code structure and function/class interconnections.\n\n2. 'control_flow_structure': Extracts a control flow tree from the Abstract Syntax Tree ('file_ast') obtained after traversing through nodes using AstPython libraries. This structure simplifies complex code flows into human-readable form by mapping elements hierarchically as nested dictionaries and strings, enabling better understanding of Python program logic.\n\n3. 'plantUML': Produces a visual representation of the entire control flow tree in PlantUML format ('@startuml', '@enduml') for improved comprehension of code behavior. It generates an activity diagram that depicts sequential execution paths within the software, making it easier to analyze program workflow.\n\nIn summary, `get_code_graph()` combines diverse techniques such as graph creation, control flow extraction, and plantUML generation to provide comprehensive insights into a Python codebase's structure and functional flow through its distinct outputs ('entire_code_graph', 'control_flow_structure', and 'plantUML'). These returns assist developers in identifying issues or analyzing dependencies for further refactoring or debugging purposes."
    },
    {
        "instruction": "Inputs to `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'target_details', 'source_details', 'target'\n\nPurpose and Significance:\nIn the context of 'get_edge_data_from_details' function within the get_code_graph.py module, the inputs ['target_details', 'source_details', and 'target'] hold crucial roles to determine edge attributes for nodes connected in the Directed Graph (nx.DiGraph). This helper function extracts additional information related to edges between nodes representing functions or class methods in a codebase. Each input serves a specific purpose as follows:\n\n1. 'target_details': Represents the details of the target method node being linked by an edge in the graph. It helps retrieve data such as inputs and returns associated with that particular method, which will be added to the edge's properties later on. This information assists in understanding the relationship between two connected nodes better.\n\n2. 'source_details': Contains details of the source node initiating an edge connection. By referring to this data, get_edge_data_from_details can identify inputs passed as arguments to a function call or class method invocation at the source side. This information is essential for understanding how data flows between nodes in the code graph.\n\n3. 'target': Denotes the specific node receiving an edge connection from another node (source). It acts as a reference point while determining edge attributes like inputs and returns related to the target method or function. By analyzing both source_details and target details together, get_edge_data_from_details can create comprehensive edge data for the Directed Graph representation."
    },
    {
        "instruction": "Calls made in `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'target_details.get', 'list', 'set'\n\nPurpose and Significance:\nIn the `get_edge_data_from_details` function within the get_code_graph.py script, three crucial calls are executed to achieve targeted outcomes regarding graph edge details extraction for representation purposes. Their respective roles and impacts are described below:\n\n1. `target_details.get(<key>)` - This method accesses attributes stored in 'target_details', which represents the information related to a specific node or element connected through an edge in the code graph. It helps retrieve necessary data required for populating edge details such as inputs and returns associated with the target function/method.\n\n2. `list` - Although not directly called within `get_edge_data_from_details`, it signifies a built-in Python data type used to store intermediate results or temporary collections during program execution. In this context, `target_inputs`, an integral portion of graph edges information relating target's received data arises through dealing with multiple arguments for diverse objects/use cases collectively defined by Union type Hint 'List[str], possibly forming node/edge-related lists.\n\n3. `set()` constructor - This call creates a Set object in Python, which is an unordered collection without duplicates. In the given code context, it serves as a container for tracking nodes already processed ('seen') during recursive traversal within `reorganize_structure`. It ensures that no repeated elements are included while rearranging control flow structure to match code graph starting points. This prevents redundancy and maintains unique entries in organized outputs for efficient readability and clear understanding of code relationships."
    },
    {
        "instruction": "Variables in `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'target_details', 'source_details', 'target', 'edge_data'\n\nPurpose and Significance:\nIn the context of 'get_edge_data_from_details' function within the 'get_code_graph.py', these four variables hold specific roles that contribute towards building edges with related information between nodes in the directed graph representing the code relationships.\n\n1. 'target_details': This variable captures details extracted from the target method within the code graph, allowing extraction of crucial information like inputs and returns for edge data creation during edge formation. It helps to maintain contextual understanding about the dependencies among functions or class methods in the program flow.\n\n2. 'source_details': Analogous to 'target_details', but holds information about source method details instead, necessary for obtaining proper call inputs if applicable while adding edges between nodes. Both 'target_details' and 'source_details' play a key part in enriching edge data with accurate information.\n\n3. 'target': It represents the specific node or element being connected by an edge within the code graph, facilitating linkage to its respective details obtained from 'class_method_details_lookup' (if it's a method call target) or 'function_details_lookup'. Understanding dependencies starts from such identified nodes or methods in this fashion.\n\n4. 'edge_data': It functions as a collecting unit for storing extracted inputs and returns from either 'target_details' or 'source_details', depending on their availability during edge formation process. This variable accumulates relevant data to be associated with edges connecting source and target nodes in the graph, making it easier to visualize relationships between code elements. By updating 'edge_data', the function can construct complete edge attributes for networkx Directed Graph (nx.DiGraph)."
    },
    {
        "instruction": "Returns from `get_edge_data_from_details` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_edge_data_from_details(target_details: dict, source_details: dict, target: str) -> dict:\n    edge_data = {}\n    if target_details:\n        edge_data['target_inputs'] = target_details.get('inputs')\n        edge_data['target_returns'] = list(set(target_details.get('returns', [])))\n    if source_details and 'call_inputs' in source_details and (target in source_details['call_inputs']):\n        edge_data['target_inputs'] = source_details['call_inputs'][target]\n    return edge_data\n```",
        "output": "'edge_data'\n\nPurpose and Significance:\nIn 'get_edge_data_from_details' function within the get_code_graph.py module, the primary objective lies in acquiring essential edge attributes (target inputs and target returns) by examining associated details of source and target nodes involved in a connection within the code graph. This extracted information is encapsulated within 'edge_data', which serves as a dictionary return value when called with arguments - target_details referring to the receiving method's information, and source_details linked to the triggering method details or class definitions. This returned dictionary forms additional attributes added on graph edges later to visualize method calls properly between functions/classes more intuitively in the network representation of the code structure. 'edge_data' essentially supports efficient interpretation by users about the relationship specifics among diverse nodes present in a Directed Graph. It is a crucial step towards generating comprehensive software documentation with accurate dependencies and interactions between various elements within the program logic flow."
    },
    {
        "instruction": "Inputs to `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'control_flow_structure'\n\nPurpose and Significance:\nIn the context of 'get_plantUML' function within 'get_code_graph.py', the primary input named 'control_flow_structure' plays a crucial role in generating plantUML activity diagram representations for enhanced software code understanding. This variable embodies the organized control flow tree extracted from Abstract Syntax Tree (AST) nodes, which represents Python code elements as either nested dictionaries or strings. Its significance lies in providing a structured overview of program execution order and decision-making paths within the codebase. Each element in 'control_flow_structure' symbolizes various aspects like function definitions ('def'), classes ('class'), conditionals ('if'), loops ('while', 'for', etc.), exceptions ('try'), and exception handlers ('except'). After obtaining control flow trees from AST traversal, this structured data serves as the foundation for producing visually appealing plantUML diagrams that illustrate the workflow of a Python program in an easily comprehensible manner. In essence, 'control_flow_structure' helps visualize code functionality using PlantUML syntax, offering better understanding than plain text code viewing.'''"
    },
    {
        "instruction": "Docstring of `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file"
    },
    {
        "instruction": "Calls made in `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'get_plantUML_element'\n\nPurpose and Significance:\nIn 'get_plantUML' function within get_code_graph.py, the primary objective lies in generating PlantUML activity diagram code representation for an entire file based on its extracted control flow structure. The `get_plantUML` operation leverages individual helper methods residing inside to fulfill this goal effectively. Within these internal functions, particular attention should be paid towards `get_plantUML_element`.\n\n1) Purpose of 'get_plantUML_element':\nThe 'get_plantUML_element' function is called repeatedly during PlantUML code generation within `get_plantUML` to construct its distinct parts by converting extracted control flow elements into PlantUML notation. It takes two arguments - an element (either a dictionary or string) and indentation level ('indentation'). This method generates PlantUML representation for each element in the control flow structure with proper indentation levels, allowing better visualization of code hierarchy when constructing overall diagrams.\n\n2) Call Breakdown within `get_plantUML` utilizing 'get_plantUML_element':\na. Initializes a string buffer named 'plantuml_str' containing PlantUML starting tags '@startuml\\n'.\nb. Iterates through each element in the control flow structure using 'get_plantUML_element', passing indentation level as '3 spaces (\"  \") for better readability. This recursively generates PlantUML code for every element within the structure.\nc. Finalizes the process by appending '@enduml' string to conclude PlantUML representation of the entire control flow tree.\n\nIn summary, `get_plantUML` relies heavily on 'get_plantUML_element' to create PlantUML visualizations for each element in the control flow structure, ultimately producing a comprehensive diagram representing the code's activity flow."
    },
    {
        "instruction": "Variables in `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'control_flow_structure', 'plantuml_str'\n\nPurpose and Significance:\nIn get_plantUML function within 'get_code_graph.py', the variables 'control_flow_structure' and 'plantuml_str' hold crucial roles to generate plantUML activity diagrams representing control flow visualizations of software code files.\n\n1. control_flow_structure: This variable stores the reorganized control flow tree extracted from Abstract Syntax Tree (AST) nodes after processing through functions like `extract_control_flow_tree()` and `reorganize_control_flow()`. It contains a list of elements representing Python code elements in nested dictionary or string format. The reordering ensures better alignment with the code graph starting points for improved readability purposes. This structured data serves as an input to generate plantUML diagrams that depict control flow logic accurately within software programs.\n\n2. plantuml_str: As an empty string initialized initially, this variable gradually accumulates the overall plantUML representation of entire code through successive invocations of `get_plantUMLElement()` on every control flow structure element at each iteration. Upon traversing elements within 'control_flow_structure', `plantuml_str` acquires corresponding plantUML representations employing respective indentation levels (generated from get_plantUMLElement()), which together culminate in generating PlantUML diagram code comprehensively presenting Python elements sequencing logically at last rendered by appending \"@startuml\", \"@enduml\" tokens to denote the start and end of activity diagrams respectively."
    },
    {
        "instruction": "Returns from `get_plantUML` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef get_plantUML(control_flow_structure):\n    \"\"\"\n    Get plantUML activity diagram code for entire file.\n    Args:\n        file_details: file details\n    Returns:\n        plantuml_str: plantUML code for entire file\n    \"\"\"\n    plantuml_str = '@startuml\\n'\n    for element in control_flow_structure:\n        plantuml_str += get_plantUML_element(element, '  ')\n    plantuml_str += 'end\\n@enduml'\n    return plantuml_str\n```",
        "output": "'plantuml_str'\n\nPurpose and Significance:\nIn 'get_plantUML', the returned variable \"'plantuml_str'\" signifies an instrumental output containing formatted plantUML Activity Diagram representations corresponding to software codes analyzed. It produces readable visualization illustrations by converting extracted control flow structures into a concise language comprehensible by PlantUML software tools. This diagrammatic representation enhances code understanding through graphical layouts depicting program workflows and decision points. The plantUML string generated here serves as the final product for visualizing complex Python code logic in an organized manner, making it easier to comprehend relationships between various elements such as functions, classes, loops, conditions, exceptions handling, etc., thereby aiding developers during debugging or maintenance tasks. It acts as a significant deliverable of 'get_code_graph.py' by offering a graphical overview of code operations beyond mere textual data structures generated elsewhere in the script. ''plantuml_str'' amalgamates plantUML elements created from each control flow structure item via 'get_plantUML_element', forming a complete Activity Diagram depicting overall program flow as specified within input arguments. Consequently, it contributes significantly to code comprehension by combining various processed components into an accessible visual representation. ''"
    },
    {
        "instruction": "Inputs to `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "'source', 'target', 'init_method'\n\nPurpose and Significance:\nIn the context of 'get_code_graph.py' script, particularly within the function `add_edge_with_data()`, the arguments ['source', 'target', and occasionally an additional argument called 'init_method'] serve vital purposes during networkx Directed Graph formation through edges representation and adding corresponding edge details in Python code analysis process.\n\n1. 'source': This parameter refers to the starting point node from which connections will be built towards a subsequent element within the Directed Graph. It essentially defines an origin of dependencies that triggers or initiates the function/class method calls, assisting in creating the required edge pathways. In `add_edge_with_data()`, source functions as the predecessor to link with target nodes and provide data for associated edges in a structured manner.\n\n2. 'target': This parameter indicates the end node receiving connection from source elements through an association such as function or class method invocations within the Python codebase. The edge's terminal point helps identify interdependent relations, facilitating comprehensive graph formation. In `add_edge_with_data()`, target denotes the destination where edges are established from sources to represent the code flow accurately.\n\n3. 'init_method': This optional argument comes into play when dealing with class methods specifically. It represents an initializer (__init__) within classes, which might be required during edge creation between classes and their respective methods. When present in `add_edge_with_data()`, init_method specifies the constructor call linking between them. The default value ('None') indicates a standard function invocation otherwise when connecting unrelated elements in graph structure development.'"
    },
    {
        "instruction": "Calls made in `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "'class_method_details_lookup.get', 'function_details_lookup.get', 'G.add_edge', 'get_edge_data_from_details'\n\nPurpose and Significance:\nIn `add_edge_with_data()` function within get_code_graph.py, several essential method invocations aid in constructing a directed graph representing software code relationships. These calls play crucial roles in establishing edges with relevant data between nodes corresponding to functions and class methods. Their purposes are as follows:\n\n1. `class_method_details_lookup.get(target)` or `function_details_lookup.get(source)`: Retrieve specific method details related to target (`qualified_method_name`) and source (`source_name`) nodes from respective lookup dictionaries to create directed connections in the code graph (NetworkX DiGraph `G`).\n\n2. `nx.DiGraph().add_edge(source, target)` ('G.add_edge'): This NetworkX call adds edges between identified nodes in the graph based on extracted method dependencies from file summaries. Each edge contains data retrieved by `get_edge_data_from_details()`.\n\n3. `get_edge_data_from_details(target_details, source_details, target)`: This helper function extracts edge attributes such as 'source inputs' and 'target returns', which are later assigned to edges during their creation in the graph. It ensures a detailed representation of data flow between nodes in the codebase."
    },
    {
        "instruction": "Variables in `add_edge_with_data` in Python file: `py2dataset\\get_code_graph.py`?",
        "input": "```python\ndef add_edge_with_data(source: str, target: str, init_method: Optional[str]=None) -> None:\n    target_details = class_method_details_lookup.get(init_method or target) or function_details_lookup.get(target)\n    source_details = function_details_lookup.get(source) or class_method_details_lookup.get(source)\n    G.add_edge(source, target, **get_edge_data_from_details(target_details, source_details, target))\n```",
        "output": "'target_details', 'init_method', 'source_details', 'target', 'source'\n\nPurpose and Significance:\nIn the 'add_edge_with_data' function within get_code_graph.py, the listed variables play vital roles while setting up directed graph edges with accompanying metadata within networkX diagrams (nx.DiGraph). They provide meaningful associations necessary to portray real relationships present within given software codes' hierarchies or connections among distinct programming constructs like classes/methods ('nodes'), their implementation ('details' lookups), and edge attributes such as inputs/returns between them.\n\n1. 'target_details': This variable stores information about the target method details retrieved from class_method_details_lookup (class methods) or function_details_lookup (function definitions). It is employed to obtain specific properties related to connected nodes for setting edge attributes during edge creation in a network graph.\n\n2. 'init_method': A temporary reference holding the constructor method name ('__init__') encountered when traversing class hierarchy in classes. Its usage occurs when dealing with classes as an initiation point to build directed edges in a graph between them and related methods.\n\n3. 'source_details': This variable represents data retrieved from function_details_lookup (function definitions) or class_method_details_lookup (class methods). It assists in fetching relevant source method properties that are necessary for assigning edge attributes when constructing directed connections between nodes.\n\n4. 'target': Identifies the actual node targeted by an edge, being a function name or qualified method name as it gets formed while iterating within nodes associations at distinct context levels across a given Python program architecture ('functions' / 'classes & their methods').  The attribute access utilizes such a data-structure tie and derives properties necessary to enrich edge attributes during connection building in network graphs.\n\n5. 'source': Designates the starting point for directed edges which might be a function or class method as the connection source node ('functions' / 'class methods') during the graph construction process. It helps establish relationships between nodes by referencing their respective positions within the code structure."
    }
]