file_info:
    file_code: "\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = (\n            [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None\n        )\n        node_variables = list(\n            {\n                ast.unparse(target)\n                for subnode in node_walk\n                if isinstance(subnode, ast.Assign)\n                for target in subnode.targets\n                if isinstance(target, ast.Name)\n            }\n        )\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": node_inputs,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": node_variables,\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                class_attributes = self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                )\n                class_attributes += attributes\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n\n        class_defs = [\n            {\n                class_name: {\n                    \"method_defs\": {\n                        method_name[len(\"class_method_\") :]: {\n                            \"inputs\": details[\"method_inputs\"],\n                            \"calls\": details[\"method_calls\"],\n                            \"call_inputs\": details[\"method_call_inputs\"],\n                            \"returns\": details[\"method_returns\"],\n                        }\n                        for method_name, details in class_details.items()\n                        if method_name.startswith(\"class_method_\")\n                    }\n                }\n            }\n            for class_name, class_details in self.classes.items()\n        ]\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\": node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node), self.tree),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n\n    # get code graph items and add to file_details\n    file_summary = file_details[\"file_info\"][\"file_summary\"]\n    file_ast = file_details[\"file_info\"][\"file_ast\"]\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(\n        file_summary, file_ast\n    )\n    file_details[\"file_info\"][\"entire_code_graph\"] = entire_code_graph\n    file_details[\"file_info\"][\"control_flow_structure\"] = control_flow_structure\n    file_details[\"file_info\"][\"plant_uml\"] = plant_uml\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(file_summary).replace(\n        '\"', \"\"\n    )\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n"
    file_dependencies:
    - logging
    - ast
    - typing
    - get_code_graph
    - json
    file_functions:
    - remove_docstring
    - get_all_calls
    - get_python_file_details
    file_classes:
    - CodeVisitor
    file_constants: []
    file_summary: '{dependencies: [logging, ast, typing, get_code_graph, json], function_defs: [{remove_docstring: {inputs: [code, tree], calls: [isinstance, tree.body.pop, ast.walk, node.body.pop, ast.unparse], call_inputs: {isinstance: [tree.body[0], ast.Expr, tree.body[0].value, ast.Str, node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef), first_body_node, ast.Expr, first_body_node.value, ast.Str], tree.body.pop: [0], ast.walk: [tree], node.body.pop: [0], ast.unparse: [tree]}, returns: [ast.unparse(tree)]}}, {get_all_calls: {inputs: [node, calls], calls: [isinstance, calls.append, ast.unparse, get_all_calls, ast.iter_child_nodes, calls_dict[func].extend], call_inputs: {isinstance: [node, ast.Call, node, ast.ClassDef, body_item, ast.Assign, body_item.targets[0], ast.Name], calls.append: [(ast.unparse(node.func), [ast.unparse(arg) for arg in node.args])], ast.unparse: [node.func, arg], get_all_calls: [body_item.value, calls, child, calls], ast.iter_child_nodes: [node], calls_dict[func].extend: [args]}, returns: [calls_dict]}}, {get_python_file_details: {inputs: [file_path], calls: [open, f.read, ast.parse, logging.warning, CodeVisitor, visitor.analyze, get_code_graph, json.dumps(file_summary).replace, json.dumps], call_inputs: {open: [file_path, ''r''], f.read: [], ast.parse: [code], logging.warning: [f''{e} error in file: {file_path}''], CodeVisitor: [code, tree], visitor.analyze: [tree], get_code_graph: [file_summary, file_ast], json.dumps(file_summary).replace: [''\'', ''''], json.dumps: [file_summary]}, returns: [file_details, None]}}], class_defs: [{CodeVisitor: {method_defs: {__init__: {inputs: [self, code, tree], calls: [], call_inputs: {}, returns: []}, visit_FunctionDef: {inputs: [self, node], calls: [self.extract_details, self.generic_visit], call_inputs: {self.extract_details: [node, ''method'' if self.current_class else ''function''], self.generic_visit: [node]}, returns: []}, visit_ClassDef: {inputs: [self, node], calls: [self.extract_details, self.generic_visit], call_inputs: {self.extract_details: [node, ''class''], self.generic_visit: [node]}, returns: []}, generic_visit: {inputs: [self, node], calls: [ast.iter_child_nodes, self.visit], call_inputs: {ast.iter_child_nodes: [node], self.visit: [child]}, returns: []}, visit_Assign: {inputs: [self, node], calls: [isinstance, ast.unparse, self.constants.append, self.generic_visit], call_inputs: {isinstance: [node.parent, ast.Module, target, ast.Name, value, ast.Constant, value.value, str], ast.unparse: [value], self.constants.append: [constant_assignment], self.generic_visit: [node]}, returns: []}, extract_details: {inputs: [self, node, node_type], calls: [list, ast.walk, get_all_calls, ast.unparse, isinstance, set, next, call_data.keys, self.classes[self.current_class].setdefault, details.update, any], call_inputs: {list: [ast.walk(node), {ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}, set(node_inputs + node_variables), call_data.keys(), {ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set(), {ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}, {ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}], ast.walk: [node], get_all_calls: [node], ast.unparse: [target, node, d, subnode.value, decorator, subnode.annotation, subnode, base], isinstance: [subnode, ast.Assign, target, ast.Name, n, ast.Expr, n.value, ast.Str, subnode, ast.Return, subnode, ast.AnnAssign, subnode, ast.Attribute, subnode.ctx, ast.Store, subnode, ast.Assign, target, ast.Attribute, target.value, ast.Name, subnode, ast.Assign, target, ast.Attribute, subnode, ast.FunctionDef, subnode, ast.FunctionDef, decorator, ast.Name], set: [node_inputs + node_variables], next: [(n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None], call_data.keys: [], self.classes[self.current_class].setdefault: [''class_attributes'', []], details.update: [{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], ''class_inheritance'': [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}], any: [(isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list)]}, returns: [details]}, analyze: {inputs: [self, node], calls: [self.visit, list, ast.walk, isinstance, self.functions.items, len, class_details.items, method_name.startswith, self.classes.items, self.functions.keys, self.classes.keys, remove_docstring, ast.unparse], call_inputs: {self.visit: [node], list: [ast.walk(node), file_dependencies, self.functions.keys(), self.classes.keys(), file_dependencies], ast.walk: [node], isinstance: [subnode, ast.Import, subnode, ast.ImportFrom], self.functions.items: [], len: [''class_method_''], class_details.items: [], method_name.startswith: [''class_method_''], self.classes.items: [], self.functions.keys: [], self.classes.keys: [], remove_docstring: [ast.unparse(node), self.tree], ast.unparse: [node]}, returns: []}}}}]}'
    file_code_simplified: "import ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict\n\nclass CodeVisitor(ast.NodeVisitor):\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n        node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n                class_attributes += attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details"
    entire_code_graph:
        nodes:
        - CodeVisitor
        - CodeVisitor.__init__
        - CodeVisitor.visit_FunctionDef
        - CodeVisitor.visit_ClassDef
        - CodeVisitor.generic_visit
        - CodeVisitor.visit_Assign
        - CodeVisitor.extract_details
        - CodeVisitor.analyze
        - remove_docstring
        - get_all_calls
        - get_python_file_details
        - isinstance
        - tree.body.pop
        - ast.walk
        - node.body.pop
        - ast.unparse
        - calls.append
        - ast.iter_child_nodes
        - calls_dict[func].extend
        - open
        - f.read
        - ast.parse
        - logging.warning
        - visitor.analyze
        - get_code_graph
        - json.dumps(file_summary).replace
        - json.dumps
        - self.visit
        - self.constants.append
        - list
        - set
        - next
        - call_data.keys
        - self.classes[self.current_class].setdefault
        - details.update
        - any
        - self.functions.items
        - len
        - class_details.items
        - method_name.startswith
        - self.classes.items
        - self.functions.keys
        - self.classes.keys
        edges:
        -   source: CodeVisitor
            target: CodeVisitor.__init__
            target_inputs:
            - self
            - code
            - tree
            target_returns: []
        -   source: CodeVisitor
            target: CodeVisitor.visit_FunctionDef
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor
            target: CodeVisitor.visit_ClassDef
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor
            target: CodeVisitor.generic_visit
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor
            target: CodeVisitor.visit_Assign
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor
            target: CodeVisitor.extract_details
            target_inputs:
            - self
            - node
            - node_type
            target_returns:
            - details
        -   source: CodeVisitor
            target: CodeVisitor.analyze
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor.visit_FunctionDef
            target: CodeVisitor.extract_details
            target_inputs:
            - self
            - node
            - node_type
            target_returns:
            - details
        -   source: CodeVisitor.visit_FunctionDef
            target: CodeVisitor.generic_visit
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor.visit_ClassDef
            target: CodeVisitor.extract_details
            target_inputs:
            - self
            - node
            - node_type
            target_returns:
            - details
        -   source: CodeVisitor.visit_ClassDef
            target: CodeVisitor.generic_visit
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor.generic_visit
            target: ast.iter_child_nodes
            target_inputs:
            - node
        -   source: CodeVisitor.generic_visit
            target: self.visit
            target_inputs:
            - child
        -   source: CodeVisitor.visit_Assign
            target: isinstance
            target_inputs:
            - node.parent
            - ast.Module
            - target
            - ast.Name
            - value
            - ast.Constant
            - value.value
            - str
        -   source: CodeVisitor.visit_Assign
            target: ast.unparse
            target_inputs:
            - value
        -   source: CodeVisitor.visit_Assign
            target: self.constants.append
            target_inputs:
            - constant_assignment
        -   source: CodeVisitor.visit_Assign
            target: CodeVisitor.generic_visit
            target_inputs:
            - self
            - node
            target_returns: []
        -   source: CodeVisitor.extract_details
            target: list
            target_inputs:
            - ast.walk(node)
            - '{ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}'
            - set(node_inputs + node_variables)
            - call_data.keys()
            - '{ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()'
            - '{ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}'
            - '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}'
        -   source: CodeVisitor.extract_details
            target: ast.walk
            target_inputs:
            - node
        -   source: CodeVisitor.extract_details
            target: get_all_calls
            target_inputs:
            - node
            target_returns:
            - calls_dict
        -   source: CodeVisitor.extract_details
            target: ast.unparse
            target_inputs:
            - target
            - node
            - d
            - subnode.value
            - decorator
            - subnode.annotation
            - subnode
            - base
        -   source: CodeVisitor.extract_details
            target: isinstance
            target_inputs:
            - subnode
            - ast.Assign
            - target
            - ast.Name
            - n
            - ast.Expr
            - n.value
            - ast.Str
            - subnode
            - ast.Return
            - subnode
            - ast.AnnAssign
            - subnode
            - ast.Attribute
            - subnode.ctx
            - ast.Store
            - subnode
            - ast.Assign
            - target
            - ast.Attribute
            - target.value
            - ast.Name
            - subnode
            - ast.Assign
            - target
            - ast.Attribute
            - subnode
            - ast.FunctionDef
            - subnode
            - ast.FunctionDef
            - decorator
            - ast.Name
        -   source: CodeVisitor.extract_details
            target: set
            target_inputs:
            - node_inputs + node_variables
        -   source: CodeVisitor.extract_details
            target: next
            target_inputs:
            - (n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str))
            - None
        -   source: CodeVisitor.extract_details
            target: call_data.keys
            target_inputs: []
        -   source: CodeVisitor.extract_details
            target: self.classes[self.current_class].setdefault
            target_inputs:
            - '''class_attributes'''
            - '[]'
        -   source: CodeVisitor.extract_details
            target: details.update
            target_inputs:
            - '{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], ''class_inheritance'': [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}'
        -   source: CodeVisitor.extract_details
            target: any
            target_inputs:
            - (isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list)
        -   source: CodeVisitor.analyze
            target: self.visit
            target_inputs:
            - node
        -   source: CodeVisitor.analyze
            target: list
            target_inputs:
            - ast.walk(node)
            - file_dependencies
            - self.functions.keys()
            - self.classes.keys()
            - file_dependencies
        -   source: CodeVisitor.analyze
            target: ast.walk
            target_inputs:
            - node
        -   source: CodeVisitor.analyze
            target: isinstance
            target_inputs:
            - subnode
            - ast.Import
            - subnode
            - ast.ImportFrom
        -   source: CodeVisitor.analyze
            target: self.functions.items
            target_inputs: []
        -   source: CodeVisitor.analyze
            target: len
            target_inputs:
            - '''class_method_'''
        -   source: CodeVisitor.analyze
            target: class_details.items
            target_inputs: []
        -   source: CodeVisitor.analyze
            target: method_name.startswith
            target_inputs:
            - '''class_method_'''
        -   source: CodeVisitor.analyze
            target: self.classes.items
            target_inputs: []
        -   source: CodeVisitor.analyze
            target: self.functions.keys
            target_inputs: []
        -   source: CodeVisitor.analyze
            target: self.classes.keys
            target_inputs: []
        -   source: CodeVisitor.analyze
            target: remove_docstring
            target_inputs:
            - ast.unparse(node)
            - self.tree
            target_returns:
            - ast.unparse(tree)
        -   source: CodeVisitor.analyze
            target: ast.unparse
            target_inputs:
            - node
        -   source: remove_docstring
            target: isinstance
            target_inputs:
            - tree.body[0]
            - ast.Expr
            - tree.body[0].value
            - ast.Str
            - node
            - (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)
            - first_body_node
            - ast.Expr
            - first_body_node.value
            - ast.Str
        -   source: remove_docstring
            target: tree.body.pop
            target_inputs:
            - '0'
        -   source: remove_docstring
            target: ast.walk
            target_inputs:
            - tree
        -   source: remove_docstring
            target: node.body.pop
            target_inputs:
            - '0'
        -   source: remove_docstring
            target: ast.unparse
            target_inputs:
            - tree
        -   source: get_all_calls
            target: isinstance
            target_inputs:
            - node
            - ast.Call
            - node
            - ast.ClassDef
            - body_item
            - ast.Assign
            - body_item.targets[0]
            - ast.Name
        -   source: get_all_calls
            target: calls.append
            target_inputs:
            - (ast.unparse(node.func), [ast.unparse(arg) for arg in node.args])
        -   source: get_all_calls
            target: ast.unparse
            target_inputs:
            - node.func
            - arg
        -   source: get_all_calls
            target: get_all_calls
            target_inputs:
            - body_item.value
            - calls
            - child
            - calls
            target_returns:
            - calls_dict
        -   source: get_all_calls
            target: ast.iter_child_nodes
            target_inputs:
            - node
        -   source: get_all_calls
            target: calls_dict[func].extend
            target_inputs:
            - args
        -   source: get_python_file_details
            target: open
            target_inputs:
            - file_path
            - '''r'''
        -   source: get_python_file_details
            target: f.read
            target_inputs: []
        -   source: get_python_file_details
            target: ast.parse
            target_inputs:
            - code
        -   source: get_python_file_details
            target: logging.warning
            target_inputs:
            - 'f''{e} error in file: {file_path}'''
        -   source: get_python_file_details
            target: CodeVisitor
            target_inputs:
            - code
            - tree
            target_returns: []
        -   source: get_python_file_details
            target: visitor.analyze
            target_inputs:
            - tree
        -   source: get_python_file_details
            target: get_code_graph
            target_inputs:
            - file_summary
            - file_ast
        -   source: get_python_file_details
            target: json.dumps(file_summary).replace
            target_inputs:
            - '''"'''
            - ''''''
        -   source: get_python_file_details
            target: json.dumps
            target_inputs:
            - file_summary
    control_flow_structure:
    -   'def get_python_file_details(file_path: str)':
        -   try:
            -   with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                - code = f.read()
                - tree = ast.parse(code)
            except:
            -   'except (PermissionError, SyntaxError, IOError) as :':
                - 'logging.warning(f''{e} error in file: {file_path}'')'
                -   return:
                    - None
        - visitor = CodeVisitor(code, tree)
        - visitor.analyze(tree)
        - 'file_details = {''file_info'': visitor.file_info, ''functions'': visitor.functions, ''classes'': visitor.classes}'
        - file_summary = file_details['file_info']['file_summary']
        - file_ast = file_details['file_info']['file_ast']
        - entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)
        - file_details['file_info']['entire_code_graph'] = entire_code_graph
        - file_details['file_info']['control_flow_structure'] = control_flow_structure
        - file_details['file_info']['plant_uml'] = plant_uml
        - file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('"', '')
        - del file_details['file_info']['file_ast']
        -   return:
            - file_details
    - import ast
    - import logging
    - import json
    - from typing import Dict, List, Union
    - from get_code_graph import get_code_graph
    -   'def remove_docstring(code: str, tree: ast.AST)':
        -   if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):
            - tree.body.pop(0)
        -   for node in ast.walk(tree):
            -   if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:
                - first_body_node = node.body[0]
                -   if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):
                    - node.body.pop(0)
        -   return:
            - ast.unparse(tree)
    -   'def get_all_calls(node: ast.AST, calls)':
        -   if calls is None:
            - calls = []
        -   if isinstance(node, ast.Call):
            - calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))
            elif isinstance(node, ast.ClassDef):
            -   for body_item in node.body:
                -   if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):
                    - get_all_calls(body_item.value, calls)
        -   for child in ast.iter_child_nodes(node):
            - get_all_calls(child, calls)
        - calls_dict = {}
        -   for (func, args) in calls:
            -   if func not in calls_dict:
                - calls_dict[func] = []
            - calls_dict[func].extend(args)
        -   return:
            - calls_dict
    -   class CodeVisitor:
        -   'def __init__(self, code: str, tree: ast.AST)':
            - 'self.code: str = code'
            - 'self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}'
            - 'self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}'
            - 'self.file_info: Dict[str, Union[str, List[str]]] = {}'
            - 'self.current_class: str = None'
            - 'self.constants: List[str] = []'
            - self.tree = tree
        -   'def visit_FunctionDef(self, node: ast.FunctionDef)':
            - details = self.extract_details(node, 'method' if self.current_class else 'function')
            -   if self.current_class:
                - self.classes[self.current_class][f'class_method_{node.name}'] = details
                else:
                - self.functions[node.name] = details
            - self.generic_visit(node)
        -   'def visit_ClassDef(self, node: ast.ClassDef)':
            - self.classes[node.name] = self.extract_details(node, 'class')
            - self.current_class = node.name
            - self.generic_visit(node)
            - self.current_class = None
        -   def generic_visit(self, node):
            -   for child in ast.iter_child_nodes(node):
                - child.parent = node
                - self.visit(child)
        -   'def visit_Assign(self, node: ast.Assign)':
            -   if isinstance(node.parent, ast.Module):
                -   for target in node.targets:
                    -   if isinstance(target, ast.Name):
                        - value = node.value
                        -   if isinstance(value, ast.Constant) and isinstance(value.value, str):
                            - value_repr = f"'{value.value}'"
                            else:
                            - value_repr = ast.unparse(value)
                        - constant_assignment = f'{target.id}={value_repr}'
                        - self.constants.append(constant_assignment)
            - self.generic_visit(node)
        -   'def extract_details(self, node: ast.AST, node_type: str)':
            - node_walk = list(ast.walk(node))
            - call_data = get_all_calls(node)
            - node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None
            - node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})
            -   if node_inputs:
                - node_variables = list(set(node_inputs + node_variables))
            - 'details = {f''{node_type}_name'': node.name, f''{node_type}_code'': ast.unparse(node), f''{node_type}_docstring'': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f''{node_type}_inputs'': node_inputs, f''{node_type}_defaults'': [ast.unparse(d) for d in node.args.defaults] if node_type in [''function'', ''method''] else None, f''{node_type}_returns'': [ast.unparse(subnode.value) if subnode.value is not None else ''None'' for subnode in node_walk if isinstance(subnode, ast.Return)], f''{node_type}_calls'': list(call_data.keys()), f''{node_type}_call_inputs'': call_data, f''{node_type}_variables'': node_variables, f''{node_type}_decorators'': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f''{node_type}_annotations'': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f''{node_type}_properties'': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}'
            -   if node_type in ['class', 'method']:
                -   if node_type == 'method' and self.current_class:
                    - attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]
                    - class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])
                    - class_attributes += attributes
                -   if node_type == 'class':
                    - 'details.update({''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], ''class_inheritance'': [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]})'
            -   return:
                - details
        -   'def analyze(self, node: ast.AST)':
            - self.visit(node)
            - node_walk = list(ast.walk(node))
            - file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}
            - 'function_defs = [{func_name: {''inputs'': details[''function_inputs''], ''calls'': details[''function_calls''], ''call_inputs'': details[''function_call_inputs''], ''returns'': details[''function_returns'']}} for func_name, details in self.functions.items()]'
            - 'class_defs = [{class_name: {''method_defs'': {method_name[len(''class_method_''):]: {''inputs'': details[''method_inputs''], ''calls'': details[''method_calls''], ''call_inputs'': details[''method_call_inputs''], ''returns'': details[''method_returns'']} for method_name, details in class_details.items() if method_name.startswith(''class_method_'')}}} for class_name, class_details in self.classes.items()]'
            - 'self.file_info = {''file_code'': self.code, ''file_ast'': node, ''file_dependencies'': list(file_dependencies), ''file_functions'': list(self.functions.keys()), ''file_classes'': list(self.classes.keys()), ''file_constants'': self.constants, ''file_summary'': {''dependencies'': list(file_dependencies), ''function_defs'': function_defs, ''class_defs'': class_defs}, ''file_code_simplified'': remove_docstring(ast.unparse(node), self.tree)}'
    plant_uml: "@startuml\n  : def get_python_file_details(file_path: str);\n      partition \"try\" {\n          : with open(file_path, 'r', encoding='utf-8', errors='ignore') as f;\n      }\n      : visitor = CodeVisitor(code, tree);\n      : visitor.analyze(tree);\n      : file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes};\n      : file_summary = file_details['file_info']['file_summary'];\n      : file_ast = file_details['file_info']['file_ast'];\n      : entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast);\n      : file_details['file_info']['entire_code_graph'] = entire_code_graph;\n      : file_details['file_info']['control_flow_structure'] = control_flow_structure;\n      : file_details['file_info']['plant_uml'] = plant_uml;\n      : file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '');\n      : del file_details['file_info']['file_ast'];\n      : return;\n  : import ast;\n  : import logging;\n  : import json;\n  : from typing import Dict, List, Union;\n  : from get_code_graph import get_code_graph;\n  : def remove_docstring(code: str, tree: ast.AST);\n      if (tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str)) then (yes)\n          : tree.body.pop(0);\n      endif\n      if (node in ast.walk(tree)) then (yes)\n          if (isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body) then (yes)\n              : first_body_node = node.body[0];\n              if (isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str)) then (yes)\n                  : node.body.pop(0);\n              endif\n          endif\n      endif\n      : return;\n  : def get_all_calls(node: ast.AST, calls);\n      if (calls is None) then (yes)\n          : calls = [];\n      endif\n      if (isinstance(node, ast.Call)) then (yes)\n          : calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]));\n      endif\n      if (child in ast.iter_child_nodes(node)) then (yes)\n          : get_all_calls(child, calls);\n      endif\n      : calls_dict = {};\n      if ((func, args) in calls) then (yes)\n          if (func not in calls_dict) then (yes)\n              : calls_dict[func] = [];\n          endif\n          : calls_dict[func].extend(args);\n      endif\n      : return;\n  : class CodeVisitor;\n      : def __init__(self, code: str, tree: ast.AST);\n          : self.code: str = code;\n          : self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {};\n          : self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {};\n          : self.file_info: Dict[str, Union[str, List[str]]] = {};\n          : self.current_class: str = None;\n          : self.constants: List[str] = [];\n          : self.tree = tree;\n      : def visit_FunctionDef(self, node: ast.FunctionDef);\n          : details = self.extract_details(node, 'method' if self.current_class else 'function');\n          : if self.current_class;\n              : self.classes[self.current_class][f'class_method_{node.name}'] = details;\n          : self.generic_visit(node);\n      : def visit_ClassDef(self, node: ast.ClassDef);\n          : self.classes[node.name] = self.extract_details(node, 'class');\n          : self.current_class = node.name;\n          : self.generic_visit(node);\n          : self.current_class = None;\n      : def generic_visit(self, node);\n          if (child in ast.iter_child_nodes(node)) then (yes)\n              : child.parent = node;\n              : self.visit(child);\n          endif\n      : def visit_Assign(self, node: ast.Assign);\n          if (isinstance(node.parent, ast.Module)) then (yes)\n              if (target in node.targets) then (yes)\n                  if (isinstance(target, ast.Name)) then (yes)\n                      : value = node.value;\n                      if (isinstance(value, ast.Constant) and isinstance(value.value, str)) then (yes)\n                          : value_repr = f\"'{value.value}'\";\n                      endif\n                      : constant_assignment = f'{target.id}={value_repr}';\n                      : self.constants.append(constant_assignment);\n                  endif\n              endif\n          endif\n          : self.generic_visit(node);\n      : def extract_details(self, node: ast.AST, node_type: str);\n          : node_walk = list(ast.walk(node));\n          : call_data = get_all_calls(node);\n          : node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None;\n          : node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)});\n          if (node_inputs) then (yes)\n              : node_variables = list(set(node_inputs + node_variables));\n          endif\n          : details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})};\n          : if node_type in ['class', 'method'];\n              : if node_type == 'method' and self.current_class;\n                  : attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')];\n                  : class_attributes = self.classes[self.current_class].setdefault('class_attributes', []);\n                  : class_attributes += attributes;\n              : if node_type == 'class';\n                  : details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]});\n          : return;\n      : def analyze(self, node: ast.AST);\n          : self.visit(node);\n          : node_walk = list(ast.walk(node));\n          : file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)};\n          : function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()];\n          : class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()];\n          : self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)};\nend\n@enduml"
    code_qa_response: "py2dataset/get_python_file_details.py:\n  Code Documentation:\n  - 'I) The purpose of 'py2dataset/get_python_file_details.py' script is to extract detailed information from Python source code files. It performs analysis using Abstract Syntax Tree (AST), parses docstrings, function calls, dependencies, constants, and generates a code graph representation for better understanding of the file structure. This extracted data helps developers gain insights into the functionality of the given Python file.\n    II) Requirements & API Signatures:\n    1. `remove_docstring` - Removes docstrings from provided Python code string while preserving its syntax.\n    Inputs: Python code string, parsed Abstract Syntax Tree representing this code snippet as argument `tree`.\n    Return value: sanitized source code after stripping the comments and top-level docstrings within functions and classes but retaining the structure intact using ast.unparse().\n    2. `get_all_calls` - Traverses the given AST node's subtree to identify all function calls, including nested occurrences in class attributes, list comprehensions, and lambda functions.\n    Inputs: Node of type ast.AST as argument `node`, an optional dictionary `calls` to accumulate function call lists when no existing instances provided initially (Default = []).\n    Outputs: A Dictionary of strings keyed with the calling functions listing arguments respectively [Function_Calls => [args...]] formed using recursion within the subtree.\n    3. `CodeVisitor` - A class that traverses an Abstract Syntax Tree and extracts details about Python code, inheriting from ast.NodeVisitor for easy traversal management. It collects function definitions, class definitions, file dependencies, constants, etc., storing them in relevant attributes such as 'functions', 'classes', 'file_info'.\n    Constructor Arguments: Source code `code` and parsed Abstract Syntax Tree `tree`.\n    4. `get_python_file_details` - Extracts comprehensive details from a given Python file path using CodeVisitor class methods and generates a control flow structure, entire code graph representation, and PlantUML notation for visualization purposes through get_code_graph function integration.\n    Inputs: File path as string `file_path`.\n    Outputs: A dictionary containing extracted file details or None if an error occurs during processing.\n    III) Inputs, Variables, Calls & Returns explanation in the code context:\n    1. remove_docstring():\n    - Inputs 'code' represents Python source code string while 'tree' is its Abstract Syntax Tree representation generated using ast.parse(). Functions remove top-level docstrings from code strings while recursively deleting nested docstrings inside function bodies or class definitions keeping AST intact by invoking `ast.unparse(tree)`.\n    2. get_all_calls():\n    - 'node' represents an AST node, used to find all occurrences of ast.Call instances along with their arguments within the subtree rooted at this node. It returns a dictionary mapping function calls as keys to lists of their respective arguments. If no initial call list provided ('calls'), it creates an empty list by default ['Dict[str, List[str]]].\n    3. get_python_file_details():\n    - Receives Python file path string 'file_path' and performs the following steps:\n    a) Opens the file using 'open()', reads its content into variable 'code'.\n    b) Parses code into Abstract Syntax Tree using ast.parse().\n    c) Instantiates CodeVisitor object with provided source code 'code' and parsed tree as arguments ('visitor').\n    d) Invokes visitor.analyze() to populate details related to the file in instance attributes.\n    e) Gets a detailed graphical representation of function call relations, control flow structure & PlantUML notation from get_code_graph().\n    f) Replaces quotations from json.dumps() output using replace().\n    g) Returns file_details dictionary with extracted data or None in case of an error.\n    4. CodeVisitor class:\n    - Its methods operate on AST nodes and extract relevant information for various aspects of Python code like functions, classes, dependencies, constants, etc., storing them into attributes such as 'functions', 'classes', 'file_info'. It also maintains a current class context ('current_class') to track nested class definitions.\n    - visit_FunctionDef() and visit_ClassDef(): Calls self.extract_details() method passing relevant node types as parameters ('function' or 'class'), populates 'functions'/'classes' dictionaries accordingly.\n    - extract_details(): Iterates through AST walk of given node, collects function/class details into a dictionary using various calls like ast.walk(), get_all_calls(), ast.unparse(). Returns this collected data as detailed output dictionary depending on node type ('function', 'method', 'class', or 'self').\n    - analyze(): Traverses AST node ('node') for dependencies capturing details related to file_summary (used JSON format) while setting up variables such as file_dependencies, function_defs, class_defs. Invokes get_code_graph() to generate entire code graph representation and PlantUML notation.\n    - Other methods like visit_FunctionDef(), visit_ClassDef(), generic_visit(), visit_Assign(): Assist in traversing AST nodes efficiently by invoking appropriate extract_details() method or calling other relevant ast functions.\n    '\n  Dependencies:\n    Value: logging, ast, typing, get_code_graph, json\n    Purpose: 'The given context involves several dependencies that play crucial roles in achieving the desired functionality within 'py2dataset/get_python_file_details.py'. Understanding their purpose and significance helps us comprehend how they contribute to extracting detailed information from Python source code files effectively.\n      1. logging: This module is a standard Python library used for producing diagnostic output beyond the standard output channel (sys.stdout). It allows developers to create customized log messages with different levels such as DEBUG, INFO, WARNING, ERROR, CRITICAL based on application requirements. In our code context, it's utilized to handle warnings related to file access errors during processing by logging a warning message indicating the error type and file path affected.\n      2. ast (Abstract Syntax Tree): This is another Python standard library that facilitates parsing source code into data structures called Abstract Syntax Trees. It helps developers traverse Python programs more easily by providing a way to analyze them without executing the code itself. In our script, ast is employed to parse Python files into Abstract Syntax Trees which are then traversed using NodeVisitor class inherited from ast.NodeVisitor for extracting necessary details about functions, classes, dependencies, etc.\n      3. typing: This module was introduced in Python 3.5 as an optional package to provide static type hints and type checking capabilities without altering the runtime behavior of Python code. In our context, typing is used with the List[Tuple[str, List[str]] data structure definition for get_all_calls() function arguments 'calls'. This allows defining the expected input format as a list containing tuples with strings representing functions and their respective arguments lists.\n      4. get_code_graph: Although not explicitly mentioned as an external dependency but seems to be a custom-built function within the codebase, it generates directed graphs representing the entire code call graph using networkx library elements like nodes (function nodes, class nodes, method nodes) and edges specifying relationships between them. This graphical representation helps visualize dependencies among functions and classes in the Python file under analysis.\n      5. json: This is a standard Python library used for working with JSON data types. It provides functions to encode Python objects into JSON format strings (json.dumps()) and decode JSON strings back into Python values (json.loads()). In our script, json is utilized to convert file_summary dictionary into a string representation by replacing quotations using replace(). This enables easy transfer of file dependency information when communicating between different modules or saving details into storage mediums supporting JSON format.'\n  Functions:\n    Value: remove_docstring, get_all_calls, get_python_file_details\n    Purpose: 'The given context consists of three significant functions - 'remove_docstring', 'get_all_calls', and 'get_python_file_details' - which play crucial roles within the Python script 'py2dataset/get_python_file_details.py'. Their purposes and functionalities are as follows:\n      1. remove_docstring: This function aims to eliminate docstrings from provided Python code while preserving its syntax structure. It accepts two arguments - a Python code string and an Abstract Syntax Tree representing this code snippet ('tree'). By removing top-level module docstrings along with those within functions and classes, it ensures only the core logic remains intact but without comments or introductory explanations. This helps in focusing on the main functionality of the code while maintaining its internal organization using ast.unparse().\n      2. get_all_calls: Its primary objective is to recursively find all function calls within a given Abstract Syntax Tree node and its subtree. It accepts an AST node as input ('node') along with an optional dictionary ('calls') for accumulating function call lists when none exist initially (default is None). This function discovers instances of ast.Call inside class attributes, list comprehensions, and lambda functions as well, making extensive effort to extract thorough data concerning functional interaction across nested components in a program before finally returning a Dictionary containing mapping from function calls (as strings) to their arguments lists [Function_Calls => [args...]].\n      3. get_python_file_details: This comprehensive function serves the purpose of extracting detailed information from a Python file path provided as input ('file_path'). It performs several steps including opening and parsing the file content into an Abstract Syntax Tree, instantiating a CodeVisitor object to analyze the code structure and dependencies. Afterwards, it fetches a detailed graphical representation of function call relations (entire code graph), control flow structure, and PlantUML notation using 'get_code_graph' integration. The resulting data is formatted into a dictionary containing extracted file details or None in case any error occurs during processing. This function effectively collects all necessary information about the Python script for better understanding of its functionality and organization.'\n  Classes:\n    Value: CodeVisitor\n    Purpose: 'In the given context, the primary focus is on understanding the role of 'CodeVisitor' class within the 'get_python_file_details.py' script which deals with Python source code analysis and extraction of essential details for better comprehension of a file structure. This class plays a crucial part in breaking down complex code into manageable components by traversing an Abstract Syntax Tree (AST) representing the given Python file.\n      [CodeVisitor] is designed as a custom visitor class that inherits from ast.NodeVisitor to facilitate easy navigation through the AST nodes. Its purpose lies in extracting specific details about functions and classes within the codebase while maintaining dependencies, constants, and other relevant information. It helps developers gain insights into the functionality of Python files by collecting necessary data during its traversal process.\n      The significant tasks performed by CodeVisitor are:\n      1. Identifying function definitions ('visit_FunctionDef()') and class definitions ('visit_ClassDef()'). Each extracted detail gets stored in appropriate dictionaries ('functions', 'classes'), allowing easy access later for further processing or visualization purposes.\n      2. Analyzing the entire Abstract Syntax Tree using the 'analyze()' method, which populates 'file_info'. It contains all required file information including dependencies list (used during parsing imports), a summary of function and class definitions ('function_defs', 'class_defs'), and file simplified source code minus documentation string removed with help of the 'remove_docstring' utility. This extensive mapping results in deeper insight for maintaining workflows between objects inside classes, inheritances, attributes, static methods, etc.\n      3. Alongside, it manages a current class context ('current_class') to handle nested class definitions effectively while traversing through the code structure. This helps distinguish between attributes defined within classes and those outside of them during extraction.\n      4. The 'extract_details()' method is central to this process as it collects information about nodes depending on their types ('function', 'method', 'class', or self). It invokes other methods like 'get_all_calls()', ast.walk(), and ast.unparse() to gather specific details related to each node.\n      5. Additionally, CodeVisitor utilizes 'visit_Assign()' to collect constant assignments in the global scope, 'visit()' to call generic visit functions if none is defined explicitly for a node type, and 'generic_visit()' for recursive traversal through child nodes of any given node.\n      In summary, CodeVisitor serves as a core component within this script that extracts meaningful data from Python files by navigating their Abstract Syntax Tree representation, enabling developers to understand complex code structures better and identify relationships between various elements in the program logic.'\n  remove_docstring:\n    Inputs:\n      Value: code, tree\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', the inputs for the function `remove_docstring` are specifically named as 'code' and 'tree'. Their purpose and significance can be elaborated as follows:\n        1. 'code': This input represents the raw Python source code string that needs to have its docstrings removed. Docstrings are blocks of text typically placed at the beginning of modules, functions, classes, or other user-defined objects in Python programs. They serve as documentation comments providing explanations about the purpose and usage of these entities. By removing them using `remove_docstring`, developers can focus on the core logic without being distracted by extra notes.\n        2. 'tree': This input represents an Abstract Syntax Tree (AST) built from the given Python code string through parsing with ast.parse(). An AST is a hierarchical representation of the source code as nodes and connections between them, making it easier to navigate and analyze the program structure without worrying about its syntactical details. In `remove_docstring`, this parsed tree allows accurate targeting and elimination of docstrings at different levels (module, function or class definitions) while keeping intact other important structural elements within Python code by preserving AST relations via ast.unparse() calls later on in the process. This method enables working on an intermediate yet semantically correct version of source code that reflects Python syntax rules accurately even after docstrings are taken away from select components but remains parseable with Pythons abstract language constructs and statements left undisturbed.'\n    Calls:\n      Value: isinstance, tree.body.pop, ast.walk, node.body.pop, ast.unparse\n      Purpose: 'In the context of 'remove_docstring' function within 'py2dataset/get_python_file_details.py', four distinct operations represented by given methods play crucial roles:\n        1. isinstance(checks if an object belongs to a specific class or inherits from it): This method ensures proper identification and handling of Python code elements like functions, classes, async functions within the Abstract Syntax Tree (AST). It helps remove_docstring() function to focus on removing docstrings only from relevant nodes without interfering with other components in the source code.\n        2. tree.body.pop(): This list manipulation method deletes an element at index 0 from tree's 'body' attribute if a certain condition is met. Here, it checks if tree.body contains a Python expression representing a docstring (root node as ast.Expr holding ast.Str instance) at its first position. If found, this operation removes the top-level module docstring to eliminate it from the source code string after traversing AST subtrees for other docstrings inside functions and classes.\n        3. ast.walk(): This recursive generator function walks through each node in the Abstract Syntax Tree starting with 'node'. It's utilized by CodeVisitor class methods like extract_details(), visit_FunctionDef(), etc., enabling comprehensive extraction of relevant information by navigating nodes layer-wise, allowing data retrieval even within nested elements of AST structure. In remove_docstring(), ast.walk() is indirectly called as part of recursive traversal within get_all_calls().\n        4. node.body.pop(): Similar to tree.body.pop(), this call deletes an element from a node's 'body' attribute if specific conditions are satisfied. In remove_docstring(), it targets nodes inside functions or classes (isinstance checks) containing docstrings at the first position of their body list. This ensures removing docstrings from nested function/class definitions as well, keeping only code syntax intact while discarding comments and top-level module docstrings.\n        5. ast.unparse(): This method converts an Abstract Syntax Tree node back into a Python source code string maintaining its original structure but without removed docstrings from prior manipulations such as popping elements via tree.body.pop() and node.body.pop(). The returned string reflects sanitized Python code stripped off unnecessary comments while preserving its syntax for further processing or analysis by other functions like get_all_calls().'\n    Variables:\n      Value: tree, first_body_node, code\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', particularly within the function 'remove_docstring', the mentioned variables serve crucial purposes as follows:\n        1. tree: This variable represents an Abstract Syntax Tree generated using ast.parse() for the provided Python code string. It holds the internal structure of the source code in a format that's easier to navigate and manipulate programmatically. In 'remove_docstring', tree acts as input to remove docstrings while preserving the syntax intact by applying changes only on the abstract representation without altering the original code stored in 'code'.\n        2. first_body_node: Inside 'remove_docstring', this variable refers to the initial node encountered during traversal within the Abstract Syntax Tree (tree). Its purpose is to identify whether the current node being processed is a function or class definition with an accompanying docstring at its beginning. If so, it gets removed from tree's body list by indexing it using 'node.body.pop(0)'.\n        3. code: This variable holds the original Python source code string provided as input to the script. It represents the raw textual representation of the file before any modifications are made during analysis or documentation removal processes like in 'remove_docstring'. The sanitized version without docstrings is returned after invoking ast.unparse(tree) at the end of the function call, ensuring no change is done directly on code itself but only within Abstract Syntax Tree representation (tree).'\n    Returns:\n      Value: ast.unparse(tree)\n      Purpose: 'In the given context relating to 'remove_docstring' function within 'py2dataset/get_python_file_details.py', the return value involving [ast.unparse(tree)] holds significance when sanitizing Python code by stripping off docstrings while preserving its syntax structure. This operation ensures that the original code's semantic meaning remains intact even after removing comments and top-level documentation strings from functions or classes.\n        The 'remove_docstring' function primarily achieves two purposes:\n        1. Removing Docstrings: It deletes comment strings accompanying a module definition (top level docstring), in addition to trimming topmost strings embedded inside FunctionDef or ClassDef statements found in Python source code snippet ('tree'). It acts upon an accepted Argument 'code' that signifies Python input code and processed Abstract Syntax Tree representation of the same called as 'tree'. This makes ast.unparse(tree) instrumental as it generates cleaned yet structurally preserved output string without Docstrings while keeping syntax correct after applying all modifications required to eradicate docstrings at multiple levels.\n        2. Providing Cleaned Code Representation: The result returned by [ast.unparse(tree)] offers developers a clear view of Python code sans comments and top-level documentation strings. This simplified version serves as a starting point for further analysis processes such as AST traversal using 'CodeVisitor' class, where complex logic relies on retaining valid syntax even after eliminating Docstrings from source code.'\n  get_all_calls:\n    Inputs:\n      Value: node, calls\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', the function `get_all_calls` plays a crucial role within the larger framework to extract comprehensive information about function calls present in a Python codebase. Its primary purpose is to traverse an Abstract Syntax Tree (AST) starting from a given node and identify all occurrences of function call expressions recursively, including nested instances found in class attributes, list comprehensions, or lambda functions.\n        The two inputs for `get_all_calls` are as follows:\n        1. 'node': This input is the root node acting as the starting point of traversal within the AST subtree where the function searches for ast.Call objects denoting calls to Python functions. As this node acts as a seed for exploration, it significantly impacts what part of the code gets examined and determines how thoroughly function calls are located across various layers in the program structure.\n        2. 'calls': This parameter serves as an optional accumulator for storing discovered function call details during traversal. If no initial list is provided (Default behavior), `get_all_calls` creates an empty dictionary ['Dict[str, List[str]]]. As the function iterates through the AST nodes, it appends identified function calls along with their arguments into this accumulator list. Eventually, after returning from the traversal process, `get_all_calls` transforms this accumulated data into a dictionary format where keys represent function names and values are lists containing their respective arguments ('Dict[str, List[str]]'). Thus, 'calls' enables tracking discovered calls for final return results that ultimately form essential connections between code entities within Python scripts.'\n    Calls:\n      Value: isinstance, calls.append, ast.unparse, get_all_calls, ast.iter_child_nodes, calls_dict[func].extend\n      Purpose: 'In the context of `get_all_calls` function within the 'py2dataset/get_python_file_details.py' script, several important methods and built-in Python facilities are being employed for comprehensively traversing and identifying function calls throughout the Abstract Syntax Tree (AST) provided as its main argument `node`. Their significance in understanding program logic and effectiveness lie in constructing a detailed dictionary of all found function call occurrences with respective arguments within subtrees. Let's delve deeper into each call mentioned:\n        1. isinstance(node, ast.Call): This check determines if the current node being processed during recursion is an instance of `ast.Call`, which signifies a Python function invocation in the codebase. It's vital because if an object satisfies this criterion, then the program continues accumulating related function calls with respective arguments as the method advances down through its nested levels (including complex ones found inside attributes and lambda functions).\n        2. calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]): When a function call is identified, it gets appended to the 'calls' list as a tuple containing the function name (after unparsing the `node.func` using `ast.unparse`) and a list of arguments obtained by iterating over `node.args`, applying `ast.unparse` on each argument value. This way, the function call gets stored in a format that's human-readable while maintaining syntax integrity.\n        3. get_all_calls(child, calls): As recursion traverses through subtrees beneath `node`, it repeatedly invokes this function to process further nodes (represented by `child`) with existing call list `calls` maintained during the initial invocation of `get_all_calls`. It keeps collecting function calls and their arguments from each nested level, thus ensuring exhaustive search for all occurrences.\n        4. ast.iter_child_nodes(node): This built-in Python facility traverses child nodes under the given node (`node`) in a depth-first manner. It helps explore the entire subtree efficiently while handling various types of nested structures within the AST, such as classes, functions, attributes, etc., ensuring no function call is missed during recursion.\n        5. calls_dict[func].extend(args): After identifying all the unique function names ('func') obtained by looping through accumulated call information ('calls'), it appends argument lists retrieved during previous iterations (i.e., args) under each function name in `calls_dict`. This step ensures a dictionary structure where keys are distinct functions while values are their respective arguments lists, forming a comprehensive mapping of all identified function calls within the subtree rooted at `node`.\n        In summary, these calls within `get_all_calls` contribute to efficiently finding and cataloging Python function call occurrences throughout an abstract syntax tree's various nestings level with essential syntax information, laying foundation for thorough interpretation and exploration of given Python source codes in later parts of the overall process executed by this codebase.'\n    Variables:\n      Value: calls, calls_dict, node\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', specifically within the function `get_all_calls`, three variables play crucial roles to achieve its objective of finding all function calls in a subtree rooted at a provided node within an Abstract Syntax Tree (AST).\n        1. calls: This variable serves as an accumulator for storing function call details discovered during recursive traversal through the AST. Initially, it is set to None but gets assigned a list of tuples containing calling functions and their arguments when invoked with an initial empty list ['List[Tuple[str, List[str]]']. As the algorithm progresses, this variable collects all function calls found in the tree structure and eventually returns as a dictionary representing call relationships.\n        2. calls_dict: This variable is initialized to None within `get_all_calls` but gets built after completing traversal by converting the 'calls' list into a dictionary format. Each unique function name becomes a key holding its corresponding arguments as values ['Dict[str, List[str]]'. The resulting dictionary represents a mapping of functions with their respective calls and inputs for further analysis or storage purposes.\n        3. node: This parameter is passed as an argument to `get_all_calls` function and acts as the root node from where traversal starts in search of function calls within the AST subtree. It could be any instance of ast.AST representing a Python code segment. As the algorithm progresses through the tree, 'node' represents the current position being inspected by `get_all_calls` while processing each level down until it exhausts all call instances within the subtree.'\n    Returns:\n      Value: calls_dict\n      Purpose: \"In the given context relating to the 'get_python_file_details.py' script inside the 'py2dataset' module, the function `get_all_calls` plays a crucial role within its nested usage in the `CodeVisitor` class for extracting information on all identified function calls in the Abstract Syntax Tree (AST) traversal process. This function significantly contributes to generating details about Python code behavior by capturing call relationships among functions throughout the program structure.\\n\\nThe primary purpose of `get_all_calls` is to recursively find every occurrence of ast.Call nodes within an AST subtree rooted at a given node while considering nested function calls in class attributes, list comprehensions, and lambda functions as well. It returns a dictionary mapping each identified function call as a key to its respective arguments listed as values. This data structure helps developers understand the flow of function invocations within the codebase more clearly.\\n\\nBreaking down `get_all_calls`'s API signature:\\n1. Node (ast.AST): The root node from where search begins for function calls in the AST traversal process.\\n2. Calls (List[Tuple[str, List[str]], optional): An accumulator used to store found function call details as tuples of (Function Name, Arguments List). If not provided initially, it defaults to an empty list ['None'].\\n\\nUpon execution, `get_all_calls` performs the following actions:\\n- If 'calls' is None, initializes it as an empty tuple list [] otherwise works upon accumulated information up to now.\\n- Processes recursive tree traversal via children calls ('for child in ast.iter_child_nodes(node)' iteration), iteratively exploring ast nodes looking for matches against ast.Call nodes where the actual function call occurrence exists. During matching instances, these invocations get added as new key-value pairs in the 'calls' dictionary with function names obtained from ast.unparse() and arguments extracted from node's args attribute ('[ast.unparse(arg) for arg in node.args]').\\n   a) The 'args' part creates an argument list extracted directly from nodes Args tuple property - 'node.args.args'. This represents actual parameter lists passed when invoking functions during runtime.\\n- After traversing the entire tree, `get_all_calls` constructs a dictionary ('calls_dict') using accumulated function call details where keys are unique function names and values correspond to their respective argument lists. This dictionary serves as an essential output for further analysis or visualization purposes in the overall code processing pipeline.\"\n  get_python_file_details:\n    Inputs:\n      Value: file_path\n      Purpose: 'In the context given for 'get_py2dataset/get_python_file_details.py' script, the input parameter 'file_path' holds significant value as it represents the path to a Python file that needs detailed analysis and information extraction. This input serves as the primary source from where all further operations are initiated within the function get_python_file_details().\n        The role of 'file_path' can be broken down into two crucial aspects when dealing with `get_python_file_details`:\n        1. Data Retrieval - This string acts as an anchor pointing towards a particular Python source code file which serves as the starting point for collecting valuable metadata required for constructing insights into the script's inner workings. The function opens this file using 'open()', reads its content, and then parses it into an Abstract Syntax Tree (AST) using ast.parse(). This AST representation further feeds multiple procedures essential in fetching descriptive statistics regarding code structures.\n        2. Analysis Framework Coordination - Since get_python_file_details calls numerous supporting elements throughout execution to process and accumulate comprehensive information, the referenced file by 'file_path' provides a base upon which those auxiliary methods work collectively to gather detailed Python code knowledge such as functions definitions, class definitions, dependencies, constants, function call relationships, control flow structures, and graphical representations for visualization. These data elements help developers gain an improved understanding of the target Python file and improve code analysis capability with regards to potential interlinking dependencies, documentation patterns or inherent object properties in terms of a specified algorithmic layout (Control Flow Graph and PlantUML representation).\n        To sum up, 'file_path' serves as the key entry point to `get_python_file_details` function providing essential access to the Python source code under inspection while setting the context for all subsequent operations within this utility function. It enables a deep dive into analyzing Python scripts and extracting crucial details about their structure, dependencies, relationships, and visualization possibilities.'\n    Calls:\n      Value: open, f.read, ast.parse, logging.warning, CodeVisitor, visitor.analyze, get_code_graph, json.dumps(file_summary).replace, json.dumps\n      Purpose: 'In the `get_python_file_details` function within 'py2dataset/get_python_file_details.py', several critical operations are executed to extract detailed information from Python source code files. These functions serve unique purposes, which are as follows:\n        1. open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\"): This built-in Python function opens the specified file path given as an argument in read mode (\"r\"). It enables reading contents from the provided file while handling any potential encoding issues using UTF-8 encoding and ignoring invalid characters.\n        2. f.read(): After opening the file with 'open()', this method reads its entire content into memory as a string variable named 'code'. This step prepares the raw Python code for further processing.\n        3. ast.parse(code): Here, 'ast' stands for Abstract Syntax Tree from Python's AST module. It takes the previously read source code and parses it into an Abstract Syntax Tree representation. This tree structure helps analyze the code more efficiently by breaking down its elements into nodes representing different programming constructs like functions, classes, imports, etc.\n        4. logging.warning(f\"{e} error in file: {file_path}\") : This call invokes a warning message from Python's built-in 'logging' module when an exception occurs during processing (PermissionError, SyntaxError or IOError). It logs the error message along with the affected file path to notify developers about potential issues.\n        5. CodeVisitor(code, tree): A custom user-defined class initialized for handling Abstract Syntax Tree traversal and extracting specific code details such as function calls, docstrings, dependencies, etc. The 'CodeVisitor' object 'visitor' will store and process relevant data collected throughout its lifetime by inspecting the AST 'tree'.\n        6. visitor.analyze(tree): Once CodeVisitor is instantiated with required parameters, this method triggers analysis of the Abstract Syntax Tree to populate instance attributes like 'functions', 'classes', and 'file_info' with parsed information from Python code. This step plays a significant role in preparing extracted details about dependencies, functions, classes, constants, etc.\n        7. get_code_graph(file_summary, file_ast): An external function call to generate a directed graph representation of the entire code call graph using networkx library. It also creates control flow structure and PlantUML notation for visualization purposes. These representations aid in understanding complex relationships between functions, classes, methods, etc., within the Python file.\n        8. json.dumps(file_summary).replace('\"', \"\"): 'json' is Python's standard JSON encoding and decoding library used to convert Python objects into JSON strings for storing file dependencies summaries. In this case, it converts 'file_summary' dictionary into a JSON string but replaces double quotes with empty strings ('\"\"') as they are not valid in JSON format. This ensures the final output is suitable for storage and sharing across various systems without error issues related to quote usage.\n        9. json.dumps(): After returning the overall extracted details in a nested dictionary form from get_python_file_details(), this function call again converts the result into JSON string representation if required by the user for serialization purposes. However, it is not directly present within 'get_python_file_details'.'\n    Variables:\n      Value: file_ast, tree, visitor, file_details, file_path, code, file_summary\n      Purpose: 'In the context of 'get_python_file_details', each variable plays a distinct role contributing to the overall process of extracting detailed information from Python source code files. Here's their purpose and significance:\n        1. file_ast: This variable represents the Abstract Syntax Tree (AST) of the parsed Python source code corresponding to a particular file path input given. The AST structure facilitates navigating the Python program at an abstract level which eases parsing information related to docstrings, dependencies, constants, function calls etc., helping CodeVisitor to extract crucial insights from the source code.\n        2. tree: Similar to file_ast but exists within 'CodeVisitor' class's constructor where it receives tree as input along with Python code string 'code'. This variable holds the Abstract Syntax Tree of parsed Python code while initializing an instance of CodeVisitor. The tree serves as a foundation for traversing and analyzing the code structure during object instantiation.\n        3. visitor: An object of class 'CodeVisitor' initialized using provided Python source code 'code' and corresponding Abstract Syntax Tree 'tree'. Visitor instantiated this way will perform the main tasks related to gathering function details, class details etc., through traversal utilizing various methods of CodeVisitor class like visit_FunctionDef(), visit_ClassDef() etc.\n        4. file_details: This variable holds a dictionary containing all extracted information from the Python source code after processing by 'CodeVisitor'. It consolidates data collected during analysis such as function definitions, class definitions, dependencies, constants etc., making it easily accessible for further use or storage outside the function scope.\n        5. file_path: The input argument representing the path to a Python file whose details need extraction. This string is used by 'get_python_file_details' function to open and read the source code using built-in 'open()', which then gets parsed into Abstract Syntax Tree for further analysis.\n        6. code: A local variable created within get_python_file_details when opening a Python file at 'file_path'. It holds the contents of the input file in string format that's later passed to ast.parse() function to generate Abstract Syntax Tree (tree).\n        7. file_summary: This variable stores a subset of extracted information about the Python file in JSON format within 'file_info' dictionary of 'file_details'. It contains details like dependencies, function definitions and class definitions but excludes advanced features such as control flow structure or PlantUML notation generated separately using get_code_graph(). The JSON representation makes it easy to share this summary across systems or applications.'\n    Returns:\n      Value: file_details, None\n      Purpose: 'In the context given for 'get_python_file_details.py', the function `get_python_file_details(file_path: str)` holds paramount significance as it acts as the main gateway to fetch exhaustive data insights regarding Python files under scrutiny. When functioning appropriately, this function yields a detailed dictionary [file_details] encapsulating all extracted information from the analyzed source code file. This data encompasses elements like function definitions, class details, dependencies, constants present within the script, entire code graph representation along with control flow structure, and PlantUML notation for visualization purposes. The obtained output [file_details] empowers developers to better understand the Python file's functionality by providing a comprehensive overview of its structure and relationships between various components.\n        On the other hand, when an error occurs during processing (PermissionError, SyntaxError, IOError), `get_python_file_details()` returns 'None'. This null value signifies some problematic situation such as insufficient permissions to access the file, incorrect syntax in the code or I/O errors while reading the file content. It alerts developers about potential issues that might need attention before proceeding further with analysis.'\n  CodeVisitor:\n    Methods:\n      Value: __init__, visit_FunctionDef, visit_ClassDef, generic_visit, visit_Assign, extract_details, analyze\n      Purpose: \"In the CodeVisitor class within the given context of 'get_python_file_details.py', several methods play crucial roles contributing towards extracting valuable details from a Python file using its Abstract Syntax Tree representation:\\n\\n1. __init__(self, code: str, tree: ast.AST) -> None:\\n   - This method acts as the constructor initializing the CodeVisitor object by assigning provided source code and Abstract Syntax Tree instance to class attributes 'code' and 'tree', setting up empty dictionaries for 'functions', 'classes', 'file_info', and an empty list for 'constants'. It also sets current_class attribute to None indicating no active class context yet.\\n\\n2. visit_FunctionDef(node: ast.FunctionDef) -> None:\\n   - This method specifically targets FunctionDef nodes in the AST walk and invokes extract_details() passing 'function' as node type. It stores the extracted details about a function into the 'functions' dictionary under the key corresponding to its name.\\n\\n3. visit_ClassDef(node: ast.ClassDef) -> None:\\n   - Similarly, it focuses on ClassDef nodes in AST traversal and again calls extract_details() with 'class' as node type. The extracted details are stored into the 'classes' dictionary under class name keys. Additionally, if inside a class definition (current_class is set), it also updates attributes for enclosed methods under their respective class name key within the same dictionary.\\n\\n4. generic_visit(self, node):\\n   - This utility method serves when no specific visit function exists for a node type. It iterates through child nodes of given 'node', sets parent attribute to maintain AST structure and recursively calls self.visit() on each child node.\\n\\n5. visit_Assign(self, node: ast.Assign):\\n   - This method is responsible for collecting constants from the Python file by identifying assignments within the top-level module scope where values are strings. It appends constant assignment expressions into a list stored in 'constants' attribute.\\n\\n6. extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]:\\n   - This key method extracts specific details about a node depending on the passed node type ('function', 'method', 'class', or 'self'). It processes AST walk of given node collecting attributes like name, docstrings, inputs/outputs, call data, returns, annotations, etc., and returns a dictionary containing these extracted details. If node_type is 'class'/'method', it also updates class attributes lists accordingly.\\n\\n7. analyze(self, node: ast.AST) -> None:\\n   - The central analysis method in CodeVisitor traverses the Abstract Syntax Tree node ('node'), calling self.visit() on all its child nodes and compiles details captured in previous methods into 'file_info' dictionary (like file dependencies, constants list). It then builds comprehensive Python file summaries using function_defs & class_defs lists generated from functions & classes dictionaries respectively. Finally, it generates sanitized code without docstrings for easier parsing by get_code_graph().\\n\\nIn summary, these methods work together to traverse the Abstract Syntax Tree of a Python file, extract relevant details about functions and classes, maintain contextual information like constants and dependencies, and prepare data structures required for further analysis or visualization purposes.\"\n    Attributes:\n      Value: tree, current_class, current_class, file_info\n      Purpose: 'In the context of 'CodeVisitor' class within the given Python script 'py2dataset/get_python_file_details.py', these attributes hold significant roles during analysis and extraction of details from a Python source code file using Abstract Syntax Tree (AST). Here is an explanation for each mentioned attribute:\n        1. tree: This attribute represents the parsed Abstract Syntax Tree of the input Python code when instantiating 'CodeVisitor'. It acts as a foundation for traversing the code structure and extracting necessary information about functions, classes, dependencies, etc., enabling better understanding of the program logic. As 'tree' stores the parsed representation of the original source code string, it becomes an essential ingredient for navigating through different nodes within the AST.\n        2. current_class (twice mentioned but refers to the same concept): This attribute serves as a mechanism to track and manage nested class definitions during traversal. When 'CodeVisitor' encounters a ClassDef node while visiting the Abstract Syntax Tree, it sets 'current_class' to indicate that the code execution is within a specific class context. Once finished with this class definition, 'current_class' gets reset to None signifying the exit from the nested scope. This attribute helps differentiate between global functions and methods (outside any class) against class functions (inside classes) and methods in extracting accurate details.\n        3. file_info: As its name suggests, this attribute collects various summary details about the Python file being processed by 'CodeVisitor'. It stores crucial information like dependencies, constants, function definitions, class definitions, simplified code without comments ('file_code_simplified') for reviewers preferring easy reading or test scenarios without distraction. When processing 'analyze' method finishes gathering insights throughout AST traversal, the collected data gets stored in this attribute as a dictionary ready to be incorporated into final output when calling get_python_file_details(). This consolidated information offers an overview of the file structure and functionality at a glance.'\n    Inheritance:\n      Value: ast.NodeVisitor\n      Purpose: \"In the given Python script 'py2dataset/get_python_file_details.py', the class 'CodeVisitor' inherits from ast.NodeVisitor which plays a crucial role in facilitating traversal through an Abstract Syntax Tree (AST) representing Python code. This inheritance enables CodeVisitor to efficiently navigate and extract relevant details about functions, classes, dependencies, constants, etc., while analyzing the code structure.\\n\\nThe NodeVisitor class from ast module provides essential methods such as visit(), which gets overridden by CodeVisitor in custom ways to accomplish specific tasks during traversal\\u2014visiting particular types of AST nodes. Its major objectives within CodeVisitor include tracking information regarding method/function definitions and attributes during their traversals for comprehensive understanding and structuring into separate attribute lists like 'functions', 'classes', and 'file_info'.\\n\\nSome significant methods in CodeVisitor are:\\n1. visit_FunctionDef(): Extracts details about Python functions, storing them under the 'functions' dictionary attribute when visiting a FunctionDef node in AST traversal.\\n2. visit_ClassDef(): Gathers information associated with class definitions storing into dictionary format inside attribute 'classes'. Here also updating respective self._current_class while stepping in (signaling to note operations pertinent only for internal Class nodes), after finishing it resets the current_class attribute.\\n3. generic_visit(): Handles other cases when no specific visit method exists for a node, iterates over child nodes continuing traversal within ast framework by calling the 'visit()' method inherited from ast.NodeVisitor base class.\\n4. extract_details(): Performs crucial work capturing information related to individual AST nodes based on their type (function/method or class). This includes functions inputs, returns, call graphs, etc., in suitable formats which further feed into overall 'file_info', 'functions' or 'classes'. It provides key data pieces needed to represent a clear image of code under different scopes and constructs.\\n5. analyze(): Traverses the entire Abstract Syntax Tree ('node') to collect dependencies, function definitions, class definitions, constants, etc., for storing in respective attributes like 'file_dependencies', 'function_defs', 'class_defs'. It also generates a file summary JSON format and simplified code without docstrings.\\n\\nIn essence, the inheritance from ast.NodeVisitor significantly impacts CodeVisitor's capabilities to parse Python code comprehensively, allowing for robust analysis while traversing through AST nodes and generating essential data structures representing functions, classes, dependencies, etc., thus providing developers a detailed software documentation for better understanding of given Python files.\"\n  CodeVisitor.__init__:\n    Inputs:\n      Value: self, code, tree\n      Purpose: 'In the context given for CodeVisitor class initialization (or __init__ method), three main inputs are being passed: 'self', 'code', and 'tree'. Understanding their roles helps us comprehend how this class instance gets prepared to analyze Python code effectively.\n        1. self: This keyword represents the instance of the currently being constructed CodeVisitor object itself during instantiation. In OOP languages like Python, it refers to the current object as an argument in methods and acts as a pointer back to the instance attributes and methods defined within the class. Here, 'self' allows accessing properties such as 'functions', 'classes', 'file_info', etc., which will be populated during the traversal of Abstract Syntax Tree (AST).\n        2. code: This input argument represents the raw Python source code string that needs to be analyzed by the CodeVisitor instance. It is initially provided when creating an object and serves as a reference point for storing information related to function definitions, class definitions, dependencies, constants, etc., in respective attributes like 'functions', 'classes', etc.\n        3. tree: The third input argument 'tree' is a parsed Abstract Syntax Tree representation of the Python code provided by 'code'. This tree structure helps CodeVisitor navigate through the program logic easily using ast.NodeVisitor inheritance and its methods such as visit_FunctionDef(), visit_ClassDef(), etc., enabling extraction of necessary details about functions, classes, dependencies, etc. It assists in understanding the control flow and relationship between different elements within the Python file more efficiently than working with raw code strings alone.'\n    Variables:\n      Value: self, tree, code\n      Purpose: 'In the context of 'CodeVisitor' class initialization method __init__, the mentioned variables have distinct roles during object setup for parsing and traversing Python code using Abstract Syntax Tree (AST).\n        1. self: This refers to the instance of the CodeVisitor class itself when used within methods or functions inside the class body. It allows access to attributes and methods defined within that particular object, creating scope binding with instantiation data such as source code or tree structures for later usage. When working within the class methods like __init__, 'self' is used to interact with those declared attributes (functions, classes, file_info, current_class, constants) or methods (visit_FunctionDef, visit_ClassDef, extract_details, analyze).\n        2. tree: This variable represents the Abstract Syntax Tree generated from the provided Python source code using ast.parse(). The tree holds the structural representation of Python code elements as nodes connected by edges forming a directed acyclic graph (AST). It's passed into __init__ along with 'code' and acts as a base for traversal and analysis performed within CodeVisitor instances during further method calls like analyze() or extract_details().\n        3. code: It indicates the input raw source code String, passed upon instantiating a new instance of the class, captured right from __init__ method parameters (\"self.__init__(code: str, tree: ast.AST)\" definition). This variable is essential for storing original Python file content that will be analyzed by the CodeVisitor object later during traversal or extraction operations within the class methods. It helps in connecting the actual code to its corresponding AST representation ('tree') for accurate interpretation and manipulation.'\n  CodeVisitor.visit_FunctionDef:\n    Inputs:\n      Value: self, node\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', we focus on understanding the role of inputs within the `CodeVisitor.visit_FunctionDef` method. This particular function forms a part of the CodeVisitor class which traverses an Abstract Syntax Tree (AST) to extract details about Python code.\n        1. 'self': Self-referencing instance of the CodeVisitor object invoking this visit_FunctionDef() method. It provides access to other important attributes and methods such as code (source code string), functions (dict to store function details), classes (dict for class details), file_info (general info about the file), current_class (tracking nested class definitions context), constants list, etcetera. When traversing the AST node related to a FunctionDef node invoking visit_FunctionDef(), self enables leveraging instance properties efficiently during detail extraction process and subsequent actions.\n        2. 'node': It denotes the Abstract Syntax Tree Node which is being visited specifically representing a FunctionDef within Python codebase. The visit_FunctionDef() function processes this node to extract relevant information about functions, their details such as name, inputs, returns, docstrings, annotations, etc., and stores them in attributes like 'functions'. By taking the FunctionDef AST Node input during visit_FunctionDef() operation, precise location (code structure level) becomes easy for necessary attribute modification while progressively maintaining integrity in node relationships within Python source code.'\n    Calls:\n      Value: self.extract_details, self.generic_visit\n      Purpose: \"In the context of 'CodeVisitor' class within Python's get_python_file_details script, two important calls are executed in the `visit_FunctionDef` method: self.extract_details and self.generic_visit. Their purpose and significance can be elaborated as follows:\\n\\n1. self.extract_details():\\n   This call initiates the process of extracting comprehensive details about a given function definition encountered during Abstract Syntax Tree traversal within `CodeVisitor`. It gathers information such as function name, code representation (without docstrings), inputs, returns, calls, variables used, decorators applied, and annotations associated with the function. Additionally, if the current context is inside a class definition ('current_class' attribute is set), it also collects details about class methods and attributes. The extracted data is stored in 'functions' or 'classes' dictionaries according to context before moving ahead for further AST traversal within the same method itself via self.visit(node). This crucial step plays a significant role in accumulating vital code information necessary for detailed analysis of Python files.\\n\\n2. self.generic_visit():\\n   After invoking self.extract_details(), this call continues the traversal process in `CodeVisitor`. It handles any remaining nodes in the subtree of the function definition without explicitly defined visit methods in the class. By default, it recursively iterates through child nodes using ast.iter_child_nodes() and calls their respective visitor functions if available or performs self.visit() for undefined ones (inherited from NodeVisitor class). The purpose here is to ensure complete traversal of all AST components relevant to the Python code being analyzed, facilitating extraction of every vital data piece throughout `visit_FunctionDef` processing. It further reinforces proper documentation handling during Ast node analysis, laying the foundation for constructing an accurate representation of file details in 'CodeVisitor'.\"\n    Variables:\n      Value: self, details, node\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', particularly within the 'CodeVisitor' class, we focus on understanding the roles of variables `self`, `details`, and `node` in the method `visit_FunctionDef`. This method is a part of CodeVisitor, an AST traversing class for Python code extraction.\n        1. self: Within methods like `visit_FunctionDef`, 'self' represents the current instance (CodeVisitor object itself) creating an easier way to access class attributes such as code string stored initially while initialization and parse results extracted via traversal (functions, classes, file_info). It helps bind necessary information for analysis purposes.\n        2. details: This variable stores the extracted details about a specific node encountered during AST traversal. In `visit_FunctionDef`, it collects information related to Python functions. The `extract_details()` method populates 'details' with function-specific properties such as name, docstrings, inputs/outputs arguments, return statements, annotations, decorators, etc., after parsing node data obtained through `ast.walk`. As we walk across a FunctionDef node during traversal, the acquired information gets updated here and finally used to fill attributes within class instances (self.functions).\n        3. node: It represents the current Abstract Syntax Tree node being visited in CodeVisitor methods like `visit_FunctionDef`. Here, 'node' is an instance of ast.FunctionDef which signifies a function definition encountered during traversal. This node serves as the central point for extracting relevant details about functions within Python code and passing it to `extract_details()` method for further processing.\n        In summary, `self`, `details`, and `node` in `CodeVisitor.visit_FunctionDef` are essential components for efficiently analyzing a Python file's Abstract Syntax Tree structure by gathering functional details about each encountered FunctionDef node during traversal. 'self' provides contextual information from the class instance, 'details' stores extracted data related to the current node being processed (function definition), and 'node' refers to the specific AST node currently inspected during traversal.'\n  CodeVisitor.visit_ClassDef:\n    Inputs:\n      Value: self, node\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', the CodeVisitor class is implemented with multiple visit methods as a way to handle various node types found in Python abstract syntax tree during its traversal for code analysis and detail extraction. Among them, `visit_ClassDef` focuses on extracting details specific to class definitions within the Abstract Syntax Tree (AST). Here are the significances of 'self' and 'node' inputs to this method:\n        1. self: This refers to the instance of the CodeVisitor object itself when the visit_ClassDef method is invoked. It carries crucial attributes such as code (original Python source), functions, classes, file_info, constants, current_class (to keep track of nested class definitions), tree (parsed AST), etc. During traversal, self helps access these attributes to store extracted details appropriately in respective instance variables like functions or classes dictionaries.\n        2. node: This input represents the current Abstract Syntax Tree node being visited by CodeVisitor during its traversal process. In this case, it is an ast.ClassDef type that marks the occurrence of class definition statements. Providing a concrete instance allows examining nodes at specific hierarchy levels where we wish to implement visit method behavior to understand its surrounding environment effectively. By analyzing node attributes and subnodes within node_walk list generated by ast.walk(node), CodeVisitor can extract relevant information about classes such as class name, methods defined inside it, inheritance details, static methods decorators, etc., updating the classes dictionary attribute accordingly.'\n    Calls:\n      Value: self.extract_details, self.generic_visit\n      Purpose: 'In the CodeVisitor class within the visit_ClassDef method, two important calls stand out - self.extract_details and self.generic_visit. Their purposes are closely connected as they collaborate to extract comprehensive details about classes in Python code during Abstract Syntax Tree traversal.\n        1. self.extract_details(): This call initiates the process of gathering class information when a ClassDef node is encountered. It gathers details like class name, its method definitions with associated inputs, returns, decorators, static methods inherited from parents, properties related to attribute assignment inside classes, etc., by invoking the extract_details() instance method. The extracted data populates the 'classes' dictionary in CodeVisitor class attributes for later reference or usage within the program.\n        2. self.generic_visit(): This call acts as a backup strategy if there isn't any specific visitor function defined for a particular node type. It traverses the Abstract Syntax Tree further by iterating over child nodes of the current node and recursively visiting each node through visit(). Since we have visit_ClassDef explicitly implemented, generic_visit plays only secondary role within this method to continue the tree traversal when there are subnodes related to ClassDef other than function calls or properties directly affecting classes (assignment expressions concerning class attributes are managed via 'visit_Assign()' separately). The combined actions of both methods in CodeVisitor.visit_ClassDef ensure thorough extraction and analysis of class-related details from Python code during Abstract Syntax Tree traversal.'\n    Variables:\n      Value: self, node\n      Purpose: 'In the context given from 'py2dataset/get_python_file_details.py', specifically within the CodeVisitor class, we focus on understanding the roles of 'self' and 'node' variables during the execution of `visit_ClassDef` method.\n        1. self: This keyword refers to the instance of the CodeVisitor object itself when used inside any non-static method or function within a class definition in Python. In our case, it represents an initialized instance of CodeVisitor that keeps track of various attributes like code (source code), functions dictionary, classes dictionary, file_info dictionary, constants list, etc. When invoking methods on self within `visit_ClassDef`, we are interacting with properties maintained by this CodeVisitor instance, like its parent ast.AST tree for reference tracking in its `generic_visit(node)` call or updating attributes related to classes during traversal.\n        2. node: This parameter represents the current Abstract Syntax Tree (AST) node being visited inside the `CodeVisitor` class's `visit_ClassDef` method. It could be an instance of ast.ClassDef representing a Python class definition encountered while traversing the AST tree. Here, 'node' helps in extracting relevant details about classes within the source code and updating respective dictionaries ('classes') during traversal. The node acts as a reference point to the current position in the Abstract Syntax Tree being analyzed by CodeVisitor.\n        In summary, 'self' is an instance of the CodeVisitor class containing useful information pertaining to Python code analysis while 'node' denotes the AST node under scrutiny at any given moment within `visit_ClassDef`. Together they help perform meaningful actions on code representation during the traversal process to gather essential details about classes present in the source code.'\n  CodeVisitor.generic_visit:\n    Inputs:\n      Value: self, node\n      Purpose: 'In the given context within the CodeVisitor class, the method `generic_visit()` serves as a base for handling node types where explicit visitor functions don't exist. It ensures traversal continuation to subsequent nodes in Abstract Syntax Tree (AST) after processing specific nodes like FunctionDef or ClassDef using respective visitor methods like `visit_FunctionDef`, `visit_ClassDef`. Self refers to the current instance of the CodeVisitor class when called, utilizing its properties such as `tree`, `constants`, and various dictionaries (`functions`, `classes`, etc.) stored during AST traversal.\n        The input 'node' represents an Abstract Syntax Tree node encountered during traversal. It can be any type of valid Python code construct like function definitions, class definitions, imports, assignments, etc., depending upon the progression in the tree exploration. Inside `generic_visit()`, this node is iterated through using `ast.iter_child_nodes()` to further traverse its child nodes and invoke appropriate visitor methods if available or perform generic actions like updating constants list when dealing with module level assignments.\n        In summary, 'self' provides contextual information about the CodeVisitor instance while 'node' represents the current node being processed during AST traversal within `CodeVisitor.generic_visit()`. Together they enable efficient extraction of code details and maintain a comprehensive understanding of Python source code structure during analysis.'\n    Calls:\n      Value: ast.iter_child_nodes, self.visit\n      Purpose: 'In the given context within the CodeVisitor class, particularly inside the method 'generic_visit', both 'ast.iter_child_nodes' and 'self.visit' serve significant roles in traversing through an Abstract Syntax Tree (AST) efficiently during analysis of Python code details extraction. Let's elaborate on their individual contributions:\n        1. ast.iter_child_nodes: This built-in Python function associated with AST nodes provides a generator that yields each child node of the current node recursively, which is essentially iterating through every descendant in the subtree below it (including its children and further descendants). This facilitates an effective way to handle tree structures inherent to AST. CodeVisitor utilizes ast.iter_child_nodes as a source of iteration across all relevant child nodes in each step while visiting an Abstract Syntax Tree during code analysis.\n        2. self.visit: This refers to the core functionality of CodeVisitor itself being inherited from ast.NodeVisitor. Every node visit or exploration invokes self.visit to advance toward traversal inside CodeVisitor. 'generic_visit', acting as a utility function for standard operations over generic node types where no specific visitor method exists (e.g., Assign nodes). It iterates through child nodes returned by ast.iter_child_nodes and recursively calls self.visit() on each child node, allowing the CodeVisitor instance to perform its analysis tasks consistently across various AST components. This way, it ensures thorough examination of the Abstract Syntax Tree while extracting necessary details about functions, classes, dependencies, constants, etc., as per requirement.'\n    Variables:\n      Value: self, node\n      Purpose: 'In the context given from the 'CodeVisitor' class within the Python script 'py2dataset/get_python_file_details.py', we focus on understanding the role of self and node variables within the `generic_visit()` method.\n        Self refers to an instance of the CodeVisitor class itself when invoked inside a particular method. In object-oriented programming languages like Python, self is a reference that connects method calls back to an existing object and helps in accessing object attributes efficiently within class definitions. It ensures method execution specific to its calling instance by providing necessary contextual information about the object. In `CodeVisitor`, self acts as a bridge between different methods and their respective data stored in instance attributes like 'code', 'functions', 'classes', etc., allowing them to interact with each other seamlessly.\n        Node, on the other hand, represents an Abstract Syntax Tree (AST) node while visiting different sections of the codebase during analysis. Ast nodes break down complex Python programs into simpler pieces representing specific syntactic constructs like assignments, functions, classes, imports, etc. `generic_visit()` is responsible for traversing the entire AST structure to analyze and extract details about various code elements. Node acts as a current focus point while visiting its children recursively in order to understand the relationships between different programming elements. This method calls other methods like visit_FunctionDef(), visit_ClassDef(), or visit_Assign() depending on node type, thus allowing `CodeVisitor` to extract necessary information about functions, classes, constants, etc., by passing node as an argument.\n        In summary, self connects `CodeVisitor` method executions to their related object context, whereas node acts as a central element being visited within the Abstract Syntax Tree to guide CodeVisitor during Python code traversal and detail extraction processes. Their collective interaction leads to an accurate comprehension of a Python program's intricate details while populating 'functions', 'classes', 'file_info', etc., attributes efficiently.'\n  CodeVisitor.visit_Assign:\n    Inputs:\n      Value: self, node\n      Purpose: 'Within the context of the given Python script 'py2dataset/get_python_file_details.py' and specifically focusing on the `CodeVisitor` class, the method `visit_Assign` plays a crucial role in gathering information related to constants (static values) within a Python source code file being processed. Here, self and node act as significant inputs when invoked within this method.\n        1. self refers to the instance of the `CodeVisitor` class itself when it's used inside methods like `visit_Assign`. It allows accessing attributes such as 'code', 'functions', 'classes', 'current_class', or 'file_info', and shares functionality with its inherited base classes - enhancing method efficiency while retaining vital state variables within object boundaries. These details aid in populating attribute dictionaries correspondingly while analyzing different aspects of Python code like functions, class definitions, file information, etc.\n        2. node refers to a current Abstract Syntax Tree node passed down through inheritance from the ast.NodeVisitor superclass into `visit_Assign`. Its exact purpose inside `visit_Assign` lies in identifying constant assignments within the Python source code. It traverses the AST structure and checks for ast.Assign nodes where targets are names representing constants (variables assigned static values). This method maintains a list named 'constants', appending such variable assignments with their respective values into it, contributing to comprehensive code analysis and data extraction by `CodeVisitor`.\n        In summary, self provides access to the `CodeVisitor` object's internal state for processing, while node denotes the current node in Abstract Syntax Tree under evaluation. Together they help recognize constant declarations in Python files as part of extracting meaningful insights from code analysis through visit_Assign method execution.'\n    Calls:\n      Value: isinstance, ast.unparse, self.constants.append, self.generic_visit\n      Purpose: 'In the context of the CodeVisitor class within the Python script 'py2dataset/get_python_file_details.py', specifically in the method `visit_Assign`, four significant calls are made involving functions or libraries - `isinstance(), ast.unparse(), self.constants.append()`, and `self.generic_visit()`. Each of these plays a crucial role in extracting details about Python code assignments during Abstract Syntax Tree traversal.\n        1. isinstance(node.parent, ast.Module): This call checks if the parent node of the current Assign statement is an ast.Module object, indicating it's at the top level (file scope). It helps determine whether constants are global variables or not.\n        2. ast.unparse(value) (if isinstance(value, ast.Constant)): If the assigned value in the Ast node is a constant expression with a string literal ('ast.Constant' with string 'value'), ast.unparse() method is utilized to format this expression as Python code readable by humans. This ensures that constants are stored correctly in self.constants list for further analysis.\n        3. self.constants.append(constant_assignment): When a constant assignment occurs (variable assignment with a string literal value), the constant_assignment string is appended to the self.constants list. This list stores all the identified constants present within the code, useful for keeping track of globally available variables throughout analysis.\n        4. self.generic_visit(node): Similar to other node visitation methods in CodeVisitor (visit_FunctionDef(), visit_ClassDef()), self.generic_visit() continues traversing child nodes beneath Assign node after assigning constants. This allows CodeVisitor to explore the entire Abstract Syntax Tree and extract more details about Python code structure.\n        In summary, these calls within `CodeVisitor.visit_Assign` support discovering constants stored as string literals across variable assignments within Python scripts and prepare required information for constructive analysis throughout AST traversal. They provide insight into how constants are created in a file or module scope while maintaining the code's overall contextual understanding.'\n    Variables:\n      Value: node, value_repr, constant_assignment, self, value\n      Purpose: 'Within the `CodeVisitor` class in Python's `get_python_file_details.py`, specifically in the `visit_Assign()` method, these variables hold particular significance while processing Python source code during analysis. Here is a breakdown of their roles:\n        1. node: This parameter represents the current Abstract Syntax Tree (AST) node being visited by the CodeVisitor object during traversal. It helps identify various elements within the code structure and extract relevant details accordingly. In `visit_Assign()`, node refers to an Assign statement where variable assignments occur.\n        2. value_repr: This variable stores a string representation of constants encountered during AST traversal in `CodeVisitor`. Constants are identified when visiting ast.Assign nodes inside the module level (i.e., not within classes). It captures constant values represented as strings in the code after processing through ast unparsing, making them human-readable while preserving their syntax context.\n        3. constant_assignment: As `CodeVisitor` traverses the AST, it collects all assignments of constants into a list named 'self.constants'. In `visit_Assign()`, this variable temporarily holds an individual assignment statement consisting of target identifier (variable name) and its value representation ('value_repr') during its processing step within node analysis. Once the method finishes processing an ast.Assign node, it appends constant_assignment to self.constants list for future use.\n        4. self: This keyword refers to the current instance of the `CodeVisitor` class itself. It allows accessing attributes like 'code', 'functions', 'classes', 'file_info', etc., defined during object instantiation without having to repeat the object name each time in method calls within the class body. It provides contextual accessibility throughout method implementations.\n        5. value: This parameter represents the value node being assigned within an ast.Assign statement. While not explicitly used in `visit_Assign()`, it would be relevant when dealing with other types of assignments like attribute assignment or augmented assignment expressions in Python code. However, in this specific method, its usage is limited to fetch constants declared directly using assignments like a = b ('a' would correspond to a target variable; 'b' represents the assigned value), so Python will usually parse those variables into constant node form ('value').'\n  CodeVisitor.extract_details:\n    Inputs:\n      Value: self, node, node_type\n      Purpose: 'In the context of CodeVisitor class's extract_details method within the given Python script 'py2dataset/get_python_file_details.py', [self, node, node_type] represent critical inputs playing key roles during data extraction and processing steps.\n        1. self: It refers to the instance of the CodeVisitor object itself when the extract_details method is invoked. This instance maintains crucial attributes like code (source Python file content), functions dictionary for storing function details, classes dictionary containing class definitions along with necessary parsed AST information for analysis such as constants, current_class denoting active nested classes scope. Its main function here is providing necessary data access to extract_details through instance variables required for node traversal and subsequent processing of nodes encountered during Abstract Syntax Tree exploration.\n        2. node: This parameter signifies the specific AstNode in the Abstract Syntax Tree that CodeVisitor encounters while performing analysis. The method walks through the tree, analyzing each node individually to extract details related to functions or classes depending upon its type. It allows extract_details to gather information about Python code elements like function definitions, class definitions, imports, constants, etc., which are stored in attributes such as 'functions', 'classes', and 'file_info'.\n        3. node_type: This input determines the category of the current AstNode being processed by extract_details - whether it represents a 'function', 'method', or 'class'. It helps differentiate between various Python code elements during extraction, allowing for tailored data collection depending on the node type encountered. For instance, when processing function nodes ('function' node_type), details related to inputs, returns, calls, etc., are collected differently compared to class nodes ('class') which gather method definitions or inheritance aspects within the extract_details output dictionary. This differentiation is vital for generating a comprehensive and structured understanding of the Python file contents.'\n    Calls:\n      Value: list, ast.walk, get_all_calls, ast.unparse, isinstance, set, next, call_data.keys, self.classes[self.current_class].setdefault, details.update, any\n      Purpose: 'In the context of CodeVisitor's extract_details method within a Python programming setting, various built-in functions and libraries are employed to extract detailed information about different elements found in Abstract Syntax Tree nodes (ast.AST). These functions play essential roles as outlined below:\n        1. list - This built-in Python type is often utilized to create temporary collections like node_variables during extraction of details for a given node. It helps store information related to variables present within the scope of that node.\n        2. ast.walk(node) - This function recursively traverses an Abstract Syntax Tree starting from the provided node, allowing exploration of nested structures and accessing relevant data for analysis purposes. In extract_details(), it is used to iterate through nodes associated with a given ast.AST instance named 'node'.\n        3. get_all_calls(node) - This function (defined outside CodeVisitor but called within extract_details) finds all function calls in the subtree rooted at node including those present in class attributes, list comprehensions, and lambda functions. It returns a dictionary of function calls with their arguments. Here, it helps gather call details for further processing.\n        4. ast.unparse(node) - This function generates Python source code as a string representation of an Abstract Syntax Tree node. It's employed in multiple instances to keep docstrings intact while removing them or represent simplified file_code without comments during file analysis.\n        5. isinstance(object, class) - This built-in function checks whether the given object belongs to the specified class type or not. In extract_details(), it is used for various checks such as identifying top-level docstrings, handling assignments related to constants, decorators, annotations, properties, etc.\n        6. set - This data structure allows us to eliminate duplicates among elements in node iterations which could be attributes (in class definition case), dependencies while creating lists out of unique values. It ensures distinctness during the extraction process.\n        7. next(iterator[, default]) - A built-in function that returns the next item from an iterator's collection or specified default value if the iterator is exhausted. In extract_details(), it helps retrieve docstrings by iterating over node walk and picking up the first occurrence of ast.Expr holding a string value representing docstring.\n        8. call_data.keys() - This function returns all keys present in dictionary 'call_data', which contains function calls found during traversal. It's used to list out functions with their respective arguments for further processing.\n        9. self.classes[self.current_class].setdefault(key, default) - A dictionary method setting default value if a particular key is absent within the scope of current class definition ('self.current_class'). This helps maintain class attributes and methods details during extraction.\n        10. details.update(otherdict) - This dictionary method merges otherdict into the existing dictionary 'details', overwriting keys with new values if they exist in both dictionaries or adding new ones if unique. It's used to consolidate information extracted from different parts of code elements (function, class, etc.) into a single details object.\n        11. any(sequence) - This built-in function returns True if at least one element in the given iterable sequence evaluates to true regarding a specified condition. In extract_details(), it checks whether a decorator instance within subnode's decorator list matches \"staticmethod\". It helps identify static methods within class definitions.\n        These calls contribute towards thorough data extraction about various elements within the Python code such as functions, classes, dependencies, constants, docstrings, function call relations, etc., creating comprehensive file summaries to facilitate deeper analysis and understanding of a given Python script's functionality.'\n    Variables:\n      Value: node_walk, node, node_inputs, self, details, node_type, class_attributes, call_data, attributes, node_variables\n      Purpose: 'In the context of the CodeVisitor class's extract_details method within a Python script analyzing Abstract Syntax Trees (AST), various variables serve specific purposes that contribute to extracting detailed information about nodes representing functions, classes, properties, constants, etc. from given source code. Understanding these variables enhances comprehension of the data collection process in Python code analysis.\n        1. node_walk: It is a list generated by iterating through ast.walk(node), which traverses the AST node recursively to gather relevant information about its subnodes and children nodes. This variable helps access multiple levels of nested structures within the code efficiently.\n        2. node: Represents the current node being processed in extract_details(). It could be a FunctionDef, ClassDef, Assign, Attribute, Import, or any other valid AST node type. This node acts as the entry point for extracting particular data relevant to that node category by referencing various aspects such as docstring, attributes, input parameters, and others within CodeVisitor logic flow.\n        3. node_inputs: In cases where node_type equals 'function' or 'method', node_inputs represent the argument lists received in those function/method definitions. It collects input arguments for further processing.\n        4. self: Refers to the instance of the CodeVisitor class itself which maintains critical data structures like functions, classes, constants, and file_info dictionaries used for storage during traversal and extraction tasks. These instances variables keep track of visited nodes' information enabling analysis consistency throughout code parsing.\n        5. details: An intermediate result dictionary storing key-value pairs derived from current node inspection and manipulation operations using ast functions like ast.unparse(), get_all_calls(). It accumulates extracted data for the specific node type ('function', 'method', or 'class') until extract_details returns the overall results of current processing node operations as output dict data representation.\n        6. node_type: It's a string representing the kind of node being processed ('function', 'method', or 'class'). This variable determines which sections in details dictionary will be populated depending on node type to differentiate function-specific, class-specific information, etc., ensuring accurate extraction of data pertaining to respective entities.\n        7. class_attributes: A list accumulating attributes defined as self.<attribute> within a ClassDef node when traversing nested assignments. This variable keeps track of all such instances encountered during parsing class definitions in the codebase.\n        8. call_data: During recursive function call discovery in get_all_calls(), call_data is a dictionary that maps function calls as keys to their respective arguments lists gathered within the subtree rooted at node. It forms an essential part of 'details' output for node types 'function' or 'method'.\n        9. attributes: This variable captures names assigned to attributes while traversing assignments related to self when inside a ClassDef node. These attribute names are stored temporarily until further processing within class_defs construction in CodeVisitor logic flow.\n        10. node_variables: A list collecting names of variables encountered during traversal within the current node scope. It helps identify local variable references used within functions or methods for better understanding of code behavior and dependencies.\n        In summary, these variables play crucial roles in efficiently extracting details about nodes within CodeVisitor's extract_details method by managing data collection, storing intermediate results, guiding operations according to node types, and ensuring accurate representation of Python code features such as functions, classes, attributes, calls, constants, etc. They aid developers in analyzing Python source code effectively by creating meaningful data structures containing useful information for code understanding purposes.'\n    Returns:\n      Value: details\n      Purpose: 'In the given context, 'CodeVisitor' class plays a crucial role with its method 'extract_details' that extracts various details about functions, classes, and attributes from Python source code analyzed through Abstract Syntax Tree (AST) traversal. When invoked on different nodes, this method returns detailed dictionaries containing essential information related to those specific entities within the codebase.\n        The purpose of `CodeVisitor.extract_details` lies in breaking down complex Python code into manageable parts and providing insights about each segment. It helps developers understand the structure better by extracting attributes like names, docstrings, inputs/outputs, decorators, return values, etc., from nodes categorized as functions ('function'), methods ('method') or classes ('class'). The significance lies in how these details assist with code refactoring, maintenance, testing, debugging, and documentation.\n        1. [details][Function]: Returned when the node is a function (function_def in AST). This dictionary provides information related to functions like name, code representation without docstrings (using ast.unparse()), function docstring if any, input arguments list ('function_inputs'), called function names with their respective inputs ('function_calls', 'function_call_inputs'), return values ('function_returns').\n        2. [details][Method]: Returned when the node is a method within a class context ('class_method' in AST). This dictionary includes class name prefixed attributes like those from function details plus additional elements such as inherited classes ('class_inheritance'), static methods present within the same class ('class_static_methods').\n        3. [details][Class]: Returned when the node represents a ClassDef statement in the AST. Here, extracted details encompass method names under 'class', class attributes ('class_attributes'), list of all methods defined within the class ('class_methods'), and inheriting classes if any ('class_inheritance').\n        In summary, `CodeVisitor.extract_details` acts as a knowledge extraction tool from Python code by providing comprehensive details about functions, methods, and classes in a structured format that can be further utilized for various development tasks.'\n  CodeVisitor.analyze:\n    Inputs:\n      Value: self, node\n      Purpose: 'In the context given for CodeVisitor class within the 'get_python_file_details.py' script, particularly focusing on its analyze() method, 'self' and 'node' serve crucial roles as inputs when invoking this function. These parameters hold significant meaning in terms of understanding how the analysis process unfolds within the codebase.\n        1. self: This keyword refers to the instance of the CodeVisitor class itself during the execution of its methods. It acts as a reference to all attributes defined within the class, such as 'code', 'functions', 'classes', 'file_info', and others. By having access to these variables, analyze() can leverage previously collected data while traversing the Abstract Syntax Tree (AST) to populate necessary details about the Python file under analysis. It allows for maintaining consistency across various methods like visit_FunctionDef(), visit_ClassDef(), extract_details(), etc., which contribute to building a comprehensive understanding of the code structure.\n        2. node: This parameter represents an Abstract Syntax Tree node that serves as the starting point for traversal within CodeVisitor's analyze() method. It signifies the current position in the AST hierarchy where analysis needs to be performed. As analyze() iterates through different nodes in the tree, it calls other methods like visit(), extract_details(), and updates attributes related to file dependencies, functions, classes, constants, etc., using information extracted from this node and its descendants. This input allows CodeVisitor to navigate through the AST efficiently while gathering essential details about Python code elements such as imports, function definitions, class definitions, dependencies, etc., which are then stored in relevant attributes like 'file_dependencies', 'function_defs', 'class_defs', and so on.\n        In summary, 'self' connects analyze() with all properties stored across method calls and data processed thus far during code inspection by the CodeVisitor object. 'node' identifies where the traversal needs to be done at each invocation of analyze(), providing crucial context about a specific part of the Abstract Syntax Tree that is being examined during analysis. Both inputs play vital roles in constructing comprehensive details regarding Python files for better comprehension and maintenance of code structure within CodeVisitor class operations.'\n    Calls:\n      Value: self.visit, list, ast.walk, isinstance, self.functions.items, len, class_details.items, method_name.startswith, self.classes.items, self.functions.keys, self.classes.keys, remove_docstring, ast.unparse\n      Purpose: 'In the context of CodeVisitor's analyze() method, several essential calls serve particular purposes advancing through code analysis and gathering data:\n        1. self.visit: Initiates traversal of Abstract Syntax Tree (AST) to collect information from nodes in an organized manner as defined by Python visitor design pattern implemented via ast.NodeVisitor inheritance. This allows the CodeVisitor class to visit each node within the AST and extract relevant details accordingly.\n        2. list & ast.walk: Combined usage creates a list containing nodes generated while walking through the AST tree with ast.walk(). This list facilitates easier data extraction by iterating over various node types (function, class, import statements, etc.) during analysis.\n        3. isinstance(): Checks if an object belongs to a specific Python class or inherits from it. In CodeVisitor, this operator helps identify nodes like FunctionDef, ClassDef, Assign, Import, etc., and allows appropriate data extraction for various code elements.\n        4. self.functions.items() & len: Iterates over all function names stored in 'self.functions' dictionary and determines its length to manage loops efficiently when populating file_summary data structure related to functions.\n        5. class_details.items(): Iterates over details collected for each method within a class definition while processing class nodes, allowing extraction of necessary data associated with those methods in 'class_defs' data structure formation within the code analysis.\n        6. method_name.startswith('class_method_'): Validates whether given method names start with \"class_method_\" prefix to identify class methods within classes during class definition traversal. This helps separate class methods from other attributes while populating 'class_defs' dictionary in file_summary data structure.\n        7. self.classes.items(): Iterates over all classes defined in the code, collecting their respective details needed for analysis like methods, properties, static methods, etc., forming comprehensive data on class-related elements stored under 'file_summary'.\n        8. remove_docstring: Sanitizes Python source code by removing docstrings and top-level module comments while preserving its syntax structure using ast.unparse(). This ensures cleaner input for further analysis without interfering with the AST tree's integrity.\n        9. ast.unparse(): Converts parsed Abstract Syntax Tree nodes back into Python source code strings, often used after manipulating or modifying the AST structure within CodeVisitor methods like visit_FunctionDef() and remove_docstring(). This allows keeping track of original code changes during analysis for better understanding.\n        These calls work collaboratively in CodeVisitor's analyze() method to perform thorough analysis on Python source code files, extracting critical details about functions, classes, dependencies, constants, etc., creating a detailed summary of the file structure.'\n    Variables:\n      Value: node, function_defs, self, class_defs, file_dependencies, node_walk\n      Purpose: 'Within the `CodeVisitor.analyze()` function, several crucial variables hold critical roles as detailed below:\n        1. `node`: This parameter represents the current Abstract Syntax Tree (AST) node being processed during traversal. As the analyze method walks through the AST to extract various code details, `node` serves as the point of reference at any given time during iteration. It receives this argument when calling the analyze function.\n        2. `function_defs`: This variable is initialized empty but later evolves into a list comprehension holding dictionary objects related to detected Python functions present in the source code being processed by CodeVisitor instance. Each dictionary within `function_defs` represents a specific function with its inputs, calls, call inputs, returns, etc., collected from the 'functions' attribute of the CodeVisitor instance (self). This variable helps aggregate all function-related information for further use or output in the final file details dictionary.\n        3. `self`: As CodeVisitor is an object-oriented class, 'self' refers to this very instance itself. Inside `CodeVisitor`, methods can access attributes specific to that particular instance via 'self'. Within analyze(), 'self' points to the instance responsible for maintaining crucial dictionaries such as 'functions', 'classes', and 'file_info'. Thus, 'self' enables manipulation of these instance variables while processing nodes in the AST.\n        4. `class_defs`: Similar to `function_defs`, `class_defs` starts empty but eventually becomes a list comprehension containing nested dictionaries representing Python classes found during traversal. Each dictionary within `class_defs` relates to one detected class in the source code with properties such as 'method_defs' storing method details. This variable accumulates class-related information analogous to how `function_defs` does for functions.\n        5. `file_dependencies`: During AST traversal, dependencies like imported modules or classes are captured during node examination using import statements ('Import', 'ImportFrom'). These dependencies are stored in a set initially and later converted into a list for output purposes within the 'file_info' dictionary of CodeVisitor instance. This variable highlights external resources utilized by the Python file being analyzed.\n        6. `node_walk`: Obtained from ast.walk(node), this list holds intermediate nodes traversed while processing `node`. The walk function iterates over a tree recursively and generates an ordered list of visited nodes which helps analyze child nodes to access various properties related to their ancestors, hence improving comprehensiveness during the code examination process in analyze().\n        To sum up, these variables facilitate extracting comprehensive information about Python code structures such as functions, classes, dependencies while maintaining file metadata through `CodeVisitor`'s `analyze()` method execution. Each variable serves a significant purpose within this function to generate an enriched understanding of the analyzed Python source code file.'"
    purpose: 'I) The purpose of ''py2dataset/get_python_file_details.py'' script is to extract detailed information from Python source code files. It performs analysis using Abstract Syntax Tree (AST), parses docstrings, function calls, dependencies, constants, and generates a code graph representation for better understanding of the file structure. This extracted data helps developers gain insights into the functionality of the given Python file.


        II) Requirements & API Signatures:

        1. `remove_docstring` - Removes docstrings from provided Python code string while preserving its syntax.

        Inputs: Python code string, parsed Abstract Syntax Tree representing this code snippet as argument `tree`.

        Return value: sanitized source code after stripping the comments and top-level docstrings within functions and classes but retaining the structure intact using ast.unparse().

        2. `get_all_calls` - Traverses the given AST node''s subtree to identify all function calls, including nested occurrences in class attributes, list comprehensions, and lambda functions.

        Inputs: Node of type ast.AST as argument `node`, an optional dictionary `calls` to accumulate function call lists when no existing instances provided initially (Default = []).

        Outputs: A Dictionary of strings keyed with the calling functions listing arguments respectively [Function_Calls => [args...]] formed using recursion within the subtree.

        3. `CodeVisitor` - A class that traverses an Abstract Syntax Tree and extracts details about Python code, inheriting from ast.NodeVisitor for easy traversal management. It collects function definitions, class definitions, file dependencies, constants, etc., storing them in relevant attributes such as ''functions'', ''classes'', ''file_info''.

        Constructor Arguments: Source code `code` and parsed Abstract Syntax Tree `tree`.

        4. `get_python_file_details` - Extracts comprehensive details from a given Python file path using CodeVisitor class methods and generates a control flow structure, entire code graph representation, and PlantUML notation for visualization purposes through get_code_graph function integration.

        Inputs: File path as string `file_path`.

        Outputs: A dictionary containing extracted file details or None if an error occurs during processing.


        III) Inputs, Variables, Calls & Returns explanation in the code context:

        1. remove_docstring():

        - Inputs ''code'' represents Python source code string while ''tree'' is its Abstract Syntax Tree representation generated using ast.parse(). Functions remove top-level docstrings from code strings while recursively deleting nested docstrings inside function bodies or class definitions keeping AST intact by invoking `ast.unparse(tree)`.

        2. get_all_calls():

        - ''node'' represents an AST node, used to find all occurrences of ast.Call instances along with their arguments within the subtree rooted at this node. It returns a dictionary mapping function calls as keys to lists of their respective arguments. If no initial call list provided (''calls''), it creates an empty list by default [''Dict[str, List[str]]].

        3. get_python_file_details():

        - Receives Python file path string ''file_path'' and performs the following steps:

        a) Opens the file using ''open()'', reads its content into variable ''code''.

        b) Parses code into Abstract Syntax Tree using ast.parse().

        c) Instantiates CodeVisitor object with provided source code ''code'' and parsed tree as arguments (''visitor'').

        d) Invokes visitor.analyze() to populate details related to the file in instance attributes.

        e) Gets a detailed graphical representation of function call relations, control flow structure & PlantUML notation from get_code_graph().

        f) Replaces quotations from json.dumps() output using replace().

        g) Returns file_details dictionary with extracted data or None in case of an error.

        4. CodeVisitor class:

        - Its methods operate on AST nodes and extract relevant information for various aspects of Python code like functions, classes, dependencies, constants, etc., storing them into attributes such as ''functions'', ''classes'', ''file_info''. It also maintains a current class context (''current_class'') to track nested class definitions.

        - visit_FunctionDef() and visit_ClassDef(): Calls self.extract_details() method passing relevant node types as parameters (''function'' or ''class''), populates ''functions''/''classes'' dictionaries accordingly.

        - extract_details(): Iterates through AST walk of given node, collects function/class details into a dictionary using various calls like ast.walk(), get_all_calls(), ast.unparse(). Returns this collected data as detailed output dictionary depending on node type (''function'', ''method'', ''class'', or ''self'').

        - analyze(): Traverses AST node (''node'') for dependencies capturing details related to file_summary (used JSON format) while setting up variables such as file_dependencies, function_defs, class_defs. Invokes get_code_graph() to generate entire code graph representation and PlantUML notation.

        - Other methods like visit_FunctionDef(), visit_ClassDef(), generic_visit(), visit_Assign(): Assist in traversing AST nodes efficiently by invoking appropriate extract_details() method or calling other relevant ast functions.

        '
functions:
    remove_docstring:
        function_name: remove_docstring
        function_code: "def remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)"
        function_docstring: "\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    "
        function_inputs:
        - code
        - tree
        function_defaults: []
        function_returns:
        - ast.unparse(tree)
        function_calls:
        - isinstance
        - tree.body.pop
        - ast.walk
        - node.body.pop
        - ast.unparse
        function_call_inputs:
            isinstance:
            - tree.body[0]
            - ast.Expr
            - tree.body[0].value
            - ast.Str
            - node
            - (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)
            - first_body_node
            - ast.Expr
            - first_body_node.value
            - ast.Str
            tree.body.pop:
            - '0'
            ast.walk:
            - tree
            node.body.pop:
            - '0'
            ast.unparse:
            - tree
        function_variables:
        - tree
        - first_body_node
        - code
        function_decorators: []
        function_annotations: []
        function_properties: []
    get_all_calls:
        function_name: get_all_calls
        function_code: "def get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict"
        function_docstring: "\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    "
        function_inputs:
        - node
        - calls
        function_defaults:
        - None
        function_returns:
        - calls_dict
        function_calls:
        - isinstance
        - calls.append
        - ast.unparse
        - get_all_calls
        - ast.iter_child_nodes
        - calls_dict[func].extend
        function_call_inputs:
            isinstance:
            - node
            - ast.Call
            - node
            - ast.ClassDef
            - body_item
            - ast.Assign
            - body_item.targets[0]
            - ast.Name
            calls.append:
            - (ast.unparse(node.func), [ast.unparse(arg) for arg in node.args])
            ast.unparse:
            - node.func
            - arg
            get_all_calls:
            - body_item.value
            - calls
            - child
            - calls
            ast.iter_child_nodes:
            - node
            calls_dict[func].extend:
            - args
        function_variables:
        - calls
        - calls_dict
        - node
        function_decorators: []
        function_annotations: []
        function_properties: []
    get_python_file_details:
        function_name: get_python_file_details
        function_code: "def get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details"
        function_docstring: "\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    "
        function_inputs:
        - file_path
        function_defaults: []
        function_returns:
        - file_details
        - None
        function_calls:
        - open
        - f.read
        - ast.parse
        - logging.warning
        - CodeVisitor
        - visitor.analyze
        - get_code_graph
        - json.dumps(file_summary).replace
        - json.dumps
        function_call_inputs:
            open:
            - file_path
            - '''r'''
            f.read: []
            ast.parse:
            - code
            logging.warning:
            - 'f''{e} error in file: {file_path}'''
            CodeVisitor:
            - code
            - tree
            visitor.analyze:
            - tree
            get_code_graph:
            - file_summary
            - file_ast
            json.dumps(file_summary).replace:
            - '''"'''
            - ''''''
            json.dumps:
            - file_summary
        function_variables:
        - file_ast
        - tree
        - visitor
        - file_details
        - file_path
        - code
        - file_summary
        function_decorators: []
        function_annotations: []
        function_properties: []
classes:
    CodeVisitor:
        class_name: CodeVisitor
        class_code: "class CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n        node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n                class_attributes += attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}"
        class_docstring: "\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    "
        class_inputs: null
        class_defaults: null
        class_returns:
        - details
        class_calls:
        - self.extract_details
        - self.generic_visit
        - ast.iter_child_nodes
        - self.visit
        - isinstance
        - ast.unparse
        - self.constants.append
        - list
        - ast.walk
        - get_all_calls
        - set
        - next
        - call_data.keys
        - self.classes[self.current_class].setdefault
        - details.update
        - any
        - self.functions.items
        - len
        - class_details.items
        - method_name.startswith
        - self.classes.items
        - self.functions.keys
        - self.classes.keys
        - remove_docstring
        class_call_inputs:
            self.extract_details:
            - node
            - '''method'' if self.current_class else ''function'''
            - node
            - '''class'''
            self.generic_visit:
            - node
            - node
            - node
            ast.iter_child_nodes:
            - node
            self.visit:
            - child
            - node
            isinstance:
            - node.parent
            - ast.Module
            - target
            - ast.Name
            - value
            - ast.Constant
            - value.value
            - str
            - subnode
            - ast.Assign
            - target
            - ast.Name
            - n
            - ast.Expr
            - n.value
            - ast.Str
            - subnode
            - ast.Return
            - subnode
            - ast.AnnAssign
            - subnode
            - ast.Attribute
            - subnode.ctx
            - ast.Store
            - subnode
            - ast.Assign
            - target
            - ast.Attribute
            - target.value
            - ast.Name
            - subnode
            - ast.Assign
            - target
            - ast.Attribute
            - subnode
            - ast.FunctionDef
            - subnode
            - ast.FunctionDef
            - decorator
            - ast.Name
            - subnode
            - ast.Import
            - subnode
            - ast.ImportFrom
            ast.unparse:
            - value
            - target
            - node
            - d
            - subnode.value
            - decorator
            - subnode.annotation
            - subnode
            - base
            - node
            self.constants.append:
            - constant_assignment
            list:
            - ast.walk(node)
            - '{ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}'
            - set(node_inputs + node_variables)
            - call_data.keys()
            - '{ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()'
            - '{ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}'
            - '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}'
            - ast.walk(node)
            - file_dependencies
            - self.functions.keys()
            - self.classes.keys()
            - file_dependencies
            ast.walk:
            - node
            - node
            get_all_calls:
            - node
            set:
            - node_inputs + node_variables
            next:
            - (n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str))
            - None
            call_data.keys: []
            self.classes[self.current_class].setdefault:
            - '''class_attributes'''
            - '[]'
            details.update:
            - '{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], ''class_inheritance'': [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}'
            any:
            - (isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list)
            self.functions.items: []
            len:
            - '''class_method_'''
            class_details.items: []
            method_name.startswith:
            - '''class_method_'''
            self.classes.items: []
            self.functions.keys: []
            self.classes.keys: []
            remove_docstring:
            - ast.unparse(node)
            - self.tree
        class_variables:
        - value_repr
        - attributes
        - function_defs
        - constant_assignment
        - node_inputs
        - details
        - class_defs
        - class_attributes
        - value
        - file_dependencies
        - call_data
        - node_walk
        - node_variables
        class_decorators: []
        class_annotations:
        - str
        - Dict[str, Dict[str, Union[str, List[str]]]]
        - Dict[str, Union[str, List[str]]]
        - List[str]
        class_properties:
        - self.classes
        - self.code
        - self.tree
        - child.parent
        - self.functions
        - self.file_info
        - self.current_class
        - self.constants
        class_attributes:
        - tree
        - current_class
        - current_class
        - file_info
        class_methods:
        - __init__
        - visit_FunctionDef
        - visit_ClassDef
        - generic_visit
        - visit_Assign
        - extract_details
        - analyze
        class_inheritance:
        - ast.NodeVisitor
        class_static_methods: []
        class_method___init__:
            method_name: __init__
            method_code: "def __init__(self, code: str, tree: ast.AST) -> None:\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None\n    self.constants: List[str] = []\n    self.tree = tree"
            method_docstring: "\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        "
            method_inputs:
            - self
            - code
            - tree
            method_defaults: []
            method_returns: []
            method_calls: []
            method_call_inputs: {}
            method_variables:
            - self
            - tree
            - code
            method_decorators: []
            method_annotations:
            - str
            - Dict[str, Dict[str, Union[str, List[str]]]]
            - Dict[str, Union[str, List[str]]]
            - List[str]
            method_properties:
            - self.classes
            - self.code
            - self.tree
            - self.functions
            - self.file_info
            - self.current_class
            - self.constants
        class_method_visit_FunctionDef:
            method_name: visit_FunctionDef
            method_code: "def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)"
            method_docstring: "\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        "
            method_inputs:
            - self
            - node
            method_defaults: []
            method_returns: []
            method_calls:
            - self.extract_details
            - self.generic_visit
            method_call_inputs:
                self.extract_details:
                - node
                - '''method'' if self.current_class else ''function'''
                self.generic_visit:
                - node
            method_variables:
            - self
            - details
            - node
            method_decorators: []
            method_annotations: []
            method_properties: []
        class_method_visit_ClassDef:
            method_name: visit_ClassDef
            method_code: "def visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None"
            method_docstring: "\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        "
            method_inputs:
            - self
            - node
            method_defaults: []
            method_returns: []
            method_calls:
            - self.extract_details
            - self.generic_visit
            method_call_inputs:
                self.extract_details:
                - node
                - '''class'''
                self.generic_visit:
                - node
            method_variables:
            - self
            - node
            method_decorators: []
            method_annotations: []
            method_properties:
            - self.current_class
        class_method_generic_visit:
            method_name: generic_visit
            method_code: "def generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)"
            method_docstring: "\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        "
            method_inputs:
            - self
            - node
            method_defaults: []
            method_returns: []
            method_calls:
            - ast.iter_child_nodes
            - self.visit
            method_call_inputs:
                ast.iter_child_nodes:
                - node
                self.visit:
                - child
            method_variables:
            - self
            - node
            method_decorators: []
            method_annotations: []
            method_properties:
            - child.parent
        class_method_visit_Assign:
            method_name: visit_Assign
            method_code: "def visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)"
            method_docstring: "\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        "
            method_inputs:
            - self
            - node
            method_defaults: []
            method_returns: []
            method_calls:
            - isinstance
            - ast.unparse
            - self.constants.append
            - self.generic_visit
            method_call_inputs:
                isinstance:
                - node.parent
                - ast.Module
                - target
                - ast.Name
                - value
                - ast.Constant
                - value.value
                - str
                ast.unparse:
                - value
                self.constants.append:
                - constant_assignment
                self.generic_visit:
                - node
            method_variables:
            - node
            - value_repr
            - constant_assignment
            - self
            - value
            method_decorators: []
            method_annotations: []
            method_properties: []
        class_method_extract_details:
            method_name: extract_details
            method_code: "def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n    node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n    if node_inputs:\n        node_variables = list(set(node_inputs + node_variables))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n            class_attributes += attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details"
            method_docstring: "\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        "
            method_inputs:
            - self
            - node
            - node_type
            method_defaults: []
            method_returns:
            - details
            method_calls:
            - list
            - ast.walk
            - get_all_calls
            - ast.unparse
            - isinstance
            - set
            - next
            - call_data.keys
            - self.classes[self.current_class].setdefault
            - details.update
            - any
            method_call_inputs:
                list:
                - ast.walk(node)
                - '{ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}'
                - set(node_inputs + node_variables)
                - call_data.keys()
                - '{ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()'
                - '{ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}'
                - '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}'
                ast.walk:
                - node
                get_all_calls:
                - node
                ast.unparse:
                - target
                - node
                - d
                - subnode.value
                - decorator
                - subnode.annotation
                - subnode
                - base
                isinstance:
                - subnode
                - ast.Assign
                - target
                - ast.Name
                - n
                - ast.Expr
                - n.value
                - ast.Str
                - subnode
                - ast.Return
                - subnode
                - ast.AnnAssign
                - subnode
                - ast.Attribute
                - subnode.ctx
                - ast.Store
                - subnode
                - ast.Assign
                - target
                - ast.Attribute
                - target.value
                - ast.Name
                - subnode
                - ast.Assign
                - target
                - ast.Attribute
                - subnode
                - ast.FunctionDef
                - subnode
                - ast.FunctionDef
                - decorator
                - ast.Name
                set:
                - node_inputs + node_variables
                next:
                - (n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str))
                - None
                call_data.keys: []
                self.classes[self.current_class].setdefault:
                - '''class_attributes'''
                - '[]'
                details.update:
                - '{''class_attributes'': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], ''class_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], ''class_inheritance'': [ast.unparse(base) for base in node.bases] if node.bases else [], ''class_static_methods'': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == ''staticmethod'' for decorator in subnode.decorator_list))]}'
                any:
                - (isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list)
            method_variables:
            - node_walk
            - node
            - node_inputs
            - self
            - details
            - node_type
            - class_attributes
            - call_data
            - attributes
            - node_variables
            method_decorators: []
            method_annotations: []
            method_properties: []
        class_method_analyze:
            method_name: analyze
            method_code: "def analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}"
            method_docstring: "\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        "
            method_inputs:
            - self
            - node
            method_defaults: []
            method_returns: []
            method_calls:
            - self.visit
            - list
            - ast.walk
            - isinstance
            - self.functions.items
            - len
            - class_details.items
            - method_name.startswith
            - self.classes.items
            - self.functions.keys
            - self.classes.keys
            - remove_docstring
            - ast.unparse
            method_call_inputs:
                self.visit:
                - node
                list:
                - ast.walk(node)
                - file_dependencies
                - self.functions.keys()
                - self.classes.keys()
                - file_dependencies
                ast.walk:
                - node
                isinstance:
                - subnode
                - ast.Import
                - subnode
                - ast.ImportFrom
                self.functions.items: []
                len:
                - '''class_method_'''
                class_details.items: []
                method_name.startswith:
                - '''class_method_'''
                self.classes.items: []
                self.functions.keys: []
                self.classes.keys: []
                remove_docstring:
                - ast.unparse(node)
                - self.tree
                ast.unparse:
                - node
            method_variables:
            - node
            - function_defs
            - self
            - class_defs
            - file_dependencies
            - node_walk
            method_decorators: []
            method_annotations: []
            method_properties:
            - self.file_info
