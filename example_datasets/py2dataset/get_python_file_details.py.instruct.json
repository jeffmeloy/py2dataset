[
    {
        "instruction": "Dependencies in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = (\n            [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None\n        )\n        node_variables = list(\n            {\n                ast.unparse(target)\n                for subnode in node_walk\n                if isinstance(subnode, ast.Assign)\n                for target in subnode.targets\n                if isinstance(target, ast.Name)\n            }\n        )\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": node_inputs,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": node_variables,\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                class_attributes = self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                )\n                class_attributes += attributes\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n\n        class_defs = [\n            {\n                class_name: {\n                    \"method_defs\": {\n                        method_name[len(\"class_method_\") :]: {\n                            \"inputs\": details[\"method_inputs\"],\n                            \"calls\": details[\"method_calls\"],\n                            \"call_inputs\": details[\"method_call_inputs\"],\n                            \"returns\": details[\"method_returns\"],\n                        }\n                        for method_name, details in class_details.items()\n                        if method_name.startswith(\"class_method_\")\n                    }\n                }\n            }\n            for class_name, class_details in self.classes.items()\n        ]\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\": node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node), self.tree),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n\n    # get code graph items and add to file_details\n    file_summary = file_details[\"file_info\"][\"file_summary\"]\n    file_ast = file_details[\"file_info\"][\"file_ast\"]\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(\n        file_summary, file_ast\n    )\n    file_details[\"file_info\"][\"entire_code_graph\"] = entire_code_graph\n    file_details[\"file_info\"][\"control_flow_structure\"] = control_flow_structure\n    file_details[\"file_info\"][\"plant_uml\"] = plant_uml\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(file_summary).replace(\n        '\"', \"\"\n    )\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "'logging', 'json', 'get_code_graph', 'typing', 'ast'\n\nPurpose and Significance:\n1. logging: This Python standard library module provides various capabilities for producing diagnostic output based on different levels such as debugging, information, warning, error messages during runtime. In the given script 'get_python_file_details.py', it is utilized to log warnings related to file processing errors like SyntaxError or PermissionError encountered while opening a Python file path specified by user input.\n\n2. json: A built-in Python package supporting JSON encoding and decoding of data structures like dictionary, list, array as well as providing classes dict(object='JSONEncoder'), json.loads(), json.dumps(). Here, json module plays role in serializing file_summary as string (removing quotations) before adding it to file_details dictionary for storage.\n\n3. get_code_graph: An external function imported from unspecified location but essential for constructing a directed graph with nodes and edges representing elements like functions, classes, method nodes and defining relationships among them into a dictionary format (as returned output). It contributes in mapping dependencies and forming code call graphs using networkx library which helps in understanding program control flow and dependencies within the Python file under analysis.\n\n4. typing: This module offers type hinting support for Python language introducing advanced data types like List[Tuple[str, List[str]], Dict[str, Union[str, List[str]] etc., used as return types or argument specifications in various functions of 'get_python_file_details'. It ensures clearer documentation and error detection during code development.\n\n5. ast: This module provides Abstract Syntax Tree classes and functions for Python programs analysis which are critical to parse source code into a data structure suitable for traversal and manipulation. In the script, it is used to parse input code ('ast.parse'), walk through AST nodes ('ast.walk') and unparse simplified code after removing docstrings ('ast.unparse'). ast module serves as base foundation for CodeVisitor class inheritance which further helps extract details about functions/classes within a Python file."
    },
    {
        "instruction": "Call code graph in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = (\n            [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None\n        )\n        node_variables = list(\n            {\n                ast.unparse(target)\n                for subnode in node_walk\n                if isinstance(subnode, ast.Assign)\n                for target in subnode.targets\n                if isinstance(target, ast.Name)\n            }\n        )\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": node_inputs,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": node_variables,\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                class_attributes = self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                )\n                class_attributes += attributes\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n\n        class_defs = [\n            {\n                class_name: {\n                    \"method_defs\": {\n                        method_name[len(\"class_method_\") :]: {\n                            \"inputs\": details[\"method_inputs\"],\n                            \"calls\": details[\"method_calls\"],\n                            \"call_inputs\": details[\"method_call_inputs\"],\n                            \"returns\": details[\"method_returns\"],\n                        }\n                        for method_name, details in class_details.items()\n                        if method_name.startswith(\"class_method_\")\n                    }\n                }\n            }\n            for class_name, class_details in self.classes.items()\n        ]\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\": node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node), self.tree),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n\n    # get code graph items and add to file_details\n    file_summary = file_details[\"file_info\"][\"file_summary\"]\n    file_ast = file_details[\"file_info\"][\"file_ast\"]\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(\n        file_summary, file_ast\n    )\n    file_details[\"file_info\"][\"entire_code_graph\"] = entire_code_graph\n    file_details[\"file_info\"][\"control_flow_structure\"] = control_flow_structure\n    file_details[\"file_info\"][\"plant_uml\"] = plant_uml\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(file_summary).replace(\n        '\"', \"\"\n    )\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "{'nodes': ['CodeVisitor', 'CodeVisitor.__init__', 'CodeVisitor.visit_FunctionDef', 'CodeVisitor.visit_ClassDef', 'CodeVisitor.generic_visit', 'CodeVisitor.visit_Assign', 'CodeVisitor.extract_details', 'CodeVisitor.analyze', 'remove_docstring', 'get_all_calls', 'get_python_file_details', 'isinstance', 'tree.body.pop', 'ast.walk', 'node.body.pop', 'ast.unparse', 'calls.append', 'ast.iter_child_nodes', 'calls_dict[func].extend', 'open', 'f.read', 'ast.parse', 'logging.warning', 'visitor.analyze', 'get_code_graph', 'json.dumps(file_summary).replace', 'json.dumps', 'self.visit', 'self.constants.append', 'list', 'set', 'next', 'call_data.keys', 'self.classes[self.current_class].setdefault', 'details.update', 'any', 'self.functions.items', 'len', 'class_details.items', 'method_name.startswith', 'self.classes.items', 'self.functions.keys', 'self.classes.keys'], 'edges': [{'source': 'CodeVisitor', 'target': 'CodeVisitor.__init__', 'target_inputs': ['self', 'code', 'tree'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_FunctionDef', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_ClassDef', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.visit_Assign', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor', 'target': 'CodeVisitor.analyze', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor.visit_FunctionDef', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'CodeVisitor.extract_details', 'target_inputs': ['self', 'node', 'node_type'], 'target_returns': ['details']}, {'source': 'CodeVisitor.visit_ClassDef', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.generic_visit', 'target': 'ast.iter_child_nodes', 'target_inputs': ['node']}, {'source': 'CodeVisitor.generic_visit', 'target': 'self.visit', 'target_inputs': ['child']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'isinstance', 'target_inputs': ['node.parent', 'ast.Module', 'target', 'ast.Name', 'value', 'ast.Constant', 'value.value', 'str']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'ast.unparse', 'target_inputs': ['value']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'self.constants.append', 'target_inputs': ['constant_assignment']}, {'source': 'CodeVisitor.visit_Assign', 'target': 'CodeVisitor.generic_visit', 'target_inputs': ['self', 'node'], 'target_returns': []}, {'source': 'CodeVisitor.extract_details', 'target': 'list', 'target_inputs': ['ast.walk(node)', '{ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)}', 'set(node_inputs + node_variables)', 'call_data.keys()', '{ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()', '{ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}', '{ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)}']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.walk', 'target_inputs': ['node']}, {'source': 'CodeVisitor.extract_details', 'target': 'get_all_calls', 'target_inputs': ['node'], 'target_returns': ['calls_dict']}, {'source': 'CodeVisitor.extract_details', 'target': 'ast.unparse', 'target_inputs': ['target', 'node', 'd', 'subnode.value', 'decorator', 'subnode.annotation', 'subnode', 'base']}, {'source': 'CodeVisitor.extract_details', 'target': 'isinstance', 'target_inputs': ['subnode', 'ast.Assign', 'target', 'ast.Name', 'n', 'ast.Expr', 'n.value', 'ast.Str', 'subnode', 'ast.Return', 'subnode', 'ast.AnnAssign', 'subnode', 'ast.Attribute', 'subnode.ctx', 'ast.Store', 'subnode', 'ast.Assign', 'target', 'ast.Attribute', 'target.value', 'ast.Name', 'subnode', 'ast.Assign', 'target', 'ast.Attribute', 'subnode', 'ast.FunctionDef', 'subnode', 'ast.FunctionDef', 'decorator', 'ast.Name']}, {'source': 'CodeVisitor.extract_details', 'target': 'set', 'target_inputs': ['node_inputs + node_variables']}, {'source': 'CodeVisitor.extract_details', 'target': 'next', 'target_inputs': ['(n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str))', 'None']}, {'source': 'CodeVisitor.extract_details', 'target': 'call_data.keys', 'target_inputs': []}, {'source': 'CodeVisitor.extract_details', 'target': 'self.classes[self.current_class].setdefault', 'target_inputs': [\"'class_attributes'\", '[]']}, {'source': 'CodeVisitor.extract_details', 'target': 'details.update', 'target_inputs': [\"{'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]}\"]}, {'source': 'CodeVisitor.extract_details', 'target': 'any', 'target_inputs': [\"(isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list)\"]}, {'source': 'CodeVisitor.analyze', 'target': 'self.visit', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'list', 'target_inputs': ['ast.walk(node)', 'file_dependencies', 'self.functions.keys()', 'self.classes.keys()', 'file_dependencies']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.walk', 'target_inputs': ['node']}, {'source': 'CodeVisitor.analyze', 'target': 'isinstance', 'target_inputs': ['subnode', 'ast.Import', 'subnode', 'ast.ImportFrom']}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'len', 'target_inputs': [\"'class_method_'\"]}, {'source': 'CodeVisitor.analyze', 'target': 'class_details.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'method_name.startswith', 'target_inputs': [\"'class_method_'\"]}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.items', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.functions.keys', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'self.classes.keys', 'target_inputs': []}, {'source': 'CodeVisitor.analyze', 'target': 'remove_docstring', 'target_inputs': ['ast.unparse(node)', 'self.tree'], 'target_returns': ['ast.unparse(tree)']}, {'source': 'CodeVisitor.analyze', 'target': 'ast.unparse', 'target_inputs': ['node']}, {'source': 'remove_docstring', 'target': 'isinstance', 'target_inputs': ['tree.body[0]', 'ast.Expr', 'tree.body[0].value', 'ast.Str', 'node', '(ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)', 'first_body_node', 'ast.Expr', 'first_body_node.value', 'ast.Str']}, {'source': 'remove_docstring', 'target': 'tree.body.pop', 'target_inputs': ['0']}, {'source': 'remove_docstring', 'target': 'ast.walk', 'target_inputs': ['tree']}, {'source': 'remove_docstring', 'target': 'node.body.pop', 'target_inputs': ['0']}, {'source': 'remove_docstring', 'target': 'ast.unparse', 'target_inputs': ['tree']}, {'source': 'get_all_calls', 'target': 'isinstance', 'target_inputs': ['node', 'ast.Call', 'node', 'ast.ClassDef', 'body_item', 'ast.Assign', 'body_item.targets[0]', 'ast.Name']}, {'source': 'get_all_calls', 'target': 'calls.append', 'target_inputs': ['(ast.unparse(node.func), [ast.unparse(arg) for arg in node.args])']}, {'source': 'get_all_calls', 'target': 'ast.unparse', 'target_inputs': ['node.func', 'arg']}, {'source': 'get_all_calls', 'target': 'get_all_calls', 'target_inputs': ['body_item.value', 'calls', 'child', 'calls'], 'target_returns': ['calls_dict']}, {'source': 'get_all_calls', 'target': 'ast.iter_child_nodes', 'target_inputs': ['node']}, {'source': 'get_all_calls', 'target': 'calls_dict[func].extend', 'target_inputs': ['args']}, {'source': 'get_python_file_details', 'target': 'open', 'target_inputs': ['file_path', \"'r'\"]}, {'source': 'get_python_file_details', 'target': 'f.read', 'target_inputs': []}, {'source': 'get_python_file_details', 'target': 'ast.parse', 'target_inputs': ['code']}, {'source': 'get_python_file_details', 'target': 'logging.warning', 'target_inputs': [\"f'{e} error in file: {file_path}'\"]}, {'source': 'get_python_file_details', 'target': 'CodeVisitor', 'target_inputs': ['code', 'tree'], 'target_returns': []}, {'source': 'get_python_file_details', 'target': 'visitor.analyze', 'target_inputs': ['tree']}, {'source': 'get_python_file_details', 'target': 'get_code_graph', 'target_inputs': ['file_summary', 'file_ast']}, {'source': 'get_python_file_details', 'target': 'json.dumps(file_summary).replace', 'target_inputs': ['\\'\"\\'', \"''\"]}, {'source': 'get_python_file_details', 'target': 'json.dumps', 'target_inputs': ['file_summary']}]}"
    },
    {
        "instruction": "Functions in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = (\n            [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None\n        )\n        node_variables = list(\n            {\n                ast.unparse(target)\n                for subnode in node_walk\n                if isinstance(subnode, ast.Assign)\n                for target in subnode.targets\n                if isinstance(target, ast.Name)\n            }\n        )\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": node_inputs,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": node_variables,\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                class_attributes = self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                )\n                class_attributes += attributes\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n\n        class_defs = [\n            {\n                class_name: {\n                    \"method_defs\": {\n                        method_name[len(\"class_method_\") :]: {\n                            \"inputs\": details[\"method_inputs\"],\n                            \"calls\": details[\"method_calls\"],\n                            \"call_inputs\": details[\"method_call_inputs\"],\n                            \"returns\": details[\"method_returns\"],\n                        }\n                        for method_name, details in class_details.items()\n                        if method_name.startswith(\"class_method_\")\n                    }\n                }\n            }\n            for class_name, class_details in self.classes.items()\n        ]\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\": node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node), self.tree),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n\n    # get code graph items and add to file_details\n    file_summary = file_details[\"file_info\"][\"file_summary\"]\n    file_ast = file_details[\"file_info\"][\"file_ast\"]\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(\n        file_summary, file_ast\n    )\n    file_details[\"file_info\"][\"entire_code_graph\"] = entire_code_graph\n    file_details[\"file_info\"][\"control_flow_structure\"] = control_flow_structure\n    file_details[\"file_info\"][\"plant_uml\"] = plant_uml\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(file_summary).replace(\n        '\"', \"\"\n    )\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "'remove_docstring', 'get_all_calls', 'get_python_file_details'\n\nPurpose and Significance:\n1. Function: remove_docstring\n   - Purpose: Eliminating docstrings from given Python source code by removing top-level module docstrings as well as those within functions, classes, and async functions. This function ensures clean code representation without comments or explanatory strings attached to the code blocks.\n    Important Aspects: Identifies Python docstrings and comments associated with modules, functions, and classes, ultimately providing simplified source code snippet by discarding these annotations through method invocations such as 'tree.body.pop()' for top-level docstrings and 'node.body.pop(0)' for nested ones within function definitions or class declarations. Returns the sanitized Python code string after removing docstrings using 'ast.unparse(tree)'.\n\n2. Function: get_all_calls\n   - Purpose: Thorough search throughout the subtree, retrieving information related to every functional invocation nested under specified `node` comprehensively irrespective of residing at various scope locations - plain function calls or encompassed in list comprehensions/lambda expressions. The approach incorporates recursive calling which further ensures inclusion of references occurring inside class attributes as well. Returns a dictionary, linking functions with their argument lists formed using tuples ['function call name', 'list of arguments'].\n   Significance: This function is crucial for understanding the flow of function calls within Python code and helps in mapping dependencies between different parts of the program.\n\n3. Function: get_python_file_details\n   - Purpose: Aimed at deriving extensive details regarding a given Python file through analysis and abstraction, returning structured documentation reflecting multiple facets like function/class information, dependency listing, constants storage, control flow, code graph construction utilizing NetworkX library. This multi-step process includes opening the source file ('open()'), parsing its contents as Abstract Syntax Tree ('ast.parse()'), logging warnings in case of errors via 'logging.warning', instantiating CodeVisitor class for traversal ('CodeVisitor(code, tree)'. Finally, converts extracted data into JSON format for readability ('json.dumps').\n   Importance: This function acts as the primary entry point to gather all required information about a Python file and presents it in an organized manner for further analysis or visualization purposes."
    },
    {
        "instruction": "Classes in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = (\n            [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None\n        )\n        node_variables = list(\n            {\n                ast.unparse(target)\n                for subnode in node_walk\n                if isinstance(subnode, ast.Assign)\n                for target in subnode.targets\n                if isinstance(target, ast.Name)\n            }\n        )\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": node_inputs,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": node_variables,\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                class_attributes = self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                )\n                class_attributes += attributes\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n\n        class_defs = [\n            {\n                class_name: {\n                    \"method_defs\": {\n                        method_name[len(\"class_method_\") :]: {\n                            \"inputs\": details[\"method_inputs\"],\n                            \"calls\": details[\"method_calls\"],\n                            \"call_inputs\": details[\"method_call_inputs\"],\n                            \"returns\": details[\"method_returns\"],\n                        }\n                        for method_name, details in class_details.items()\n                        if method_name.startswith(\"class_method_\")\n                    }\n                }\n            }\n            for class_name, class_details in self.classes.items()\n        ]\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\": node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node), self.tree),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n\n    # get code graph items and add to file_details\n    file_summary = file_details[\"file_info\"][\"file_summary\"]\n    file_ast = file_details[\"file_info\"][\"file_ast\"]\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(\n        file_summary, file_ast\n    )\n    file_details[\"file_info\"][\"entire_code_graph\"] = entire_code_graph\n    file_details[\"file_info\"][\"control_flow_structure\"] = control_flow_structure\n    file_details[\"file_info\"][\"plant_uml\"] = plant_uml\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(file_summary).replace(\n        '\"', \"\"\n    )\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "'CodeVisitor'\n\nPurpose and Significance:\nCodeVisitor Class Purpose and Significance in 'get_python_file_details.py': The CodeVisitor class plays a pivotal role within the Python script by traversing an Abstract Syntax Tree (AST) representing the given source code file. It extracts essential details about functions, classes, dependencies, constants, call relationships between them, and generates a structured documentation format for further analysis. As an extension of ast.NodeVisitor, it inherits several methods to navigate through nodes while adding custom functionalities specific to CodeVisitor. This class instantiates with source code and AST tree as inputs and maintains attributes such as file_info, functions, and classes during the traversal process. Important methods in CodeVisitor are visit_FunctionDef handling function node extraction details, visit_ClassDef extracting class data, analyze performing extensive AST exploration for constructive analysis, generic_visit enabling child nodes processing when explicit visitor methods are missing, and extract_details generating dictionaries with crucial node attributes. Through analyze method execution, CodeVisitor populates the file_info dictionary that comprises key information required for generating file details.\n\nKey responsibilities of CodeVisitor include:\n1. visit_FunctionDef: Extracts function-related data during traversal and adds them to instances' functions dictionary.\n2. visit_ClassDef: Gathers class details while processing the AST and updates instance classes dictionary accordingly.\n3. generic_visit: Traverses child nodes when specific methods are absent in CodeVisitor; facilitates inheritance from parent node to subnodes stack-wise navigation.\n4. visit_Assign: Identifies constant variable assignments within module scope, updating self.constants list.\n5. extract_details: Extracts node details as a dictionary with keys representing various attributes like inputs, calls, returns, dependencies, etc., based on the given node type ('node_type').\n6. analyze: Traverses AST comprehensively to capture diverse code elements and populates file_info dictionary with extracted data. This method also generates file summaries for further processing in get_code_graph().\n\nOverall, CodeVisitor acts as a central component in the script by extracting vital information from Python files through AST traversal and maintaining crucial details about functions, classes, dependencies, constants, call relationships, and constructing a code graph representation."
    },
    {
        "instruction": "1) Describe the overall Purpose and Processing Approach of Python file: `py2dataset\\get_python_file_details.py`; 2) Define API Signatures for each applicable Function and Class Method; 3) Derive Functional Requirements to specify the code's behavior and purpose; 4) Explain what each variable does in the code.",
        "input": "```python\n\"\"\"\nReturn file_details dictionary for python source code.\nRequirements:\n[req00] The `remove_docstring` function shall:\n        a. Accept a Python code string as an argument.\n        b. Remove docstrings and comments from the provided code.\n        c. Return the sanitized code string.\n[req01] The get_all_calls function shall:\n        a. Accept a node of type ast.AST as an argument.\n        b. Recursively find all function calls in the subtree rooted at the node.\n        c. Return a dictionary of all function calls in the subtree rooted at the node.\n[req02] The `CodeVisitor` class shall:\n        a. Accept the source code as input when instantiated.\n        b. Use the AST to extract details about the code.\n        c. Inherit from `ast.NodeVisitor`.\n        d. Implement `visit_FunctionDef` method to gather details about functions.\n        e. Implement `visit_ClassDef` method to gather details about classes.\n        f. Implement `extract_details` method to parse information about a given node.\n        g. Implement `analyze` method to traverse the AST and 'file_info'. \n        h. Maintain a current class context using the attribute 'current_class'.\n[req03] The `code_graph` function shall:\n        a. Accept the file summary as input.\n        b. Construct a directed graph with nodes and edges using networkx library.\n        c. Define elements such as function nodes, class nodes, and method nodes.\n        d. Specify edges to represent relationships. \n        e. Return a dictionary representation of the code call graph. \n[req04] The `get_python_file_details` function shall:\n        a. Accept a file path as an argument.\n        b. Extract info from Python file using the AST and the `CodeVisitor` class.\n        c. Include the entire code graph in the returned details.\n        d. Return a dictionary encompassing the extracted file details. \n\"\"\"\nimport ast\nimport logging\nimport json\nfrom typing import Dict, List, Union\nfrom get_code_graph import get_code_graph\n\n\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if (\n        tree.body\n        and isinstance(tree.body[0], ast.Expr)\n        and isinstance(tree.body[0].value, ast.Str)\n    ):\n        tree.body.pop(0)\n\n    for node in ast.walk(tree):\n        if (\n            isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef))\n            and node.body\n        ):\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(\n                first_body_node.value, ast.Str\n            ):\n                node.body.pop(0)\n\n    return ast.unparse(tree)\n\n\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(\n                body_item.targets[0], ast.Name\n            ):\n                get_all_calls(body_item.value, calls)\n\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n\n    # Build the dictionary after traversal\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n\n    return calls_dict\n\n\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(\n            node, \"method\" if self.current_class else \"function\"\n        )\n        if self.current_class:\n            self.classes[self.current_class][f\"class_method_{node.name}\"] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(\n            node, \"class\"\n        )  # populate class dictionary when class definition found in AST\n        self.current_class = node.name  # set current_class to indicate inside a class\n        self.generic_visit(node)  # continue AST traversal to the next node\n        self.current_class = None  # reset current_class when finished with this class\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f\"{target.id}={value_repr}\"\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(\n        self, node: ast.AST, node_type: str\n    ) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = (\n            [arg.arg for arg in node.args.args]\n            if node_type in [\"function\", \"method\"]\n            else None\n        )\n        node_variables = list(\n            {\n                ast.unparse(target)\n                for subnode in node_walk\n                if isinstance(subnode, ast.Assign)\n                for target in subnode.targets\n                if isinstance(target, ast.Name)\n            }\n        )\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n\n        details = {\n            f\"{node_type}_name\": node.name,\n            f\"{node_type}_code\": ast.unparse(node),\n            f\"{node_type}_docstring\": next(\n                (\n                    n.value.s\n                    for n in node_walk\n                    if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)\n                ),\n                None,\n            ),\n            f\"{node_type}_inputs\": node_inputs,\n            f\"{node_type}_defaults\": [ast.unparse(d) for d in node.args.defaults]\n            if node_type in [\"function\", \"method\"]\n            else None,\n            f\"{node_type}_returns\": [\n                ast.unparse(subnode.value) if subnode.value is not None else \"None\"\n                for subnode in node_walk\n                if isinstance(subnode, ast.Return)\n            ],\n            f\"{node_type}_calls\": list(call_data.keys()),\n            f\"{node_type}_call_inputs\": call_data,\n            f\"{node_type}_variables\": node_variables,\n            f\"{node_type}_decorators\": list(\n                {ast.unparse(decorator) for decorator in node.decorator_list}\n                if node.decorator_list\n                else set()\n            ),\n            f\"{node_type}_annotations\": list(\n                {\n                    ast.unparse(subnode.annotation)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.AnnAssign)\n                    and subnode.annotation is not None\n                }\n            ),\n            f\"{node_type}_properties\": list(\n                {\n                    ast.unparse(subnode)\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Attribute)\n                    and isinstance(subnode.ctx, ast.Store)\n                }\n            ),\n        }\n        if node_type in [\"class\", \"method\"]:\n            if (\n                node_type == \"method\" and self.current_class\n            ):  # find attributes defined as self.attribute\n                attributes = [\n                    target.attr\n                    for subnode in node_walk\n                    if isinstance(subnode, ast.Assign)\n                    for target in subnode.targets\n                    if isinstance(target, ast.Attribute)\n                    and isinstance(target.value, ast.Name)\n                    and target.value.id == \"self\"\n                ]\n                class_attributes = self.classes[self.current_class].setdefault(\n                    \"class_attributes\", []\n                )\n                class_attributes += attributes\n            if node_type == \"class\":\n                details.update(\n                    {\n                        \"class_attributes\": [\n                            target.attr\n                            for subnode in node.body\n                            if isinstance(subnode, ast.Assign)\n                            for target in subnode.targets\n                            if isinstance(target, ast.Attribute)\n                        ],\n                        \"class_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                        ],\n                        \"class_inheritance\": [ast.unparse(base) for base in node.bases]\n                        if node.bases\n                        else [],\n                        \"class_static_methods\": [\n                            subnode.name\n                            for subnode in node.body\n                            if isinstance(subnode, ast.FunctionDef)\n                            and any(\n                                isinstance(decorator, ast.Name)\n                                and decorator.id == \"staticmethod\"\n                                for decorator in subnode.decorator_list\n                            )\n                        ],\n                    }\n                )\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        # Traverse the AST to capture various code details\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n\n        file_dependencies = {\n            alias.name\n            for subnode in node_walk\n            if isinstance(subnode, ast.Import)\n            for alias in subnode.names\n        } | {\n            subnode.module\n            for subnode in node_walk\n            if isinstance(subnode, ast.ImportFrom)\n        }\n\n        function_defs = [\n            {\n                func_name: {\n                    \"inputs\": details[\"function_inputs\"],\n                    \"calls\": details[\"function_calls\"],\n                    \"call_inputs\": details[\"function_call_inputs\"],\n                    \"returns\": details[\"function_returns\"],\n                }\n            }\n            for func_name, details in self.functions.items()\n        ]\n\n        class_defs = [\n            {\n                class_name: {\n                    \"method_defs\": {\n                        method_name[len(\"class_method_\") :]: {\n                            \"inputs\": details[\"method_inputs\"],\n                            \"calls\": details[\"method_calls\"],\n                            \"call_inputs\": details[\"method_call_inputs\"],\n                            \"returns\": details[\"method_returns\"],\n                        }\n                        for method_name, details in class_details.items()\n                        if method_name.startswith(\"class_method_\")\n                    }\n                }\n            }\n            for class_name, class_details in self.classes.items()\n        ]\n\n        self.file_info = {\n            \"file_code\": self.code,\n            \"file_ast\": node,\n            \"file_dependencies\": list(file_dependencies),\n            \"file_functions\": list(self.functions.keys()),\n            \"file_classes\": list(self.classes.keys()),\n            \"file_constants\": self.constants,\n            \"file_summary\": {\n                \"dependencies\": list(file_dependencies),\n                \"function_defs\": function_defs,\n                \"class_defs\": class_defs,\n            },\n            \"file_code_simplified\": remove_docstring(ast.unparse(node), self.tree),\n        }\n\n\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f\"{e} error in file: {file_path}\")\n        return None\n\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {\n        \"file_info\": visitor.file_info,\n        \"functions\": visitor.functions,\n        \"classes\": visitor.classes,\n    }\n\n    # get code graph items and add to file_details\n    file_summary = file_details[\"file_info\"][\"file_summary\"]\n    file_ast = file_details[\"file_info\"][\"file_ast\"]\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(\n        file_summary, file_ast\n    )\n    file_details[\"file_info\"][\"entire_code_graph\"] = entire_code_graph\n    file_details[\"file_info\"][\"control_flow_structure\"] = control_flow_structure\n    file_details[\"file_info\"][\"plant_uml\"] = plant_uml\n    file_details[\"file_info\"][\"file_summary\"] = json.dumps(file_summary).replace(\n        '\"', \"\"\n    )\n    del file_details[\"file_info\"][\"file_ast\"]\n\n    return file_details\n\n```",
        "output": "Overall Purpose and Processing Approach of Python File 'get_python_file_details.py': This Python script aims to extract comprehensive details about a given Python file by analyzing its Abstract Syntax Tree (AST), removing docstrings, identifying functions, classes, dependencies, constants, calls between functions/methods, and constructing a code graph representation using the NetworkX library. It utilizes various helper methods such as remove_docstring(), get_all_calls(), CodeVisitor class for traversing AST nodes, extracting details about functions and classes, and generating a code graph via get_code_graph().\n\n1) Function: remove_docstring\n- Purpose: Remove docstrings from provided Python code including top-level module docstrings and docstrings in functions/classes/async functions.\n- Inputs: 'code' (source code string), 'tree' (AST representation of the source code).\n- Calls Made: tree manipulation methods like 'tree.body.pop', 'ast.walk', 'node.body.pop', 'ast.unparse'.\n- Variables Used: 'tree', 'first_body_node', 'code'.\n- Returns: Sanitized code string after removing docstrings ('ast.unparse(tree)').\n\n2) Function: get_all_calls\n- Purpose: Recursively find all function calls in the subtree rooted at a given node including those in class attributes, list comprehensions, and lambda functions.\n- Inputs: 'node' (root node), optional argument 'calls'. If none provided initializes calls as an empty list of tuples [function name, arguments].\n- Calls Made: 'isinstance', 'calls.append', 'ast.unparse', 'get_all_calls', 'ast.iter_child_nodes', 'calls_dict[func].extend'.\n- Variables Involved: 'calls', 'calls_dict', 'calls', 'node', 'func'.\n- Returns: Dictionary mapping function calls as strings to their argument lists ('calls_dict').\n\n3) Function Call: get_python_file_details\n- Purpose: Extract file details from a Python file path and generate structured documentation.\n- Inputs: 'file_path' (str, file location).\n- Calls Made: Opening file ('open'), parsing ('ast.parse'), warning logging via 'logging.warning', Instantiating 'CodeVisitor', traversing with visitor ('visitor.analyze'), 'json.dumps', string modification to remove quotations.\n- Variables Handled: 'file_path', 'tree', 'file_summary', 'file_details', 'code', 'visitor', 'file_ast'.\n- Returns: Dictionary containing extracted file details ('file_details') or None on error.\n\n4) Class: CodeVisitor\n- Type/Role: Class extending ast.NodeVisitor that traverses an AST extracting code information and storing in instance variables such as 'code', 'functions', 'classes', 'file_info', and maintaining 'current_class'.\n- Methods Implemented: __init__, visit_FunctionDef, visit_ClassDef, generic_visit, visit_Assign, extract_details, analyze.\n- Inheritance: ast.NodeVisitor.\n- Variables Stored: 'tree', 'current_class', 'file_info'.\n\n5) Method: CodeVisitor.__init__\n- Purpose: Initialize a new instance of the class with source code and AST tree as inputs.\n- Inputs: 'self' (instance), 'code' (source code string), 'tree' (AST representation).\n- Variables Assigned: 'self', 'tree', 'code'.\n\n6) Method: CodeVisitor.visit_FunctionDef\n- Purpose: Extract details about functions found during AST traversal, adds to the function dictionary in instances.\n- Inputs: 'self', 'node' (function node).\n- Called Functions/Methods: Invoking 'self.extract_details()', propagates processing down through generic visit method.\n\n7) Method: CodeVisitor.visit_ClassDef\n- Purpose: Extract class details and stores them in instances during AST traversal.\n- Inputs: 'self', 'node' (class node).\n- Called Functions/Methods: Invoking 'self.extract_details()', propagates processing down through generic visit method.\n\n8) Method: CodeVisitor.generic_visit\n- Purpose: Perform child nodes traversal while executing a visiting method of a subclass node when not defined specifically in CodeVisitor class.\n- Inputs: 'self', 'node' (the actual visiting Node).\n- Called Function: AstTree iterator, visits inheritable attributes/values and maintains stack based process in a 'parent to child nodes.' Relay propagates call of 'self.visit()'.\n\n9) Method: CodeVisitor.visit_Assign\n- Purpose: Capture constant variable assignments within module scope.\n- Inputs: 'self', 'node' (Assignment node).\n- Called Functions/Methods: Checking instance types ('isinstance'), updating 'self.constants'.\n- Variables Created: 'value_repr', 'constant_assignment', 'node', 'self', 'value'.\n\n10) Method: CodeVisitor.extract_details\n- Purpose: Extract details about an ast node depending on type and maintain data as dict {'key': Union[str, List[str]}.\n- Inputs: 'self', 'node', 'node_type' (type of the AST Node).\n- Called Functions/Methods: Walking tree ('ast.walk'), constructing dictionaries of various attributes ('get_all_calls', 'next', 'set', 'call_data.keys').\n- Variables Manipulated: 'node_inputs', 'details', 'node', 'self', 'node_variables', 'node_walk', 'node_type', 'call_data'.\n- Returns: Dict of node details extracted from the ast Node ('details').\n\n11) Method: CodeVisitor.analyze\n- Purpose: Traverse AST, list all nodes and populate file information dictionary.\n- Inputs: 'self', 'node' (root node).\n- Called Functions/Methods: Invoking self visit methods ('self.visit'), constructing dependencies lists, function defs dict, class defs dict, removing docstrings ('remove_docstring').\n- Variables Manipulated: 'file_dependencies', 'function_defs', 'class_defs', 'node', 'node_walk'."
    },
    {
        "instruction": "Methods in `CodeVisitor` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n        node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n                class_attributes += attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "'__init__', 'visit_FunctionDef', 'visit_ClassDef', 'generic_visit', 'visit_Assign', 'extract_details', 'analyze'\n\nPurpose and Significance:\nCodeVisitor Class in Detail:\nThis class plays a vital role within the given Python script by traversing an Abstract Syntax Tree (AST) to extract comprehensive information about a provided source code. It extends the ast.NodeVisitor class and houses various methods to handle diverse functionalities related to code analysis. Each method contributes distinctly to achieving this objective as described below:\n\n1. __init__(self, code: str, tree: ast.AST): The initialization routine primarily takes Python 'source_code' (denoted by variable `code`) and 'Abstract Syntax Tree Representation ('tree` from arguments before beginning the extraction process. It sets up essential instance variables such as `functions`, `classes`, `file_info`, and `current_class`.\n\n2. visit_FunctionDef(self, node: ast.FunctionDef): This method focuses on extracting details about functions encountered during AST traversal. Upon visiting a FunctionDef node, it calls the `extract_details` function to store relevant information in `functions` dictionary under corresponding function names. It further propagates processing by invoking `generic_visit`.\n\n3. visit_ClassDef(self, node: ast.ClassDef): This method concentrates on extracting class details during AST traversal. Similar to `visit_FunctionDef`, it utilizes `extract_details` to store relevant information in `classes` dictionary under respective class names and then proceeds with `generic_visit`. Additionally, if within a class definition, it collects attributes defined as self.<attribute> by tracking `self.current_class`.\n\n4. generic_visit(self, node): This method serves as a catch-all for nodes where no explicit visitor function exists. It iterates through child nodes of the given 'node', calling `self.visit()` recursively to traverse further down the AST tree while maintaining parent-child relationships using `node.parent = node`.\n\n5. visit_Assign(self, node: ast.Assign): While exploring the assignment statement ('node'), this method inspects if variable assignment refers to constant variables in global scope by analyzing subnodes for suitable cases within a Module context and stores them under 'constants' list of self instance.\n\n6. extract_details(self, node: ast.AST, node_type: str): This crucial method extracts details about an AST node based on its type ('node_type') as dict {'key': Union[str, List[str]} format. It makes extensive use of `ast.walk()` for thorough data retrieval before populating details about input nodes into appropriate categories in a unified 'details' dictionary and updating variables such as `function_inputs`, `method_calls`, `class_methods`, etc., depending on node type ('node_type').\n\n7. analyze(self, node: ast.AST): This method is responsible for traversing the entire AST tree to capture various code details like dependencies, functions, classes, constants, calls between functions/methods, and constructs a code graph representation using NetworkX library. It invokes `visit()` to perform the actual traversal, compiles diverse information into `file_info`, populates 'function_defs', 'class_defs' lists for later usage, simplifies source code ('remove_docstring'), and eventually passes tree data to get_code_graph()."
    },
    {
        "instruction": "Docstring of `CodeVisitor` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n        node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n                class_attributes += attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file."
    },
    {
        "instruction": "Attributes of `CodeVisitor` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n        node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n                class_attributes += attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "'tree', 'current_class', 'current_class', 'file_info'\n\nPurpose and Significance:\n1. Attribute: 'tree' in `CodeVisitor`\n   - Purpose: This attribute represents the Abstract Syntax Tree (AST) representation of the input Python source code obtained after parsing it using `ast.parse`. It serves as a foundation for traversing and extracting details about functions, classes, dependencies, constants, calls between functions/methods within the codebase. During initialization through `__init__`, 'tree' is assigned with the parsed AST from the given source code string.\n\n2. Attribute: 'current_class' in `CodeVisitor`\n   - Purpose: This attribute maintains contextual information about the class definition being processed during traversal. It indicates whether the current node under analysis belongs to a function or is nested within a class definition. When inside a class, it stores the name of the class being visited. 'current_class' helps differentiate between attributes defined at module level and those within classes while extracting details about nodes like methods and class attributes.\n\n3. Attribute: 'file_info' in `CodeVisitor`\n   - Purpose: This attribute captures extracted data and detailed insights on the input file which comprises an elaborate dictionary including key elements like source code without docstrings, dependency imports, summarized functions & classes, constant variable declarations in modules and an organized view of file analysis results. It is populated during `analyze` method execution by consolidating information gathered from traversing AST nodes. The 'file_info' dictionary forms a significant part of the final output returned by `get_python_file_details`."
    },
    {
        "instruction": "Inheritance of `CodeVisitor` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\nclass CodeVisitor(ast.NodeVisitor):\n    \"\"\"\n    Visitor class for traversing an AST (Abstract Syntax Tree) and extracting details about the code.\n    Attributes:\n        code (str): The source code.\n        functions(Dict): details about functions in the code.\n        classes (Dict): details about classes in the code.\n        file_info (Dict): details about the file.\n    Methods:\n        visit_FunctionDef(node: ast.FunctionDef) -> None:\n            Extract details about a function.\n        visit_ClassDef(node: ast.ClassDef) -> None:\n            Extract details about a class.\n        extract_details(node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n            Extract details about a node.\n        analyze(node: ast.AST) -> None:\n            Populate file_info with details about the file.\n    \"\"\"\n\n    def __init__(self, code: str, tree: ast.AST) -> None:\n        \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n        self.code: str = code\n        self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n        self.file_info: Dict[str, Union[str, List[str]]] = {}\n        self.current_class: str = None\n        self.constants: List[str] = []\n        self.tree = tree\n\n    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n        \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n        details = self.extract_details(node, 'method' if self.current_class else 'function')\n        if self.current_class:\n            self.classes[self.current_class][f'class_method_{node.name}'] = details\n        else:\n            self.functions[node.name] = details\n        self.generic_visit(node)\n\n    def visit_ClassDef(self, node: ast.ClassDef) -> None:\n        \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n        self.classes[node.name] = self.extract_details(node, 'class')\n        self.current_class = node.name\n        self.generic_visit(node)\n        self.current_class = None\n\n    def generic_visit(self, node):\n        \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n        for child in ast.iter_child_nodes(node):\n            child.parent = node\n            self.visit(child)\n\n    def visit_Assign(self, node: ast.Assign):\n        \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n        if isinstance(node.parent, ast.Module):\n            for target in node.targets:\n                if isinstance(target, ast.Name):\n                    value = node.value\n                    if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                        value_repr = f\"'{value.value}'\"\n                    else:\n                        value_repr = ast.unparse(value)\n                    constant_assignment = f'{target.id}={value_repr}'\n                    self.constants.append(constant_assignment)\n        self.generic_visit(node)\n\n    def extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n        node_walk = list(ast.walk(node))\n        call_data = get_all_calls(node)\n        node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n        node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n        if node_inputs:\n            node_variables = list(set(node_inputs + node_variables))\n        details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n        if node_type in ['class', 'method']:\n            if node_type == 'method' and self.current_class:\n                attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n                class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n                class_attributes += attributes\n            if node_type == 'class':\n                details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n        return details\n\n    def analyze(self, node: ast.AST) -> None:\n        \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n        self.visit(node)\n        node_walk = list(ast.walk(node))\n        file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n        function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n        class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n        self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "'ast.NodeVisitor'\n\nPurpose and Significance:\nThe Purpose of inheriting 'ast.NodeVisitor' for Python's CodeVisitor class lies within its functionality to traverse Abstract Syntax Tree (AST) structures efficiently during program analysis while extracting important information regarding functions and classes embedded in the Python codebase. By utilizing the ast NodeVisitor superclass from python's `ast` module, the 'CodeVisitor' achieves several core responsibilities necessary for thorough code interpretation:\n\n1. Enabling visit methods that process distinct AST node types such as FunctionDef and ClassDef - This ensures dynamic exploration of code components with unique properties in an organized manner during analysis.\n2. Abstracting generic visits when no explicit visitor function exists - The `generic_visit()` method takes care of visiting any other unspecified nodes within the AST hierarchy, thus providing a comprehensive traversal experience for complex code structures.\n3. Integrating various NodeVisitor features such as 'ast.walk' to explore connected subnodes, enabling detailed data extraction during processing.\n\nBy combining these inherited functionalities from ast.NodeVisitor, CodeVisitor can successfully parse Python source code into structured information related to functions and classes, providing deeper insights for code understanding and analysis in `get_python_file_details`."
    },
    {
        "instruction": "Inputs to `CodeVisitor.extract_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n    node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n    if node_inputs:\n        node_variables = list(set(node_inputs + node_variables))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n            class_attributes += attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details\n```",
        "output": "'self', 'node', 'node_type'\n\nPurpose and Significance:\nIn the context of the CodeVisitor class within the 'get_python_file_details.py' Python script, `extract_details` function serves an important role for extricating diverse code characteristics concerning selected Nodes discovered throughout Abstract Syntax Tree (AST) traversal via Instance Method calls ('self'). Taking three inputs - 'self', 'node', and 'node_type', it operates as a crucial data extractor within the CodeVisitor class.\n\n1. 'self': This refers to the current instance of the CodeVisitor object which holds vital attributes like 'code', 'functions', 'classes', 'file_info', and 'current_class'. It provides access to these variables required for accumulating node details during extraction.\n\n2. 'node': Represents the AstNode being processed at a particular moment in traversal, enabling `extract_details` to gather information related to its specific attributes and structure. This Node acts as an anchor point for extracting relevant data from the Abstract Syntax Tree.\n\n3. 'node_type': It signifies the type of node being processed ('class', 'function', 'method', etc.) and helps `extract_details` function to identify distinct characteristics associated with each node category while generating a structured dictionary output. This input allows tailoring extraction logic according to the node's nature, ensuring accurate data retrieval for further analysis.\n\nThe combination of these inputs ('self', 'node', and 'node_type') results in assembling meaningful metadata on different sections (classes/functions/methods) from an analyzed Python source code efficiently through a customized data dictionary generation per node's characteristic nature within `extract_details` method execution. This information is later utilized to build comprehensive file documentation."
    },
    {
        "instruction": "Docstring of `CodeVisitor.extract_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n    node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n    if node_inputs:\n        node_variables = list(set(node_inputs + node_variables))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n            class_attributes += attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details\n```",
        "output": "Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node."
    },
    {
        "instruction": "Calls made in `CodeVisitor.extract_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n    node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n    if node_inputs:\n        node_variables = list(set(node_inputs + node_variables))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n            class_attributes += attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details\n```",
        "output": "'list', 'ast.walk', 'get_all_calls', 'ast.unparse', 'isinstance', 'set', 'next', 'call_data.keys', 'self.classes[self.current_class].setdefault', 'details.update', 'any'\n\nPurpose and Significance:\nIn the `CodeVisitor.extract_details` method within the given Python script 'get_python_file_details.py', several critical calls are executed to extract comprehensive details about nodes encountered during Abstract Syntax Tree (AST) traversal. These calls play a significant role in gathering information related to functions, classes, and other essential aspects of the Python code. Below is an explanation of each call's purpose:\n\n1. `list`: This built-in Python function creates a new empty list used for storing variables associated with respective nodes' features extracted in a node iteration. Throughout 'extract_details', numerous instances arise, e.g., generating node lists of properties for methods and constants assignments (\"class_methods\", \"function_inputs\").\n\n2. `ast.walk`: This function traverses the AST recursively starting from the given node and yields all descendants while maintaining parent-child relationships. It helps explore nested structures within nodes to collect necessary details like docstrings, inputs, returns, annotations, etc., required for generating node descriptions.\n\n3. `get_all_calls`: This function is invoked to find all function calls in the subtree rooted at the current node. It recursively searches for Call nodes and constructs a dictionary of function calls with their arguments. The returned dictionary later contributes to mapping function names to their respective input lists within extracted details.\n\n4. `ast.unparse`: This method converts an abstract syntax tree node back into a string representation of Python code. It is utilized in removing docstrings by passing the sanitized AST ('tree') and building file information strings like 'file_info[\"file_code_simplified\"] after cleaning docstrings.\n\n5. `isinstance`: This built-in function checks if an object belongs to a specific class or implements certain methods/attributes. In `CodeVisitor`, it ensures proper node type identification during traversal, e.g., distinguishing between FunctionDef nodes and ClassDef nodes ('if isinstance(node, ast.FunctionDef)', 'isinstance(subnode, ast.Assign)' for target validation in constant assignments.\n\n6. `set`: A Python data structure used to create or update sets dynamically. In `CodeVisitor`, it generates lists from extracted attributes/nodes sets, e.g., collecting class dependencies ('file_dependencies'), function input lists (\"function_inputs\"), method calls inputs (\"method_call_inputs\"), etc.\n\n7. `next`: This built-in Python function returns the next item from an iterable object when called with no arguments in a loop context. In `remove_docstring`, it extracts docstrings by iterating over node walk results ('for n in node_walk') and selecting the first string value ('next(n.value.s, None)').\n\n8. `call_data.keys()`: Obtaining all function keys ('function_calls', 'method_calls') within `get_all_calls`. The key-list assists in generating detailed mappings for nodes during traversal of Call objects discovered recursively within functions and methods.\n\n9. `self.classes[self.current_class].setdefault`: This dictionary method adds an element with specified keys only if it does not exist initially, else updates its value with the given default object ('class_attributes'). It is used to accumulate attributes defined as self.attribute within classes.\n\n10. `details.update`: Merging two dictionaries into one by updating 'target' dictionary with values from another ('source') if keys exist in both, else adding new key-value pairs from the second dictionary ('source'). In `CodeVisitor`, it combines class details retrieved recursively during traversal to form comprehensive class descriptions.\n\n11. `any`: This built-in function returns True if any element in an iterable satisfies a given condition ('for decorator in subnode.decorator_list'), which helps identify static methods within classes during AST traversal."
    },
    {
        "instruction": "Variables in `CodeVisitor.extract_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n    node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n    if node_inputs:\n        node_variables = list(set(node_inputs + node_variables))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n            class_attributes += attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details\n```",
        "output": "'attributes', 'node_inputs', 'details', 'class_attributes', 'node', 'node_variables', 'self', 'node_walk', 'node_type', 'call_data'\n\nPurpose and Significance:\nIn `CodeVisitor.extract_details`, this method serves as a crucial component within the CodeVisitor class responsible for extracting specific details about different nodes encountered during Abstract Syntax Tree traversal. Each variable mentioned holds significance in capturing and organizing data related to various aspects of Python code analysis. Here's their roles:\n\n1. `attributes` (Not directly used but relevant): This variable represents attributes declared as 'self' in ClassDef node while recursing inAST Walker (as inner variable) referring possibly added through class scope declarations and their identifiers if available under Class objects - however not immediately touched up inside the extract_details method itself.\n\n2. `node_inputs`: This variable collects input arguments for functions or methods within the current node being processed during extraction. It is populated with argument lists from FunctionDef nodes encountered in AST traversal and stored as values under 'function_inputs' or 'method_inputs' keys in respective details dictionaries later on.\n\n3. `details`: This variable holds an accumulating dictionary comprising all extracted data for the current node being processed. It aggregates diverse attributes such as names, docstrings, returns, calls, defaults, inputs, call inputs, decorators, and annotations pertinent to functions or classes as per 'node_type'. The extracted details are structured according to 'node_type' identifier ('function', 'method', 'class').\n\n4. `class_attributes` (Not directly used but relevant): Similar to attributes but specific to ClassDef nodes capturing method identifiers declared within class scope. It becomes a part of the output when processing ClassDef nodes during AST traversal.\n\n5. `node`: It signifies the current node being processed in `extract_details`, acting as an input parameter for extracting relevant information about its properties. This variable assists in maintaining context throughout method execution.\n\n6. `node_variables`: This variable stores a list of names identified as variables within the node's scope. It helps in gathering local variables information during AST traversal and gets stored under 'function_variables' or 'method_variables' keys later on depending upon 'node_type'.\n\n7. `self`: Represents the instance of CodeVisitor itself which invokes extract_details for multiple nodes throughout its lifecycle, maintaining contextual data like functions dictionary ('functions'), classes dictionary ('classes'), file information dictionary ('file_info') and current class identifier ('current_class'). It also triggers other methods such as `visit_*` and `generic_visit`.\n\n8. `node_walk`: This variable contains an iterable list of nodes derived from ast.walk(node) operation in the method body, providing a generator to loop over children of current node facilitating more accurate analysis while processing node properties.\n\n9. `node_type`: An input parameter defining node categories encountered ('function', 'class', etc.) determining the keys in detail dictionary ('function_*'/'method_*'/'class_*') depending on current context (set in Visit* methods). This attribute is significant to segregate nodes efficiently.\n\n10. `call_data`: It represents a dictionary of function calls found during recursion within the node subtree, which gets stored under 'function_calls'/'method_calls' keys in respective details dictionaries later on."
    },
    {
        "instruction": "Returns from `CodeVisitor.extract_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef extract_details(self, node: ast.AST, node_type: str) -> Dict[str, Union[str, List[str]]]:\n    \"\"\"\n        Extract details about a node.\n        Args:\n            node: ast.AST: The node to extract details from.\n            node_type: str: The type of node.\n        Returns:\n            Dict[str, Union[str, List[str]]]: The details extracted from the node.\n        \"\"\"\n    node_walk = list(ast.walk(node))\n    call_data = get_all_calls(node)\n    node_inputs = [arg.arg for arg in node.args.args] if node_type in ['function', 'method'] else None\n    node_variables = list({ast.unparse(target) for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Name)})\n    if node_inputs:\n        node_variables = list(set(node_inputs + node_variables))\n    details = {f'{node_type}_name': node.name, f'{node_type}_code': ast.unparse(node), f'{node_type}_docstring': next((n.value.s for n in node_walk if isinstance(n, ast.Expr) and isinstance(n.value, ast.Str)), None), f'{node_type}_inputs': node_inputs, f'{node_type}_defaults': [ast.unparse(d) for d in node.args.defaults] if node_type in ['function', 'method'] else None, f'{node_type}_returns': [ast.unparse(subnode.value) if subnode.value is not None else 'None' for subnode in node_walk if isinstance(subnode, ast.Return)], f'{node_type}_calls': list(call_data.keys()), f'{node_type}_call_inputs': call_data, f'{node_type}_variables': node_variables, f'{node_type}_decorators': list({ast.unparse(decorator) for decorator in node.decorator_list} if node.decorator_list else set()), f'{node_type}_annotations': list({ast.unparse(subnode.annotation) for subnode in node_walk if isinstance(subnode, ast.AnnAssign) and subnode.annotation is not None}), f'{node_type}_properties': list({ast.unparse(subnode) for subnode in node_walk if isinstance(subnode, ast.Attribute) and isinstance(subnode.ctx, ast.Store)})}\n    if node_type in ['class', 'method']:\n        if node_type == 'method' and self.current_class:\n            attributes = [target.attr for subnode in node_walk if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute) and isinstance(target.value, ast.Name) and (target.value.id == 'self')]\n            class_attributes = self.classes[self.current_class].setdefault('class_attributes', [])\n            class_attributes += attributes\n        if node_type == 'class':\n            details.update({'class_attributes': [target.attr for subnode in node.body if isinstance(subnode, ast.Assign) for target in subnode.targets if isinstance(target, ast.Attribute)], 'class_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef)], 'class_inheritance': [ast.unparse(base) for base in node.bases] if node.bases else [], 'class_static_methods': [subnode.name for subnode in node.body if isinstance(subnode, ast.FunctionDef) and any((isinstance(decorator, ast.Name) and decorator.id == 'staticmethod' for decorator in subnode.decorator_list))]})\n    return details\n```",
        "output": "'details'\n\nPurpose and Significance:\nIn the given Python script 'get_python_file_details.py', within the 'CodeVisitor' class, the `extract_details` method holds vital responsibilities while processing Abstract Syntax Tree nodes to retrieve important attributes of a program during traversal. This function returns a dictionary containing extracted information about functions ('function') or classes ('class'), each key-value pair representing specific details as Union[str, List[str] types. The purpose is to consolidate significant data points for further processing and documentation generation. Below are the descriptions of each return value from `CodeVisitor.extract_details`:\n\n1. `{'function_name': <String>` - Represents the name of a function or method within the Python code under analysis.\n2. `'{node_type}_code': <String>` - The raw ast unparsed representation of the extracted node for better understanding of its structure in source code format.\n3. `'file_docstring': <String>` - Captures the docstring associated with the function or class node if present, removing any potential errors related to improper syntax during extraction. Note that this key might not always be available depending on whether a docstring exists for the specific node.\n4. `'{node_type}_inputs': <List[str]` - Lists down input arguments for functions or method parameters if applicable. This information helps in understanding function signatures and argument requirements.\n5. `'{node_type}_calls': <Set[String>` - Maintains a set of called functions/methods names within the current node scope, useful to identify dependencies between different parts of code.\n6. `'{node_type}_call_inputs': <List[str]` - Provides input arguments for each call found in function or method invocations during traversal. This data helps in understanding how functions are being utilized across the program.\n7. `'{node_type}_returns': <List[str]` - Lists return values of functions or methods if specified explicitly within the code.\n8. For classes specifically ('class'), there are additional returns as follows:\n   a. `'method_defs': <Dict[<String, Dict[String, Union[List[str], List[List[str]]>` - A dictionary containing method names under the class with their respective input arguments ('method_inputs'), call inputs ('method_call_inputs'), and return values ('method_returns').\n   b. `'class_attributes': <List[String]` - Captures attributes defined within a class as strings for further analysis.\n   c. `'class_methods': <List[String>` - Lists down all methods present in the class definition.\n   d. `'class_inheritance': <List[String>` - Records any base classes imported by the current class if applicable.\n   e. `'class_static_methods': <List[String>` - Identifies static methods within a class definition.\n\nThese extracted details are crucial for generating comprehensive documentation about Python code structure and facilitating analysis on program flow, dependencies, method call patterns, function argument usage, and understanding of inheritance hierarchy. Overall, `CodeVisitor.extract_details` is the primary source for data gathering about individual nodes before merging all collected information into file summary within the 'CodeVisitor' instance for downstream usage like creating a code graph using `get_code_graph()`."
    },
    {
        "instruction": "Inputs to `CodeVisitor.analyze` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the context of 'CodeVisitor.analyze' function within the 'get_python_file_details.py' script, the inputs 'self' and 'node' hold crucial roles during the execution process. These parameters are passed when invoking this method to traverse an Abstract Syntax Tree (AST) and gather comprehensive details about a Python file.\n\n1. 'self': This refers to the instance of the CodeVisitor class itself, which carries essential attributes such as 'code', 'functions', 'classes', 'file_info', 'constants', and 'current_class'. It serves as a reference to the object's state throughout method calls and maintains information gathered during AST traversal. In `CodeVisitor.analyze`, self acts as a carrier of instance variables required for extracting code details and updating file information dictionary accordingly.\n\n2. 'node': This input represents the root node or starting point in the Abstract Syntax Tree that needs to be analyzed. It is an argument passed when calling `CodeVisitor.analyze`, defining which AST to travel during detail extraction within a Python program structure. When initialized for analyzing operations ('visit'), traversing takes place upon providing the proper AST obtained via `ast.parse()` over input 'code'. The node acts as a stepping stone through various method invocations in `CodeVisitor`, helping explore distinct aspects of the Python file while accumulating details on functions, classes, dependencies, constants, and other metadata in CodeVisitor attributes such as 'functions' or 'classes'. Its main objective is enabling examination throughout all nested subtrees.```"
    },
    {
        "instruction": "Docstring of `CodeVisitor.analyze` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze."
    },
    {
        "instruction": "Calls made in `CodeVisitor.analyze` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "'self.visit', 'list', 'ast.walk', 'isinstance', 'self.functions.items', 'len', 'class_details.items', 'method_name.startswith', 'self.classes.items', 'self.functions.keys', 'self.classes.keys', 'remove_docstring', 'ast.unparse'\n\nPurpose and Significance:\nIn the `CodeVisitor.analyze` method within the given Python script 'get_python_file_details.py', several crucial function calls are executed to extract comprehensive details about a Python file's Abstract Syntax Tree (AST) and compile them into structured documentation. Their purpose and importance are highlighted as follows:\n\n1. `self.visit` - This call invokes various traversing operations of an instance's visitor functions such as `visit_FunctionDef`, `visit_ClassDef`, `visit_Assign`, etc., to analyze the AST node by node recursively. It ensures thorough examination of the code structure and extraction of relevant information.\n\n2. `list` - This built-in Python function is utilized to create multiple lists required during the data accumulation process for storing dependencies, functions details ('function_defs'), class definitions ('class_defs'), file constants, etc., as the program moves along its traversal logic in `CodeVisitor`.\n\n3. `isinstance` - A built-in Python function employed to verify instance types while inspecting different nodes encountered during the AST walk. This aids in identifying specific node categories like functions, classes, assignments, imports, etc., which further helps in extracting relevant details accurately.\n\n4. `self.functions.items`, `len` - These calls are used to access all function names stored in 'self.functions' dictionary and determine its length respectively. This information is essential for populating the final file documentation with details about functions present within the analyzed Python script.\n\n5. `class_details.items()`, `method_name.startswith` - Both involve interaction with classes ('classes') details gathered by 'CodeVisitor'. `class_details.items()` traverses all keys-values pairs of a particular class dictionary while checking if a method name starts with 'class_method_' string prefix, segregating method details within classes effectively.\n\n6. `self.classes.keys()`, `self.functions.keys()` - These calls retrieve all class and function names stored in respective instance variables ('self.classes', 'self.functions') to include them in the final file documentation for comprehensive representation.\n\n7. `remove_docstring` - This function is invoked to sanitize the Python code by eliminating docstrings from the provided source code string before constructing the final documentation output. It ensures clean data for analysis purposes without any extraneous comments or top-level module docstrings.\n\n8. `ast.unparse` - A method of the `ast` module that converts an Abstract Syntax Tree node back into a Python source code string representation. It is used to simplify the sanitized code after removing docstrings and maintain the original structure for further processing like generating a code graph or plantUML visualization."
    },
    {
        "instruction": "Variables in `CodeVisitor.analyze` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef analyze(self, node: ast.AST) -> None:\n    \"\"\"\n        Traverse the AST, list all nodes, and populate 'file_info'\n        Args:\n            node: ast.AST: The node to analyze.\n        \"\"\"\n    self.visit(node)\n    node_walk = list(ast.walk(node))\n    file_dependencies = {alias.name for subnode in node_walk if isinstance(subnode, ast.Import) for alias in subnode.names} | {subnode.module for subnode in node_walk if isinstance(subnode, ast.ImportFrom)}\n    function_defs = [{func_name: {'inputs': details['function_inputs'], 'calls': details['function_calls'], 'call_inputs': details['function_call_inputs'], 'returns': details['function_returns']}} for func_name, details in self.functions.items()]\n    class_defs = [{class_name: {'method_defs': {method_name[len('class_method_'):]: {'inputs': details['method_inputs'], 'calls': details['method_calls'], 'call_inputs': details['method_call_inputs'], 'returns': details['method_returns']} for method_name, details in class_details.items() if method_name.startswith('class_method_')}}} for class_name, class_details in self.classes.items()]\n    self.file_info = {'file_code': self.code, 'file_ast': node, 'file_dependencies': list(file_dependencies), 'file_functions': list(self.functions.keys()), 'file_classes': list(self.classes.keys()), 'file_constants': self.constants, 'file_summary': {'dependencies': list(file_dependencies), 'function_defs': function_defs, 'class_defs': class_defs}, 'file_code_simplified': remove_docstring(ast.unparse(node), self.tree)}\n```",
        "output": "'function_defs', 'node', 'file_dependencies', 'class_defs', 'self', 'node_walk'\n\nPurpose and Significance:\nIn the `CodeVisitor.analyze` method within the 'get_python_file_details' script, several variables play crucial roles in organizing and storing extracted data while traversing Abstract Syntax Tree (AST) of a Python file for detailed documentation. Their responsibilities are elaborated as follows:\n\n1. `function_defs`: This variable collects a dictionary of Python functions encountered during the analysis process within a structured format ({function_name:{inputs, calls} tuples). Its values correspond to functional inputs ('inputs'), called function list ('calls'), and their respective argument lists ('call_inputs') extracted from 'visitor.functions'. It helps represent function details in the final file documentation.\n\n2. `node`: This is a generic input parameter representing any node encountered during AST traversal within `CodeVisitor`. It acts as an anchor point for various methods to operate on specific nodes and perform required actions depending upon their types. In `analyze`, it receives the root node passed initially for traversing purposes.\n\n3. `file_dependencies`: This variable stores a set containing names of imported modules or classes from other files that the analyzed Python script relies upon. It helps identify dependencies of the processed file for contextual understanding within larger project architectures. Dependency detection is initiated in this method as part of creating an extensive file report.\n\n4. `class_defs`: Similar to `function_defs`, `class_defs` represents a dictionary containing Python classes found during AST traversal with nested dictionaries for each class ({class_name:{method_defs}). It stores method details extracted from 'visitor.classes', where keys are prefixed with \"class_method_\" followed by actual method names in the class definitions. This variable helps structure details on class information required in documenting files efficiently.\n\n5. `self`: Inside a Class-Based Object ('CodeVisitor'), this reserved Python keyword references 'visitor instance', and preserves methods/attributes defined within it. In `analyze`, 'self' refers to the current object instantiated with given source code and AST tree as inputs during initialization. It enables accessing other variables like 'file_info', 'functions', or 'classes' within various functions, ultimately influencing their processing decisions based on specific method invocation ('self.').\n\n6. `node_walk`: Not exactly a variable but 'list(ast.walk(node))' yields all descendants in recursive AST traversal across visited nodes with Python evaluation statements as list items for detailed examination by CodeVisitor methods during traversals within 'analyze'. It enables further exploration of subtrees to gather required data while analyzing the Abstract Syntax Tree (AST)."
    },
    {
        "instruction": "Inputs to `get_python_file_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details\n```",
        "output": "'file_path'\n\nPurpose and Significance:\nIn `get_python_file_details`, the primary input parameter named 'file_path' serves as a string representing the pathway to locate a Python file from where extraction and documentation processes occur. Its fundamental purpose is initiating data retrieval procedures on a given source code located at the designated path. By supplying this parameter, users can specify their target script to generate an in-depth report of its structural details such as functions, classes, dependencies, constants, calls between elements, along with generating a graphical representation of its control flow structure using NetworkX library. Within `get_python_file_details`, the file path is employed to read the Python code content through file handling operations like opening ('open'), parsing ('ast.parse') and error logging ('logging'). Afterward, it instantiates an object of CodeVisitor class with the extracted source code and AST tree as inputs, then proceeds to analyze and generate detailed information for the particular script while managing related processes throughout. These intricate tasks help build a comprehensive dictionary comprising essential attributes for that Python file in terms of software documentation.'"
    },
    {
        "instruction": "Docstring of `get_python_file_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details\n```",
        "output": "Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file."
    },
    {
        "instruction": "Calls made in `get_python_file_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details\n```",
        "output": "'open', 'f.read', 'ast.parse', 'logging.warning', 'CodeVisitor', 'visitor.analyze', 'get_code_graph', 'json.dumps(file_summary).replace', 'json.dumps'\n\nPurpose and Significance:\n1. Purpose and Significance of \"open\": Opening a Python file with given path for reading contents as part of extracting file details using the provided path in `get_python_file_details()`. Provides raw text input necessary for processing subsequent actions. Errors from read access result in warning logged using `logging`.\n\n2. Purpose and Significance of \"f.read\": Reading the Python file content as a string to pass it into further analysis steps like parsing with `ast.parse()` method.\n\n3. Purpose and Significance of \"ast.parse\": Transforming the textual representation of Python code into Abstract Syntax Tree (AST) structure essential for traversing nodes, identifying functions, classes, dependencies, etc., during the analysis process in `get_python_file_details()`.\n\n4. Purpose and Significance of \"logging.warning\": Logging warnings related to errors encountered while opening or parsing Python files such as SyntaxError or PermissionError in `get_python_file_details()` function, indicating issues with file accessibility or syntax.\n\n5. Purpose and Significance of Instantiating \"CodeVisitor\": Creating an object of CodeVisitor class initialized with source code string and AST tree extracted from Python file content for traversal and details extraction in `get_python_file_details()`. This visitor navigates through the AST to gather information about functions, classes, constants, calls between them, etc.\n\n6. Purpose and Significance of \"visitor.analyze\": Executing CodeVisitor analysis over AST to generate detailed file summary with all necessary elements including function/class definitions, dependencies, constant declarations, code simplification without docstrings, and prepares ground for creating a graphical representation via `get_code_graph`. This is vital for producing the structured documentation dictionary in `get_python_file_details()`.\n\n7. Purpose and Significance of \"get_code_graph\": Constructing a directed graph representing Python code call graph using NetworkX library based on file summary from CodeVisitor analysis results, resulting in 'entire_code_graph', 'control_flow_structure', and 'plant_uml' for further documentation in `get_python_file_details()`.\n\n8. Purpose and Significance of \"json.dumps\": Serializing Python object as a JSON string with replaced double quotes ('\"') to single quotes (') in `get_python_file_details()` function, making it more suitable for further processing or displaying as textual representation within the documentation dictionary. This step ensures compatibility across different platforms and formats while storing file summary data.\n\n9. Purpose and Significance of \"json.dumps(file_summary)\": Serializing Python object 'file_summary' (dict) into JSON format in `get_python_file_details()`. Replacing double quotes ('\"') with empty string ensures JSON compatibility, enhancing the output presentation within documentation dictionary 'file_info'. This serialized form facilitates transferability of data between programming languages and platforms."
    },
    {
        "instruction": "Variables in `get_python_file_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details\n```",
        "output": "'file_path', 'tree', 'file_summary', 'file_details', 'code', 'visitor', 'file_ast'\n\nPurpose and Significance:\n1. file_path (str): Represents the input argument specifying the Python file path whose details are to be extracted by the function get_python_file_details(). It initiates the process of analyzing a particular source code file and serves as an entry point for gathering relevant information about it.\n\n2. tree (AST representation): This variable stores the Abstract Syntax Tree (AST) of the Python code read from the given file path after parsing with `ast.parse`. It enables further analysis to identify structures, relationships, calls, etc., in a machine-readable format that facilitates effective data extraction during execution.\n\n3. file_summary: Refers to an embedded dictionary within 'file_info' under the returned file_details dict from get_python_file_details(). It contains a summary of extracted information about dependencies, functions, classes, constants, etc., required for constructing a code graph representation later in get_code_graph(). This summary is essential for generating a visualization of control flow structure and plantuml output.\n\n4. file_details (Dict[str, Union[Dict, str]]): The primary output of `get_python_file_details()`. It stores comprehensive extracted details from the analyzed Python file as a dictionary comprising file_info containing file code details such as dependencies, functions dictionary, classes dictionary, constants list, etc.\n\n5. code (str): A temporary variable initialized during get_python_file_details() function execution with the read content of the input file path using 'open'. It serves as an argument for instantiating CodeVisitor class and parsing into tree using ast.parse(). This string is later passed to remove_docstring() for sanitizing code before analysis.\n\n6. visitor (CodeVisitor instance): An object of the custom NodeVisitor class that traverses the AST, extracts details about functions and classes while maintaining contextual information like current_class attribute. It populates file_info dictionary with extracted data during analyze() method execution.\n\n7. file_ast (AST): This variable represents the parsed Abstract Syntax Tree ('tree') used by CodeVisitor instance to traverse and extract details about Python code elements. It is stored in 'file_info' within returned file_details dict for future reference but not utilized further after analyze() method execution. However, it plays a crucial role in generating plantuml using get_code_graph().'''"
    },
    {
        "instruction": "Returns from `get_python_file_details` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_python_file_details(file_path: str) -> Dict[str, Union[Dict, str]]:\n    \"\"\"\n    Extract details from a Python file.\n    Args:\n        file_path: str: The path to the Python file.\n    Returns:\n        Dict[str, Union[Dict, str]]: The details extracted from the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:\n            code = f.read()\n            tree = ast.parse(code)\n    except (PermissionError, SyntaxError, IOError) as e:\n        logging.warning(f'{e} error in file: {file_path}')\n        return None\n    visitor = CodeVisitor(code, tree)\n    visitor.analyze(tree)\n    file_details = {'file_info': visitor.file_info, 'functions': visitor.functions, 'classes': visitor.classes}\n    file_summary = file_details['file_info']['file_summary']\n    file_ast = file_details['file_info']['file_ast']\n    entire_code_graph, control_flow_structure, plant_uml = get_code_graph(file_summary, file_ast)\n    file_details['file_info']['entire_code_graph'] = entire_code_graph\n    file_details['file_info']['control_flow_structure'] = control_flow_structure\n    file_details['file_info']['plant_uml'] = plant_uml\n    file_details['file_info']['file_summary'] = json.dumps(file_summary).replace('\"', '')\n    del file_details['file_info']['file_ast']\n    return file_details\n```",
        "output": "'file_details', 'None'\n\nPurpose and Significance:\nIn `get_python_file_details`, two potential outputs are generated after comprehensively examining a given Python file: `file_details` containing extracted information about the analyzed script and `None` indicating an error occurred during processing. The primary function aims to retrieve structured documentation for a specified Python file path by leveraging various auxiliary methods and classes within its scope.\n\n1. 'file_details': This significant return represents a dictionary comprising diverse aspects related to the parsed Python file, extracted using different stages of code analysis. It incorporates vital data gathered from traversing the Abstract Syntax Tree (AST) such as function definitions, class details, dependencies, constants, call relationships between functions/methods, and even constructs a graphical representation of the code flow using NetworkX library. This dictionary serves as the core output highlighting crucial elements about the file's inner workings in a structured manner.\n\n2. 'None': Acting as an alternative return value when errors are encountered during script execution. Such errors can stem from access permission issues while reading the Python file ('PermissionError'), erroneous syntax within the code ('SyntaxError') or other Input/Output problems ('IOError'). Logging a warning message through `logging` module signifies the occurrence of these mistakes but does not stall program functionality completely; rather it reports error situations enabling further actions in separate processing lines of codes if required. Here 'None' symbolizes error condition within this particular context as there are no recoverable results extracted for file_details when facing aforementioned challenges."
    },
    {
        "instruction": "Inputs to `get_all_calls` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict\n```",
        "output": "'node', 'calls'\n\nPurpose and Significance:\nIn the context given for 'get_all_calls' function within the 'get_python_file_details.py' script, its primary purpose lies in identifying all function calls occurring across an Abstract Syntax Tree (AST) subtree initiated from a provided root node. The function serves two critical roles to accomplish this task: recursively exploring nodes in the tree and forming a dictionary comprising the found function calls along with their associated arguments list. The two key inputs in 'get_all_calls' function are listed as follows:\n\n1. 'node': This argument refers to the root node acting as a starting point for commencing search through the AST subtree. It serves as a reference point from where the traversal begins while discovering function calls within the Python codebase. The function operates on this node and its descendants, ensuring thorough examination of the tree structure.\n\n2. 'calls': This input is optional but holds initial importance if not supplied by default, as it represents an accumulator for the identified function calls discovered during traversal. When none is passed initially, 'calls' assumes an empty list of tuples containing strings representing functions and their corresponding arguments lists. As the function progresses through the AST, it appends each encountered call into this accumulator until it constructs a comprehensive dictionary at the end.\n\nThe combination of these inputs allows 'get_all_calls' to effectively locate all function calls within the subtree rooted at the given node while maintaining a record of their respective arguments. This information is crucial for understanding the code flow and interdependencies between functions in Python programs, which can be further utilized by other parts of the script for additional analysis or documentation purposes."
    },
    {
        "instruction": "Docstring of `get_all_calls` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict\n```",
        "output": "Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments."
    },
    {
        "instruction": "Calls made in `get_all_calls` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict\n```",
        "output": "'isinstance', 'calls.append', 'ast.unparse', 'get_all_calls', 'ast.iter_child_nodes', 'calls_dict[func].extend'\n\nPurpose and Significance:\nIn get_all_calls function within the given Python script for analyzing Python source code details, several crucial calls are executed to achieve its primary goal - finding all function calls recursively in a subtree rooted at a specific node. These calls play significant roles in identifying and collecting required information during traversal through Abstract Syntax Tree (AST).\n\n1. `isinstance`: This built-in Python function checks whether an object is an instance of a given class, interface, or abstract base class. In get_all_calls, it verifies if the current node being processed is an instance of 'Call', which indicates a function call encountered during traversal. If true, further processing continues to append this call into the accumulator 'calls'.\n\n2. `calls.append`: When a function call is identified ('Call' node), its string representation along with arguments list are appended into the calls dictionary using `calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args])`. This step stores each function call encountered during traversal to build a comprehensive record of all function invocations within the subtree rooted at the initial node passed as an argument.\n\n3. `ast.unparse`: It converts an Abstract Syntax Tree node into its corresponding Python source code representation string. In get_all_calls, ast.unparse() is used twice - once for the function name during adding function call entries into 'calls' dictionary and secondly when generating string representations of arguments while forming each entry (`ast.unparse(arg)` within a nested list comprehension).\n\n4. `get_all_calls` itself recursively called as a helper function within get_all_calls - primarily used for handling child nodes underneath the initial node in search for additional function calls or further exploring recursively through AST elements until exhaustive inspection. The passed calls parameter in outermost function initially represents accumulated entries from all call occurrences until current iteration depth and receives updates due to recursive execution, carrying all call discoveries discovered throughout tree exploration till this node depth level.\n\n5. `ast.iter_child_nodes`: This method iterates over child nodes of the given AST node in a depth-first manner. In CodeVisitor class's visit_Assign method, it is utilized to find constant variable assignments within module scope. It traverses the subtree associated with an Assign node to locate constants defined at that level.\n\n6. `calls_dict[func].extend`: When dealing with classes in get_all_calls function, this list append operation adds attributes identified as self.attribute into respective class attribute lists ('class_attributes') within the 'classes' dictionary if they belong to methods starting with \"class_method_\". It expands these lists for future references or analysis purposes."
    },
    {
        "instruction": "Variables in `get_all_calls` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict\n```",
        "output": "'calls_dict', 'calls', 'node'\n\nPurpose and Significance:\nIn the `get_all_calls` function within the given Python script for extracting file details from a Python source code, the mentioned variables hold crucial roles during recursive traversal to find all function calls within a given AstNode 'node'.\n\n1) `calls_dict`: A dict used as an accumulator while building up lists of all found function calls during `get_all_calls()`. The initialized `None`, yet receives updates after iterating through the AstNode tree. It stores each unique function call string as a key with its corresponding arguments list as values. This dictionary helps in representing relationships between functions and their respective input parameters effectively.\n\n2) `calls`: Initially set to `None`, but later becomes an argument passed into the recursive function call within `get_all_calls()`. It serves as an intermediate storage for accumulating function calls found during traversal before being transformed into a dictionary format ('calls_dict') at the end of the function.\n\n3) `node`: This parameter stands for the root AstNode where recursion starts while discovering function calls within its subtree. Its significance lies in serving as the entry point to initiate the search process for identifying all function invocations throughout the tree structure. It is passed into `get_all_calls()` and gets updated with child nodes during traversal through `ast.iter_child_nodes(node)`. It ensures exploring nested subtrees, thus encompassing complex scenarios involving classes or methods inside functions/other AstNodes within a node's context."
    },
    {
        "instruction": "Returns from `get_all_calls` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef get_all_calls(node: ast.AST, calls=None) -> Dict[str, List[str]]:\n    \"\"\"\n    Recursively find all function calls in the subtree rooted at `node`,\n    including those in class attributes, list comprehensions, and lambda functions.\n    Args:\n        node (ast.AST): The root node to start the search from.\n        calls (List[Tuple[str, List[str]]], optional): Accumulator for function calls found.\n    Returns:\n        Dict[str, List[str]]: dictionary mapping function calls (as strings) to lists of their arguments.\n    \"\"\"\n    if calls is None:\n        calls = []\n    if isinstance(node, ast.Call):\n        calls.append((ast.unparse(node.func), [ast.unparse(arg) for arg in node.args]))\n    elif isinstance(node, ast.ClassDef):\n        for body_item in node.body:\n            if isinstance(body_item, ast.Assign) and isinstance(body_item.targets[0], ast.Name):\n                get_all_calls(body_item.value, calls)\n    for child in ast.iter_child_nodes(node):\n        get_all_calls(child, calls)\n    calls_dict = {}\n    for func, args in calls:\n        if func not in calls_dict:\n            calls_dict[func] = []\n        calls_dict[func].extend(args)\n    return calls_dict\n```",
        "output": "'calls_dict'\n\nPurpose and Significance:\nThe 'calls_dict' return value within the 'get_all_calls' function plays a crucial role in mapping discovered function calls as keys to their respective argument lists in a Python source code analysis process. This dictionary formation occurs during recursive traversal of Abstract Syntax Tree (AST) nodes initiated by `get_all_calls()`, following certain patterns based on conditions associated with Node Instances detection through Ast operations, ensuring discovery not just of raw calls within 'function def'/'class def' declarations but furthermore encounters including lambda expressions embedded under attributes such as list comprehensions. In the Python codebase under examination, it helps create a comprehensive record of functions and their corresponding invocations to enable a thorough understanding of code interactions and relationships. The 'calls_dict' object ultimately provides insights into function dependencies or call graphs which are vital for further analysis like control flow structure extraction or static code visualization in the form of graph representations. Its contents include strings representing function names as keys alongside their corresponding lists of arguments, serving as a foundation for advanced code examination within overall script functioning mechanisms and method relationships interpretation."
    },
    {
        "instruction": "Inputs to `remove_docstring` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)\n```",
        "output": "'code', 'tree'\n\nPurpose and Significance:\nIn the `remove_docstring` function within the given Python script 'get_python_file_details.py', two primary inputs are utilized - 'code' and 'tree'. These parameters hold crucial information required for accomplishing the core task of removing docstrings from a provided Python source code snippet.\n\n1) 'code': This input represents the raw textual content of a Python file in string format. It serves as an entry point into processing where extraction begins as the initial Python script. Throughout its operations, the function retains its integrity till late stages while serving as an input argument to 'ast.parse' that translates Python syntax into an Abstract Syntax Tree (AST) represented by 'tree'.\n\n2) 'tree': After parsing Python code with `ast.parse` into AST form ('tree'), it becomes a more structured representation of the original script that facilitates efficient navigation through Python language constructs for better manipulation purposes like identifying and eliminating docstrings effectively using subsequent function calls like `remove_docstring`. The AST traversal helps to understand Python semantics better by providing node-wise data, allowing specific changes on identified segments of code without affecting other sections."
    },
    {
        "instruction": "Docstring of `remove_docstring` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)\n```",
        "output": "Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed."
    },
    {
        "instruction": "Calls made in `remove_docstring` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)\n```",
        "output": "'isinstance', 'tree.body.pop', 'ast.walk', 'node.body.pop', 'ast.unparse'\n\nPurpose and Significance:\n1. Purpose and Significance of Calls in `remove_docstring` Function:\n   a. `isinstance`: Determines data types during execution for decision making in removing docstrings efficiently from specific nodes within the Python code string represented by `tree`. This helps filter unnecessary sections from the given input source code without disrupting other valid elements like functions or class definitions.\n\n   b. `tree.body.pop()`: Removes top-level module docstrings from the beginning of a parsed Abstract Syntax Tree (AST). If there is an initial comment or docstring found as first node in `tree`, it is discarded for providing cleaned Python code. This call simplifies code representation prior to further processing.\n\n   c. `ast.walk(tree)`: Traverses the AST tree recursively, allowing examination of each node within the parsed source code. It helps identify docstrings in functions and classes while iterating through the entire tree structure for accurate string manipulation in the following steps.\n\n   d. `node.body.pop()`: If a function or class definition has a docstring as its first statement, this call eliminates it from its respective `node.body`, reducing overall string size in the AST before formatting and returning a simplified version without commentary content. These manipulations provide readable source code details necessary for analysis downstream within `get_python_file_details`.\n\n   e. `ast.unparse(tree)`: Converts the modified Abstract Syntax Tree back into human-readable Python code string format after removing docstrings from various nodes. This function generates sanitized source code output which is returned as a result of `remove_docstring`. It helps in providing clean code for further processing within the pipeline of `get_python_file_details` function."
    },
    {
        "instruction": "Variables in `remove_docstring` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)\n```",
        "output": "'tree', 'first_body_node', 'code'\n\nPurpose and Significance:\n1. tree: In the `remove_docstring` function within the given Python script 'get_python_file_details.py', `tree` represents an Abstract Syntax Tree (AST) generated from the provided Python source code string as input argument. This AST serves as a data structure representing the parse tree of the code which helps in navigating through different nodes and manipulating them for specific purposes like removing docstrings in this case.\n\n2. first_body_node: Inside `remove_docstring`, `first_body_node` is a temporary variable utilized during the recursive traversal process to identify the initial node after locating the top-level module docstring (if any). It points to the immediate child node following the docstring when found within function, class or async function definitions. This node becomes significant in removing the leading docstrings by popping it from `tree` later using `node.body.pop(0)`.\n\n3. code: 'code' denotes the original Python source string provided as input to `remove_docstring` and other related functions such as `CodeVisitor.__init__`. It acts as a reference point for maintaining context throughout various operations like removing docstrings or extracting details about functions/classes during AST traversal. This variable stores the raw input before any transformations occur."
    },
    {
        "instruction": "Returns from `remove_docstring` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef remove_docstring(code: str, tree: ast.AST) -> str:\n    \"\"\"\n    Remove docstrings from the provided Python code.\n    This includes top-level module docstrings and docstrings in\n    functions, classes, and async functions.\n    Args:\n        code (str): The source code from which to remove docstrings.\n    Returns:\n        str: The source code with docstrings removed.\n    \"\"\"\n    if tree.body and isinstance(tree.body[0], ast.Expr) and isinstance(tree.body[0].value, ast.Str):\n        tree.body.pop(0)\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.FunctionDef, ast.ClassDef, ast.AsyncFunctionDef)) and node.body:\n            first_body_node = node.body[0]\n            if isinstance(first_body_node, ast.Expr) and isinstance(first_body_node.value, ast.Str):\n                node.body.pop(0)\n    return ast.unparse(tree)\n```",
        "output": "'ast.unparse(tree)'\n\nPurpose and Significance:\nIn 'remove_docstring' function, the primary purpose is eliminating docstrings found in a provided Python source code segment within its Abstract Syntax Tree (AST). It ensures removal of top-level module docstrings as well as docstrings associated with functions, classes, and async functions. The return value from this function is represented by `ast.unparse(tree)`, which represents the sanitized Python code string after stripping off all docstrings. This cleaned code string serves further processing in other parts of the program to extract necessary details about functions, classes, dependencies, calls between them, and constructing a code graph representation using NetworkX library. By excluding comments or documentation strings, it facilitates a more concise understanding of core functionalities present within the source code. The `ast.unparse(tree)` function reconstructs the AST as a Python expression string, allowing further analysis while disregarding any original docstrings embedded within it."
    },
    {
        "instruction": "Inputs to `CodeVisitor.visit_Assign` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the context of Python script 'get_python_file_details.py,' particular emphasis lies upon method 'CodeVisitor.visit_Assign' residing within Class 'CodeVisitor'. It carries significant functional value serving to apprehend constant variable assignments occurring within module scope during Abstract Syntax Tree traversal. These two inputs - `self` and `node`, act as vital parameters when invoking this method.\n\n1. 'self':\n   - Refers to the instance of Class 'CodeVisitor' itself, which holds all relevant attributes such as 'code,' functions,' classes,' file_info,' constants,' tree,' current_class,' etc., enabling access to these variables during method execution. This self-reference ensures access to preserved details acquired during preceding visits to nodes throughout AST traversal and further enables storing updated data based on the instant situation encountered while iterating the AstTree elements.\n\n2. 'node':\n   - Symbolizes the current node being processed within the Abstract Syntax Tree. This parameter primarily represents an instance of 'ast.Assign' type node denoting a variable assignment operation in Python code. The method inspects this node to recognize constant assignments in module context. While executing 'visit_Assign,' it enables the detection and management of global constants declared with assignment statements, updating `self.constants` list for future usage in documentation. This crucial input facilitates capturing constant variable declarations within the script's scope during AST traversal."
    },
    {
        "instruction": "Docstring of `CodeVisitor.visit_Assign` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)\n```",
        "output": "Get self.constants\n        Args:\n            node: ast.Assign: The node to visit."
    },
    {
        "instruction": "Calls made in `CodeVisitor.visit_Assign` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)\n```",
        "output": "'isinstance', 'ast.unparse', 'self.constants.append', 'self.generic_visit'\n\nPurpose and Significance:\nIn the context of 'CodeVisitor.visit_Assign' function within the `get_python_file_details.py`, three significant calls are executed to perform specific tasks related to capturing constant variable assignments within module scope. These calls contribute towards extracting relevant information from Python source code during Abstract Syntax Tree traversal and their detailed explanation is given as follows:\n\n1. `isinstance(subnode, ast.AnnAssign)` - This `isinstance()` call is employed to examine each node walked within `visit_Assign` method while iterating through the AstTree. It checks if a subnode belongs to the 'ast.AnnAssign' class type which represents an assignment operation involving variable annotations in Python code. If so, it ensures capturing those nodes for further processing related to constant variables declaration.\n\n2. `ast.unparse(subnode.value)` - The `ast.unparse()` function is utilized to convert abstract syntax tree nodes back into their corresponding Python source code representation strings. In `visit_Assign`, it converts the value of an assignment node (either a constant or expression) into a human-readable format for storing in 'self.constants'. This helps maintain readability while analyzing the Python file's details.\n\n3. `self.constants.append(constant_assignment)` - After identifying relevant nodes through `isinstance()` and converting them using `ast.unparse()`, this call appends each constant assignment into 'self.constants'. This list keeps track of all constants found during the traversal within the module scope, which are variable declarations without any associated expressions or functions assigned to them in Python code. It collects variables with constant values stored as strings throughout the file analysis process.\n\n4. `self.generic_visit(node)` - Lastly, `self.generic_visit()` is invoked on the current node after processing specific cases related to constants assignment. This method acts as a fallback mechanism when no explicit visitor function exists for a particular node type in CodeVisitor class. It recursively traverses child nodes of the visited node and calls corresponding visit methods for each encountered subnode until reaching leaf nodes or encountering an appropriate node type with defined visit functions like `visit_FunctionDef`, `visit_ClassDef` etc., allowing the code to move through various nodes seamlessly within Abstract Syntax Tree. It also helps in maintaining parent-child relationship while analyzing Python code structure and storing essential information related to different nodes encountered during traversal."
    },
    {
        "instruction": "Variables in `CodeVisitor.visit_Assign` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_Assign(self, node: ast.Assign):\n    \"\"\"\n        Get self.constants\n        Args:\n            node: ast.Assign: The node to visit.\n        \"\"\"\n    if isinstance(node.parent, ast.Module):\n        for target in node.targets:\n            if isinstance(target, ast.Name):\n                value = node.value\n                if isinstance(value, ast.Constant) and isinstance(value.value, str):\n                    value_repr = f\"'{value.value}'\"\n                else:\n                    value_repr = ast.unparse(value)\n                constant_assignment = f'{target.id}={value_repr}'\n                self.constants.append(constant_assignment)\n    self.generic_visit(node)\n```",
        "output": "'value_repr', 'constant_assignment', 'node', 'self', 'value'\n\nPurpose and Significance:\nIn the `CodeVisitor` class within the `visit_Assign` method, four key variables are utilized to collect information regarding constant variable assignments present within the module scope of a Python source code. Their roles are explained as follows:\n\n1. `value_repr`: This variable holds a string representation of constants after converting them into quotes when encountered during traversal in the Abstract Syntax Tree (AST). It is mainly used to maintain consistency while handling constant values that may be numeric or strings but not necessarily enclosed within quotes originally. The transformation ensures proper data format in the extracted file details dictionary.\n\n2. `constant_assignment`: An internally constructed string listing variable assignments related to constants. During visits at Assign nodes in AST where constant assignment exists (assigning value to variables), these constant names with respective representation are stored for subsequent handling. It facilitates accumulation of a list named 'self.constants', storing the record of Python module level variable definitions and assignments throughout traversal.\n\n3. `node`: It is a generic reference to the current node being visited in `visit_Assign`. This variable helps navigate through different nodes during AST traversal while keeping track of the context within the method execution.\n\n4. `self`: Represents the instance of `CodeVisitor`, providing access to its attributes and methods for manipulation purposes. It allows interaction with other variables like 'code', 'functions', 'classes', 'file_info', etc., required during traversal operations.\n\n5. `value`: This variable represents the value assigned to a constant in an assignment operation within Python code. It is primarily used alongside `value_repr` for transforming constants into a string representation while accumulating assignments related to module-level variables in 'self.constants'."
    },
    {
        "instruction": "Inputs to `CodeVisitor.__init__` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef __init__(self, code: str, tree: ast.AST) -> None:\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None\n    self.constants: List[str] = []\n    self.tree = tree\n```",
        "output": "'self', 'code', 'tree'\n\nPurpose and Significance:\nIn the `CodeVisitor.__init__` method within the 'get_python_file_details.py' script, three crucial inputs are utilized during initialization of a new instance of the CodeVisitor class. These inputs significantly contribute to setting up the object with essential attributes required for extracting and processing Python code information during AST traversal:\n\n1. 'self': It denotes the instance of the currently creating CodeVisitor object. Self acts as a reference for various method invocations inside this constructor where class member variables get initialized along with linkages to other vital parameters passed at instantiation time.\n\n2. 'code': This input represents the source code string provided as an argument when instantiating the CodeVisitor instance. It holds the Python script content that will be analyzed and processed further in subsequent stages of execution. The code serves as the fundamental foundation for gathering insights into its functions, classes, dependencies, calls between functions/methods, and generating a code graph representation.\n\n3. 'tree': AST (Abstract Syntax Tree) representation of the source code provided through the argument is stored in this input parameter. Abstract Syntax Tree offers a structured means to navigate Python programs efficiently, enabling the extraction of semantic details while traversing its nodes during object processing within the class methods like `visit_FunctionDef`, `visit_ClassDef`, `generic_visit` and more. By accessing `tree`, the script is able to work upon code abstractions in order to understand Python syntax elements, their relationships, and generate comprehensive documentation about the file."
    },
    {
        "instruction": "Docstring of `CodeVisitor.__init__` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef __init__(self, code: str, tree: ast.AST) -> None:\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None\n    self.constants: List[str] = []\n    self.tree = tree\n```",
        "output": "Initialize a new instance of the class.\n        Args:\n            code: str: The source code."
    },
    {
        "instruction": "Variables in `CodeVisitor.__init__` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef __init__(self, code: str, tree: ast.AST) -> None:\n    \"\"\"\n        Initialize a new instance of the class.\n        Args:\n            code: str: The source code.\n        \"\"\"\n    self.code: str = code\n    self.functions: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.classes: Dict[str, Dict[str, Union[str, List[str]]]] = {}\n    self.file_info: Dict[str, Union[str, List[str]]] = {}\n    self.current_class: str = None\n    self.constants: List[str] = []\n    self.tree = tree\n```",
        "output": "'tree', 'self', 'code'\n\nPurpose and Significance:\nIn the `CodeVisitor.__init__` method within the `CodeVisitor` class, three significant variables are utilized to initialize a new instance - `'self', 'tree', and 'code'. These variables play important roles in establishing connections between instances of this class with source code information for analysis. Here is how they contribute to the functioning:\n\n1. 'self': This reserved Python keyword refers to the instance being created within the current method scope, enabling access to class attributes and methods across different parts of the class implementation. It holds the reference to the newly initialized object which can be further manipulated during object lifetime. In `CodeVisitor.__init__, self is employed alongside other variables to set up various properties essential for processing the code details extraction.\n\n2. 'tree': This parameter specifically receives an Abstract Syntax Tree (AST) representation of a Python file as input when instantiating a new instance of CodeVisitor. The AST is a data structure representing the syntactic structure of source code necessary for traversing and extracting information about functions, classes, dependencies, etc. By providing 'tree' to `CodeVisitor`, it enables efficient navigation through Python code elements and helps identify nodes related to different aspects like functions or classes in an organized manner.\n\n3. 'code': The source code string containing Python content that is analyzed and converted into its corresponding AST for deeper processing inside `CodeVisitor`. It represents the actual program lines as input fed when instantiating this class instance and stored by the `CodeVisitor` object for traversing and detail extraction purposes throughout various methods such as `visit_FunctionDef`, `visit_ClassDef`, etc. While working with `tree`, `code` allows linkage to its original context during analysis."
    },
    {
        "instruction": "Inputs to `CodeVisitor.visit_FunctionDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the context of Python script 'get_python_file_details.py' and specifically focusing on the method `CodeVisitor.visit_FunctionDef`, the parameters passed hold substantial relevance to fulfill its designated role. These two inputs primarily help analyze Python files, gather data about functions in code and subsequently add those details to internal data structures of `CodeVisitor` instances during Abstract Syntax Tree traversal.\n\n1. 'self': This parameter represents an instance of `CodeVisitor`, carrying important variables like the source code ('code'), dictionaries storing information about functions ('functions') and classes ('classes'), as well as details about a particular file's structure ('file_info'). When `visit_FunctionDef` is invoked on an object 'self', it gains access to all stored attributes needed for function extraction within the class context. This self-reference ensures proper utilization of existing data during AST traversal.\n\n2. 'node': This argument represents a specific Python Function Definition node ('ast.FunctionDef') in Abstract Syntax Tree (AST) that `CodeVisitor` is currently examining. It serves as the entry point for extracting details about functions within the codebase. By passing this node to `visit_FunctionDef`, the method can analyze its attributes, identify function names, docstrings, inputs, returns, decorators, etc., and add them to corresponding sections in 'functions' dictionary. This parameter helps maintain a connection between `CodeVisitor` operations and the actual node being processed during traversal."
    },
    {
        "instruction": "Docstring of `CodeVisitor.visit_FunctionDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)\n```",
        "output": "Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit."
    },
    {
        "instruction": "Calls made in `CodeVisitor.visit_FunctionDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)\n```",
        "output": "'self.extract_details', 'self.generic_visit'\n\nPurpose and Significance:\n1) Purpose of Calls in CodeVisitor.visit_FunctionDef: Within the `CodeVisitor` class's `visit_FunctionDef` method, two significant calls are made to execute essential functionalities - `self.extract_details()` and propagate processing through the `generic_visit()`. These functions help gather detailed information about Python functions within a file during Abstract Syntax Tree traversal.\n    a) 'self.extract_details(): This method extracts necessary details related to each function encountered in the codebase by walking through the AST nodes and storing them in instances as per-function dictionaries under `self.functions`. It returns a dictionary containing various attributes such as function name, inputs, call graph elements, returns values, docstrings, annotations, etc., depending upon 'node_type' (\"function\" or \"method\") with reference to its defining class. These extracted details aid in structuring complete information about each Python function found within the file underanalysis.\n    b) 'self.generic_visit()': This call serves as a fallback mechanism for any unhandled node types during traversal by ensuring the child nodes' visitation. When a particular subclass visiting method isn't defined in the `CodeVisitor` class explicitly, this propagates control flow downward while continuing tree exploration to other children or associated attributes within a given node through `self.visit(node)`. In summary, `generic_visit()` guarantees traversing unidentified nodes within an abstract syntax tree before moving ahead. These calls enable thorough data gathering about the Python file under study, allowing the CodeVisitor class to comprehensively analyze and document its contents."
    },
    {
        "instruction": "Variables in `CodeVisitor.visit_FunctionDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_FunctionDef(self, node: ast.FunctionDef) -> None:\n    \"\"\"\n        Extract details about a function.\n        Args:\n            node: ast.FunctionDef: The node to visit.\n        \"\"\"\n    details = self.extract_details(node, 'method' if self.current_class else 'function')\n    if self.current_class:\n        self.classes[self.current_class][f'class_method_{node.name}'] = details\n    else:\n        self.functions[node.name] = details\n    self.generic_visit(node)\n```",
        "output": "'self', 'details', 'node'\n\nPurpose and Significance:\nIn the `CodeVisitor` class's method `visit_FunctionDef`, three crucial variables play significant roles during the extraction of function details within Python source code analysis. These variables are 'self', 'details', and 'node'.\n\n1. 'self': This keyword refers to the instance of the `CodeVisitor` object itself when used inside a method scope. It allows accessing other attributes and methods defined in the class context. In `visit_FunctionDef`, it helps utilize the extracted details from various steps within the traversal process and update the corresponding instances such as 'functions', 'classes', and 'file_info'. By leveraging self, we can invoke instance properties or call instance methods relevant to capturing file details accurately.\n\n2. 'details': This variable represents a dictionary containing extracted information about the current function being processed during traversal. It stores Union[str, List[str]] type data related to the function node attributes such as name, code representation, docstring content, input arguments, default values, return statements, calls made by the function, call inputs, and annotations. The `extract_details` method populates 'details' with these details for further processing in other methods like updating instances or forming parts of `file_info`.\n\n3. 'node': The parameter 'node', signifies the Python abstract syntax tree (AST) node object which represents the FunctionDef AST type within Python source code that this visitation method is currently analyzing. It serves as an input argument in `visit_FunctionDef` to identify and process function definitions while traversing the Abstract Syntax Tree, enabling extraction of relevant details about each encountered function. This node acts as a reference point for gathering information about specific functions within the codebase."
    },
    {
        "instruction": "Inputs to `CodeVisitor.visit_ClassDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the context of Python script 'get_python_file_details.py' and specifically within the class 'CodeVisitor', the method `visit_ClassDef` plays a crucial role in extracting essential details about classes during Abstract Syntax Tree (AST) traversal. It falls under the category of instance methods in this class, inheriting from ast.NodeVisitor. The two primary inputs for this function are denoted as ['self' and 'node'].\n\n1. 'self': This input refers to the current instance of the CodeVisitor object itself. It carries all the relevant attributes such as 'code', 'functions', 'classes', 'file_info', etc., gathered from prior stages or steps executed earlier during processing. With these properties readily available, the `CodeVisitor` instance can manipulate information, identify class-specific features within AST traversal more accurately and maintain its state throughout the code analysis process.\n\n2. 'node': This input represents the current node being visited in the Abstract Syntax Tree (AST). It is an ast.ClassDef object that signifies a Python class definition encountered during tree traversal. As the `visit_ClassDef` method is responsible for extracting class details, the provided node becomes crucial for extracting data relevant to the particular class being inspected and populating appropriate dictionary elements within the CodeVisitor instance ('classes' attribute). The input 'node' provides vital context that directs this method to handle classes distinctly from other AST components such as functions or modules.\n\nBoth 'self' and 'node' collectively contribute towards a comprehensive understanding of Python code structure by enabling the `CodeVisitor` class to identify classes, their attributes, methods, inheritance details, etc., which are essential for generating detailed documentation about the analyzed file. By combining insights provided from different sections or aspects (here in ClassDef AST traversal) into single informative results (representing Class and FileInfo dict), CodeVisitor comprehensively catalogues crucial characteristics of the code's hierarchical entities \u2013 functions, classes, dependencies, constants, call patterns between functions/methods, etc., offering an extensive analysis report on a Python file."
    },
    {
        "instruction": "Docstring of `CodeVisitor.visit_ClassDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None\n```",
        "output": "Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit."
    },
    {
        "instruction": "Calls made in `CodeVisitor.visit_ClassDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None\n```",
        "output": "'self.extract_details', 'self.generic_visit'\n\nPurpose and Significance:\nIn the `CodeVisitor` class within the given Python script 'get_python_file_details.py', during the execution of its methods `visit_FunctionDef` and `visit_ClassDef`, two significant calls are made - `self.extract_details` and `self.generic_visit`. These calls play crucial roles in extracting essential details about functions and classes present in the Abstract Syntax Tree (AST) respectively while traversing the code structure.\n\n1. `self.extract_details` Call within `visit_ClassDef()`:\n   - Purpose: Extracts comprehensive information regarding classes discovered during AST traversal and adds them to instances ('classes' dictionary).\n   - Significance: After identifying a class node, this method is invoked to gather detailed insights about the class definition. It collects attributes like name, methods within the class, inheritance details, static methods, etc., updating the 'classes' attribute of `CodeVisitor` instance with the extracted data. The retrieved information includes class attributes and methods names along with their respective inputs, calls, returns, dependencies, etc.\n\n2. `self.generic_visit` Call within `visit_ClassDef()`:\n   - Purpose: Continues traversing the AST after visiting a class node while maintaining parent-child relationships between nodes.\n   - Significance: This call ensures that processing proceeds to subsequent nodes in the Abstract Syntax Tree even if no specific method exists for the current node type (class definition). It handles various node types and iterates through child nodes by utilizing `ast.iter_child_nodes()`, allowing a systematic traversal of the code structure while keeping track of parent-subnode associations ('node.parent = node'). The primary role is to prepare further processing for subsequent functions in the `CodeVisitor` class methods pipeline."
    },
    {
        "instruction": "Variables in `CodeVisitor.visit_ClassDef` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef visit_ClassDef(self, node: ast.ClassDef) -> None:\n    \"\"\"\n        Extract details about a class.\n        Args:\n            node: ast.ClassDef: The node to visit.\n        \"\"\"\n    self.classes[node.name] = self.extract_details(node, 'class')\n    self.current_class = node.name\n    self.generic_visit(node)\n    self.current_class = None\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the `CodeVisitor` class within the given Python script 'get_python_file_details.py', the variables `'self' and 'node' hold crucial roles during the execution of the method `visit_ClassDef`. These parameters are passed as arguments when invoking this function.\n\n1. `self` refers to the instance of the `CodeVisitor` object itself. It maintains access to all attributes and methods defined within the class, enabling interaction with stored data such as `functions`, `classes`, `file_info`, etc., during the traversal process in AST (Abstract Syntax Tree). In essence, `self` represents the current object context.\n\n2. On the other hand, `node` stands for the particular node being visited during traversal - in this case, a class definition encountered within the Python source code's Abstract Syntax Tree. This node contains relevant information required to extract details about classes and their associated methods. The method processes the provided 'node', analyzing its properties, adding or updating necessary instance variables with gathered data related to classes and their constituents like methods while navigating through the tree structure of the source code. By referencing `node`, `visit_ClassDef` can access crucial information such as class names, attributes, base classes, method definitions, etc., thus playing a central role in organizing and storing class-related details within the `CodeVisitor` instance."
    },
    {
        "instruction": "Inputs to `CodeVisitor.generic_visit` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the context given for Python script 'get_python_file_details.py,' one pivotal method named `CodeVisitor.generic_visit` falls under the `CodeVisitor` class acting as a subclass derived from `ast.NodeVisitor`. It has an indispensable role in traversing the Abstract Syntax Tree (AST) while analyzing Python code to extract crucial details about functions, classes, dependencies, constants, calls between functions/methods, and constructing a code graph representation using NetworkX library. Within this method, two inputs are significant: 'self' and 'node'.\n\n1. `self`: This refers to the current instance of the `CodeVisitor` object being used for analyzing Python code. It holds all relevant data related to the file processing such as source code ('code'), extracted details about functions ('functions', 'classes'), file information ('file_info'), and maintaining a class context ('current_class'). By having access to these variables, `generic_visit` can manipulate instance attributes for effective analysis.\n\n2. `node`: This parameter represents the current node being traversed in the Abstract Syntax Tree during AST traversal. It serves as an entry point for processing each node encountered while exploring the tree structure of Python code. The method iterates through child nodes within this 'node' to perform further analysis and recursively calls other visiting methods based on node types. This input helps `generic_visit` understand its current position in the AST hierarchy, enabling it to extract necessary details from each node encountered during traversal."
    },
    {
        "instruction": "Docstring of `CodeVisitor.generic_visit` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)\n```",
        "output": "Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit."
    },
    {
        "instruction": "Calls made in `CodeVisitor.generic_visit` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)\n```",
        "output": "'ast.iter_child_nodes', 'self.visit'\n\nPurpose and Significance:\nIn `CodeVisitor.generic_visit` within the given Python script 'get_python_file_details.py', two crucial calls are executed - `ast.iter_child_nodes` and `self.visit`. These calls serve pivotal roles in traversing an Abstract Syntax Tree (AST) while extracting necessary details about Python code elements during analysis by the `CodeVisitor` class instance.\n\n1. Purpose of Call: `ast.iter_child_nodes`: This built-in Python function returns an iterator over child nodes of a given node in the AST. It helps iterate through all direct children nodes within the current node being processed, enabling traversal across multiple levels of nesting in the code structure. In `CodeVisitor.generic_visit`, it allows exploring various types of subnodes and collecting their information for further processing by the visitor instance.\n\n2. Purpose of Call: `self.visit`: After identifying relevant child nodes using `ast.iter_child_nodes`, `self.visit` is invoked on each subnode. This call triggers execution of specific visit methods implemented in the `CodeVisitor` class based on node types, thus allowing extraction of attributes/values associated with each node. As `generic_visit` serves as a fallback method when no explicit visitor function exists for a particular node type, it propagates processing down through inherited nodes by recursively calling corresponding visit methods (e.g., `self.visit_FunctionDef`, `self.visit_ClassDef`, etc.) This way, the entire Abstract Syntax Tree is traversed and analyzed to gather code details required for documentation purposes.\n\nTogether, these calls ensure comprehensive exploration of an AST during file analysis in `CodeVisitor` class instances, extracting diverse aspects like functions, classes, dependencies, constants, calls between functions/methods, and generating a code graph representation. Their coordinated functioning is crucial to fulfill the overall purpose of capturing a structured documentation from a Python file within `get_python_file_details`."
    },
    {
        "instruction": "Variables in `CodeVisitor.generic_visit` in Python file: `py2dataset\\get_python_file_details.py`?",
        "input": "```python\ndef generic_visit(self, node):\n    \"\"\"\n        Called if no explicit visitor function exists for a node.\n        Args:\n            node: ast.AST: The node to visit.\n        \"\"\"\n    for child in ast.iter_child_nodes(node):\n        child.parent = node\n        self.visit(child)\n```",
        "output": "'self', 'node'\n\nPurpose and Significance:\nIn the context of the 'CodeVisitor' class within the 'get_python_file_details.py' script, the variables '_self'_ and '_node'_ hold significant roles during the execution of its method '_generic_visit_'. These parameters are primarily involved in traversing an Abstract Syntax Tree (AST) with extensive customizations, leading towards acquiring precise Python file data in detail for structuring a substantial code documentation process.\n\n'_self'_ acts as the referring context identifier indicating instances' related state in 'CodeVisitor' as an integral part of any invoked method within its scope. This enables efficient handling of inherited methods like '_visit_FunctionDef_', '_visit_ClassDef_', and user-defined '_generic_visit_'. Through self, access to class attributes such as '_functions_', '_classes_', '_file_info_', '_constants_', and others becomes straightforward. It also allows maintaining a parent-child relationship between nodes during traversal by keeping track of the current object instance.\n\n'_node'_ represents the actual node being visited in the Abstract Syntax Tree during traversal. This node serves as an input argument for various methods within '_generic_visit_', with functions exploring node aspects step-by-step within nested hierarchical ASTs of a Python program under scrutiny, capturing various syntax constituents related to Assignment, expressions and assigning these entities based on Node object inspection through ast library functionalities such as 'ast.iter_child_nodes'. In conjunction with '_self_', this facilitates capturing data and analyzing multiple instances encountered in Python source code exploration, hence essential for extracting comprehensive details about functions, classes, dependencies, constants, calls between functions/methods, etc., which are crucial for generating a structured documentation of the file."
    }
]