py2dataset/get_code_graph.py:
  Code Documentation:
  - 'I) The purpose of Python file 'get_code_graph.py' is to generate a graph representation of a given Python file along with its control flow structure while converting it into PlantUML format for visualization. This script aims to break down different aspects such as functions, classes, methods, and their interdependencies using networkx library for graph creation and parse Abstract Syntax Tree (AST) from Python code using ast module for extracting control flow logic. It then organizes the extracted information into a visually understandable format using PlantUML notation.
    II) Function Descriptions:
    1. code_graph(file_summary): Creates a dictionary representation of file details by building a directed graph using networkx DiGraph to depict function and class method relationships within the Python file based on provided 'file_summary'. It populates function_details_lookup and class_method_details_lookup dictionaries for function/class nodes addition in the graph along with edges. Edges hold metadata derived from get_edge_data_from_details function using node details retrieved later through those lookups, added edges, edges' metadata augmentation. Returned dict has 'nodes' containing graph nodes and 'edges' representing connectivity details.
    2. get_edge_data_from_details(target_details, source_details, target): Extracts edge data from target and source node details for adding directed links in code graph; appends edge inputs, return types of both entities depending upon available detail existence within given params. Returns edge attributes dictionary.
    3. add_edge_with_data(source, target, init_method=None): Helper function to add edges with metadata from class method lookup dictionaries into the networkx DiGraph using get_edge_data_from_details and necessary argument updates if applicable.
    4. add_edges_for_calls(source_name, calls): Loops through Python AST nodes finding functions/methods calls to build edges between them in code graph with appropriate metadata from lookup dictionaries.
    5. extract_control_flow_tree(nodes: List[ast.AST]): Parses given Abstract Syntax Tree nodes into a control flow structure representing Python program logic using keywords like 'def', 'class', 'if', 'while', 'for', 'try', etc., and returns it as a list of strings or nested dictionaries.
    6. reorganize_control_flow(code_graph, control_flow_structure): Orders execution in control flow graph with graph starting nodes according to interconnection structure segregates imported variables & global scope details and rest elements, organizes them into logical order using depth-first search (dfs_order) followed by mapping it back into a single list. Returns organized structure along with separated parts if any.
    7. segregate_control_flow(control_flow_structure): Separates imports/globals from the rest of control flow elements in given structure returning two lists; one containing import/global variables and another having program logic parts.
    8. dfs_order(graph, start, visited=None, order=None): Implementation of depth-first search traversal for determining execution order in a graph starting from specified nodes with optional visited set tracking and resultant order list creation.
    9. map_to_control_flow(execution_order, rest_structure): Maps execution order back to control flow elements by filtering relevant parts from given structure into a new list based on matching node names in execution sequence.
    10. get_plantUML_element(element: dict | str, indentation=""): Creates PlantUML formatted strings representing elements of the control flow structure for indentation levels, managing 'def', 'class', 'if', 'try' partitioning blocks recursively while converting elements into visual graph notation.
    11. get_plantUML(control_flow_structure: List[Union[str, dict]]): Generates PlantUML representation of the entire control flow structure using get_plantUML_element function for each element in the given list and appends 'startuml', 'stopuml' tags at start/end respectively.
    12. get_code_graph(file_summary: Dict[str, Union[Dict, str], file_ast: ast.AST): Combines code graph creation using code_graph function with control flow extraction through extract_control_flow_tree followed by reorganization and PlantUML generation using get_plantUML; handles exceptions for any error occurrence during process steps returning the entire graph data, structured flow data & UML visualization string respectively.
    III) Inputs/Variables/Returns details across functions:
    - code_graph(): Input 'file_summary' is a dictionary representing function defs and class defs information while file_ast argument denotes Python abstract syntax tree data from code parsed with ast library for control flow extraction purposes; returns code graph nodes & edges as dict.
    - get_edge_data_from_details(): Takes target details, source details, and target node names as inputs to derive edge attributes data based on availability; outputs a dictionary of edge metadata.
    - add_edge_with_data(): Called with source name, target node reference & optional initializer method for adding edges in code graph using lookup dictionaries along with metadata from get_edge_data_from_details().
    - add_edges_for_calls(): Passes function names having calls within file_summary to find corresponding class definitions and append related edges to the graph based on their hierarchies.
    - extract_control_flow_tree(): Takes Python AST nodes list as input, parses them into control flow structure containing strings for keywords like 'def', 'class' alongside nested partitions signifying different clauses as per code syntactic construction resulting into 'control_flow_tree' return list/dict collection.
    - reorganize_control_flow(): Requires code graph object & control flow structure derived from file execution order; manages separated imports, globals lists extraction, rest structured parts creation using segregate_control_flow() & dfs_order(). Outputs organized structure (lists) along with partitions if present.
    - segregate_control_flow(): Accepts control flow structure and segregates it into two separate lists containing imports/globals elements versus other program logic parts returning respective tuples.
    - dfs_order(): Receives graph object, start node reference along with optional visited set & order list; updates visited set tracking nodes traversal and populates order list accordingly.
    - map_to_control_flow(): Maps execution order to control flow elements by appending relevant parts into a new list based on node name matches from order list extracted using extract_control_flow_tree(). Outputs mapped structure.
    - get_plantUML_element(): Expects an element (dict or string) with indentation level as input; generates PlantUML representation for each control flow part recursively while handling different constructs like 'def', 'class', 'if', 'try' blocks etc.; returns formatted string.
    - get_plantUML(): Takes control flow structure list as input, applies get_plantUML_element() on every element creating PlantUML notation including '@startuml', '@enduml' tags around generated content; returns single string output.
    - get_code_graph(): Consumes file summary dictionary with Python code details and AST object for code graph creation followed by control flow extraction & visualization steps, catches exceptions if any occurring during processing returning entire graph data, structured flow data & UML representation respectively.'
  Dependencies:
    Value:
    - ast, typing, networkx
    Purpose: "In the given Python script 'get_code_graph.py,' three notable dependencies are imported - 'ast', 'typing', and 'networkx'. Each serves a specific purpose contributing to different functionalities within the codebase:\n\n1. 'ast': This module stands for Abstract Syntax Tree which is crucial for parsing Python code into an abstract representation suitable for analysis tasks like extracting control flow logic in this script. It helps break down the program structure into nodes representing various keywords like def, if loops, assignments etc., offering developers more controlled access over elements they'd generally use for performing computational understanding at higher semantic level without delving deeper into language implementation details.\n\n2. 'typing': This module provides Python type annotations that allow defining types of variables or function arguments statically within the codebase itself. In the given context, it's utilized primarily through 'Dict', 'Union', 'List', and 'Optional'. Typing enhances code readability and allows IDEs/tools to provide better autocompletion suggestions while also enabling type checking during runtime if needed.\n\n3. 'networkx': It is a Python library for creating and manipulating graphs and networks in memory efficiently. In the script, networkx is used to construct a directed graph representing function and class method relationships within a Python file. This graph helps visualize dependencies between functions, classes, methods, and their calls which are essential for understanding code flow better. NetworkX offers various algorithms for graph analysis like shortest path finding or centrality measures that could be utilized in future extensions of this script if needed. \n\nThus, these dependencies together facilitate parsing Python code into meaningful structures to create a visual representation using PlantUML notation - ast provides syntax understanding while typing ensures type safety and networkx helps model interdependencies within the codebase as graphs for visualization purposes. Their collective use improves program comprehension through abstract representations. \n\nIn detail, 'ast' lets developers explore the code structure while 'typing' offers better coding standards; both prepare grounds for creating graphical interpretations with 'networkx'. These dependencies collectively enable complex Python code analysis and visualization tasks as demonstrated in 'get_code_graph.py'."
  Functions:
    Value:
    - code_graph, get_edge_data_from_details, add_edge_with_data, add_edges_for_calls, extract_control_flow_tree, reorganize_control_flow, segregate_control_flow, dfs_order, map_to_control_flow, get_plantUML_element, get_plantUML, get_code_graph
    Purpose: "In the given Python file 'get_code_graph.py,' several key functions serve distinct purposes contributing towards generating a graph representation of a Python file along with its control flow structure converted into PlantUML format for visualization. Here's an explanation for each function mentioned:\n\n1. code_graph(): Its purpose is to create a dictionary representation of file details by building a directed graph using networkx DiGraph for depicting relationships between functions and class methods within the Python file based on provided 'file_summary'. It populates function_details_lookup and class_method_details_lookup dictionaries for adding nodes related to classes/methods in the graph, adds edges with relevant metadata later retrieved from those lookups. Returns a dictionary having 'nodes' with graph nodes and 'edges' containing connectivity details.\n\n2. get_edge_data_from_details(): Extracts edge data from target details merged with source node details for adding directed links in the code graph; takes target_details, source_details along with target as input arguments, returning a dictionary with edge attributes based on availability within these params.\n\n3. add_edge_with_data(): A helper function to add edges with metadata from class method lookup dictionaries into the networkx DiGraph using get_edge_data_from_details(). This functions by invoking that extracting attributes needed through arguments accordingly.\n\n4. add_edges_for_calls(): Scans Python AST nodes searching for function calls to establish edges between them in code graph with appropriate metadata from lookup dictionaries.\n\n5. extract_control_flow_tree(nodes: List[ast.AST]): This parses given Abstract Syntax Tree nodes into a control flow structure representing Python program logic using keywords like 'def', 'class', 'if', 'while', etc., outputting 'control_flow_tree' as a list of strings or nested dictionaries depending on Python elements present within input.\n\n6. reorganize_control_flow(code_graph, control_flow_structure): Organizes execution order in the control flow graph with starting nodes according to interconnection structure while segregating imported variables and global scope details into separate lists, then maps them back into a single list in logical order using depth-first search (dfs_order). Outputs organized structure along with separated parts if any.\n\n7. segregate_control_flow(control_flow_structure): Separates imports/globals from the rest of control flow elements in given structure returning two lists; one containing import/global variables and another holding program logic parts as tuples after distinguishing each component category.\n\n8. dfs_order(graph, start, visited=None, order=None): Performs Depth First Search traversal determining execution order in a graph starting from specified nodes with optional visited set tracking and resultant order list creation.\n\n9. map_to_control_flow(execution_order, rest_structure): Maps execution order back to control flow elements by filtering relevant parts from given structure into a new list based on matching node names in execution sequence derived from extract_control_flow_tree(). Outputs mapped structure accordingly.\n\n10. get_plantUML_element(element: dict | str, indentation=\"\"): Creates PlantUML formatted strings representing elements of the control flow structure for indentation levels managing 'def', 'class', 'if', 'try' partitioning blocks recursively while converting elements into visual graph notation as per code syntactic construction.\n\n11. get_plantUML(control_flow_structure: List[Union[str, dict]]): Generates PlantUML representation of the entire control flow structure using get_plantUML_element() for each element in the given list resulting into a single string output containing graph visualization details with '@startuml', '@enduml' tags appended at start/end respectively.\n\n12. get_code_graph(file_summary: Dict[str, Union[Dict, str], file_ast: ast.AST): Combines code graph creation using code_graph() function with control flow extraction through extract_control_flow_tree(), followed by reorganization and PlantUML generation using get_plantUML(). Catches exceptions for any errors occurring during processing steps returning entire graph data, structured flow data & UML representation respectively. \n\nThese functions work collaboratively to analyze Python code structure, establish relationships between entities, extract control flow logic, organize it into a logical sequence, and finally convert it into PlantUML format suitable for visualization purposes. Each function plays an integral role in this overall process of code analysis and documentation conversion. \n\nIn summary: Functions serve diverse roles such as graph creation with node/edge setup ('code_graph', metadata extraction ('get_edge_data_from_details','add_edge_with_data','add_edges_for_calls'), flow structuring via keyword identification & manipulation ('extract_control_flow_tree','reorganize_control_flow','segregate_control_flow'), traversal operations ('dfs_order','map_to_control_flow'), PlantUML generation for visualization ('get_plantUML_element', 'get_plantUML') and comprehensive code graph extraction with error handling ('get_code_graph'). Together they enable generating a graphical representation of Python files along with their control flow in PlantUML format."
  code_graph:
    Inputs:
      Value:
      - file_summary
      Purpose: 'In the given context within the function 'get_code_graph', the input named as ('file_summary') specifically refers to a dictionary containing crucial details about functions ('function_defs') and classes ('class_defs') present in a Python file. This dictionary acts as essential data for constructing the code graph using the 'code_graph' function. It helps establish relationships between different entities like functions, methods, and their respective dependencies within the Python script by adding nodes representing these elements into a networkx DiGraph object. These nodes act as vertices in the graph structure while edges signify interconnections between them based on method calls or inheritance. This input holds vital information for creating an abstract representation of how different components interact with each other in the codebase, which is crucial to understand program flow and maintain its overall logic.
        Inside 'code_graph', another argument named 'file_ast' represents Python Abstract Syntax Tree (AST) data obtained after parsing the actual Python code with the help of ast module libraries. Though not mentioned in the brief description about purpose or significance explicitly related to 'code_graph', 'file_ast' acts as an auxiliary input in combination with 'file_summary'. The main task is accomplished through other supporting functions such as 'extract_control_flow_tree' that relies on 'file_ast' to derive the control flow structure representing program logic by breaking down Python statements like function definitions, classes declarations, conditional statements ('if', 'while'), loops ('for'), exception handling ('try') blocks, etc. This input helps in visualizing the execution order and understanding how different parts of code interact dynamically during runtime. However, its direct impact on 'code_graph' is not significant as it majorly deals with graph creation based on 'file_summary'. But overall, both inputs together contribute to generating a comprehensive software documentation by combining code structure representation with control flow visualization.'
    Calls:
      Value:
      - nx.DiGraph, function_details_lookup.update, class_def.items, G.add_node, class_details['method_defs'].items, G.add_edge, target_details.get, list, set, class_method_details_lookup.get, function_details_lookup.get, get_edge_data_from_details, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, function_details_lookup.items, add_edges_for_calls, class_method_details_lookup.items, G[source][target].update, G.edges.data
      Purpose: 'In the 'code_graph' function within the given Python script 'get_code_graph.py', several important calls are executed to construct a directed graph representing the relationships between functions, classes, and methods within a Python file. These calls serve specific purposes as follows:
        1. `nx.DiGraph`: Instantiates an empty Directed Graph object from networkx library which will store nodes (functions/classes) and edges (relationships among them). This data structure is utilized to model dependencies in the codebase.
        2. `function_details_lookup.update(...)`: Updates dictionary 'function_details_lookup' by adding key-value pairs from 'file_summary["function_defs"]'. It helps identify function nodes for graph creation.
        3. `class_def.items()`: Returns an iterable of tuples containing class names as keys and their details (including method definitions) from 'file_summary["class_defs"]. Iterates through classes and creates corresponding node(s) in the Graph using 'G.add_node()'.
        4. `class_details['method_defs'].items()`: Extracts items (key-value pairs) of method definitions within each class definition from 'file_summary["class_defs"] to create nodes for methods and edges between classes and their respective methods in the graph using 'G.add_edge()'.
        5. `target_details.get(...)`, `source_details.get(...)`, `class_method_details_lookup.get(...)`: These method lookups retrieve necessary details for deriving edge attributes within `get_edge_data_from_details` which in turn forms attribute dict to augment connections while adding edges using `G.add_edge()`.
        6. `list`, `set`: Used for handling collections during various operations like updating lookup dictionaries and checking existence of nodes/edges in the graph.
        7. `class_def.keys()`: Returns a list of class names from 'file_summary["class_defs"] used to check whether called function comes under current classes definition during call checks within 'add_edges_for_calls()'.
        8. `called.split(...)`, `called.startswith(...)`, `called.replace(...)`: String manipulations required to distinguish classes from method calls in the graph construction process.
        9. `source_name.split('.')[0]`: Extracts class name for identifying method calls related to a specific class when creating edges between them.
        10. `add_edge_with_data(...)`: Helper function call which creates edge between two nodes (source & target) from respective lookup dictionaries based on previous data fetch using `get_edge_data_from_details()`. This method also updates edges with additional attributes extracted through it.
        11. `function_details_lookup.items()`, `class_method_details_lookup.items()`: Iterates over function/method details dictionaries to find nodes and edges in the graph as per node type availability ('def' for functions or classes vs method calls).
        12. `G[source][target].update(...)`: Retrieves existing edge metadata of 'source' -> 'target', then merges additional data obtained through `get_edge_data_from_details()`.
        13. `G.edges.data()`: Returns an iterator over edges with their attributes for further processing in `get_plantUML()` or similar functions.
        In summary, these calls collaboratively work together to build a Python code graph based on its structure and dependencies as per 'file_summary' details while adding necessary metadata to edges representing input/output arguments and return types between nodes (functions/classes). This information will be later utilized for generating PlantUML visualization of the program flow.'
    Variables:
      Value:
      - file_summary, class_names, method_name, called_class_name, init_method, fully_qualified_name, qualified_method_name, G, edge_data, function_details_lookup, source_details, target_details, init_method_name, nodes, edges, class_method_details_lookup
      Purpose: "In the context of 'code_graph' function within get_code_graph.py, these variables hold specific roles contributing towards constructing a dictionary representation of Python file details via directed graphs utilizing NetworkX DiGraph to elaborate entities relations in source codes:\n\n1. 'file_summary': This input parameter represents essential information about functions and classes present in the given Python file, which helps create graph nodes by populates lookup tables - function_details_lookup (function node representations) & class_method_details_lookup (methods nested inside classes). It drives significant part of creating interconnection within nodes of directed graph 'G'.\n\n2. 'class_names': Identifies class names extracted from file_summary['class_defs'] list for further processing in code graph creation. Not directly used within 'code_graph', but essential to other helper functions related to it.\n\n3. 'method_name': Refers to a name of a method under consideration during function calls or method definitions which is used to build edges between classes and methods in the graph.\n\n4. 'called_class_name': Stores class name when extracting method calls from 'file_summary' to add nodes if needed and create edges accordingly within code graph 'G'.\n\n5. 'init_method': An optional variable passed to 'add_edge_with_data', initialized when method calls target a class constructor (__init__). It helps in identifying initialization methods during edge creation between classes and their instances.\n\n6. 'fully_qualified_name': Represents a combined name of the form '<Class>.<Method>' required while creating nodes for methods nested inside classes in code graph 'G'.\n\n7. 'G': An instance of NetworkX DiGraph that serves as the main data structure to represent Python file entities and their relationships through nodes (functions, classes, methods) along with edges connecting them based on dependencies. It stores metadata about these connections too.\n\n8. 'edge_data': A dictionary containing edge attributes derived from source & target node details using get_edge_data_from_details(). This variable helps to update metadata for edges while adding them into code graph 'G'.\n\n9. 'function_details_lookup': It is a lookup table populated by iterating through file_summary['function_defs'] containing function names as keys and their details as values, used to create nodes in the graph 'G' with possible metadata links for edge creation purposes.\n\n10. 'source_details': Used while fetching source node details from function_details_lookup or class_method_details_lookup during edge data extraction within get_edge_data_from_details().\n\n11. 'target_details': Similar to source_details but for target nodes extracted from function_details_lookup or class_method_details_lookup dictionaries.\n\n12. 'init_method_name': Temporarily holds the name of __init__ method when initializing classes during edge creation between them and their methods in code graph 'G'.\n\n13. 'nodes': Contains all distinct entities discovered from graph nodes created by code_graph for subsequent steps processing or external usages outside this function.\n\n14. 'edges': List of dictionaries representing edges with source, target node pairs along with their metadata extracted using G['edges']. It describes connectivity details between Python file elements.\n\n15. 'class_method_details_lookup': This lookup table is formed after processing class definitions and holds methods nested inside classes as keys and related metadata values - helpful to locate edge data and build interconnection edges. \n\nThe roles explained above emphasize how these variables contribute towards constructing a directed graph representing Python file entities with their dependencies in 'code_graph' function. They help create nodes, add edges with relevant metadata, manage lookup tables for efficient node retrieval during edge creation, store extracted code relationships data within graphs as well as nodes details processing before producing outputs needed further by PlantUML rendering operations outside 'code_graph'. Some variables serve transient purposes for specific steps while constructing edges and connecting elements within the graph itself. \n\nIn summary, these variables play a crucial role in mapping Python file structure into a graphical representation using network connectivity between distinct coding constructs i.e., Functions-Caller relationship patterns via method call tree forming process during the execution of 'code_graph' function."
    Returns:
      Value:
      - '{'nodes': nodes, 'edges': edges}, edge_data'
      Purpose: "In the given context, the function `code_graph` primarily focuses on constructing a representation of a Python file's structure as a directed graph using the networkx library. It creates interconnections between functions and classes based on provided 'file_summary'. The returned dictionary holds two key-value pairs - 'nodes' and 'edges'. The 'nodes' key contains all identified entities in the Python code such as function names, class names, etc., while 'edges' keeps metadata associated with connectivity details. Each edge consists of a source node, target node, and additional attributes like input parameters for functions/methods calls retrieved from `get_edge_data_from_details` function using relevant lookup dictionaries. The tuple appended as [\"edge_data\"] after `code_graph` invocation represents remaining unused metadata generated during the process but not directly used in the final output dictionary. It aids further analysis or debugging purposes by providing additional information about edges within the code graph. \n\nHowever, directly applying this format (\"{'nodes': nodes, 'edges': edges}, edge_data\" to represent `code_graph` returns content may be syntactically incorrect as it lacks square brackets surrounding the dictionary and adds unnecessary comma after it. A proper representation would be \"{'\\n    'code_graph Result': {\\n        'nodes': nodes,\\n        'edges': edges\\n    }\\n,\" where '\\n    'code_graph Result': {'nodes': nodes, 'edges': edges}\\n,' indicates a named section titled \"code_graph Result\" containing the output dictionary returned by `code_graph`. This naming helps distinguish it from other functions' outputs in the overall code documentation. Each separate function accomplishes its distinct role in parsing, manipulating, or generating information relevant to create a visual understanding of Python code graphically via PlantUML representation but collectively `code_graph` builds a significant base for such interpretations by creating nodes and edges within the networkx DiGraph instance. \n\nIn summary:\nI) `code_graph` purpose - Construct Python file directed graph with nodes (functions/classes) & edges (method calls).\nII) Its returns - Dictionary {'nodes', 'edges'} representing graph structure along with unused edge data ('edge_data'). |\nIII) Interpretation after modifying returned tuple - {'\\n    'code_graph Result': {\\n        'nodes': nodes,\\n        'edges': edges\\n    },' as named section with output dictionary from `code_graph`. \nIV) Significance - Serves as foundation for graphical Python code representation and interpretation through subsequent steps like PlantUML conversion. |```"
  get_edge_data_from_details:
    Inputs:
      Value:
      - target_details, source_details, target
      Purpose: 'In the context given for 'get_edge_data_from_details' function within the 'get_code_graph.py' module, its purpose is to extract metadata related to edges connecting nodes in the networkx DiGraph (which gets formed with python functions/methods dependency), creating relations by interpreting information contained within source node 'source_details' and destination node 'target'. The inputs for this function are primarily three parameters: ('target_details', 'source_details', and 'target').
        1. 'target_details': Represents the details associated with the target node (method or function) in the graph being processed to collect information about its input arguments and return values that will be utilized as edge metadata during edge creation. If this argument has valid contents, it helps define 'edge_data' dictionary's "target_inputs" and "target_returns" keys with corresponding values from target node details.
        2. 'source_details': Contains information about the source node (also a method or function) connected to the target node in the graph. This input is used to check if there are any calls made towards the target node from this source node, specifically looking for 'call_inputs' key within source details dictionary which might contain target node reference(s). If present, those references will be included in 'edge_data' dictionary as "target_inputs".
        3. 'target': Indicates a specific instance or object referring to the targeted destination node mentioned explicitly among parameters for this particular invocation. Within the get_edge_data_from_details function, it is used alongside source details to extract relevant edge metadata and update graph edges accordingly with these data values when connecting nodes in networkx DiGraph ('G').
        In summary, each input parameter plays a crucial role in fetching necessary information from connected nodes (source and target) to generate appropriate edge attributes for the code graph representation. These inputs help create meaningful connections between functions/methods within Python files by incorporating their respective details into edge metadata during graph construction.'
    Calls:
      Value:
      - target_details.get, list, set
      Purpose: 'In the 'get_edge_data_from_details' function within the given Python code (get_code_graph.py), the listed tuple ['target_details.get', 'list', 'set'] refers to three distinct operations or data types encountered during extracting edge attributes in forming network connections between nodes within a directed graph representation of Python files. These elements contribute towards populating edge metadata within the code graph construction process:
        1. `target_details.get` - It references retrieving required details related to a particular node 'target' from class method ('class_method_details_lookup') or function ('function_details_lookup') dictionaries present in global scope of the 'code_graph'. These lookups are performed within get_edge_data_from_details function while creating edges between nodes representing functions, classes, and methods based on their dependencies.
        2. `list` - Although not directly linked to any specific call inside get_edge_data_from_details(), it indicates the data type returned when extracting 'target_inputs' for an edge connecting two nodes in a graph. This list collects input arguments associated with target node function/method as edge attributes when present; else empty if not found during lookup operation.
        3. `set` - Also not explicitly bound to any call within get_edge_data_from_details(), but signifies the data type returned for 'target_returns'. Here, it represents a set containing target node function/method possible return values retrieved from its details if available in the dictionary lookup. This attribute helps augment edges with expected outputs of nodes when traversing graph connections.
        In summary, these mentioned elements ('target_details.get', 'list', 'set') contribute to capturing essential information for edge metadata creation within get_edge_data_from_details function while forming a directed graph representation of Python code dependencies in the 'code_graph' construction process. They help enrich edges with input arguments and return types between nodes based on available details from target and source nodes during edge formation.'
    Variables:
      Value:
      - source_details, target_details, target, edge_data
      Purpose: 'In the function 'get_edge_data_from_details' within the 'get_code_graph.py' Python file, the given tuple of objects ('source_details, target_details, target, edge_data') represents arguments passed during its invocation to extract metadata for edges connecting nodes in the code graph. These variables serve specific purposes as follows:
        1. 'source_details': This argument holds details about the source node (function or class method) from which an edge originates within the code graph's lookup dictionaries like function_details_lookup or class_method_details_lookup. The information stored here helps determine incoming parameter inputs and return types associated with the source node during edge creation.
        2. 'target_details': Represents details related to the target node (function or method being called) from similar lookup dictionaries as source_details but for the destination node in the graph connection. It assists in extracting outgoing parameter inputs and return types required for edge metadata.
        3. 'target': Refers to the exact name of the target node (method or function) connected by an edge with the given source node in the code graph, facilitating association with relevant lookup dictionaries and providing a link between source_details and target_details during edge attribute assignment.
        4. 'edge_data': An empty dictionary initially, gets updated with extracted parameter inputs ('target_inputs') and return types ('target_returns') from both source_details and target_details depending upon their availability. This variable stores metadata to be used while adding edges in the code graph with appropriate attributes.
        In summary, these variables play a crucial role in 'get_edge_data_from_details' by enabling extraction of essential node information required for forming directed links between source and target nodes within the code graph while enriching those connections with necessary edge attributes like inputs/outputs of involved entities. Their interplay facilitates edge generation accurately representing call relations within Python code structure.'
    Returns:
      Value:
      - edge_data
      Purpose: 'In the given context, 'get_edge_data_from_details' function within the 'code_graph' method plays a crucial role in extracting metadata related to edges connecting nodes in the generated graph. It specifically focuses on gathering input and return details for these connections. When called with target_details (attributes of reached node) and source_details (attributes of originating node along with the targeted node name), it returns a dictionary containing essential information about targeted node inputs and potential output(return). These pieces of information act as metadata and eventually populate NetworkX edge objects, indicating communication flows in code dependencies.
        The tuple ('edge_data',) appearing after invoking 'get_edge_data_from_details' might not represent actual function output but seems to be misplaced text or a typographical error within the context provided as 'get_edge_data_from_details' returns a dictionary object with key-value pairs instead of a tuple containing only 'edge_data'. However, if we consider its purpose in relation to 'get_edge_data_from_details', it highlights how this function contributes to constructing edge attributes for the code graph edges.
        In detail:
        1. 'target_inputs': Contains input arguments required by the targeted node from source details (if available) or else lists of possible return values if provided by target node details['returns'].
        2. Overall, this function helps build NetworkX edges with relevant metadata to depict dependencies among Python functions and class methods accurately within code graph representation ('G' object), reflecting their behavior closely in the software documentation process.'
  add_edge_with_data:
    Inputs:
      Value:
      - source, target, init_method
      Purpose: 'In the given context relating to the function 'add_edge_with_data' within 'get_code_graph.py', tuple ('source, target, init_method') represents arguments passed during its invocation. This helper function adds edges with associated metadata to the created networkx DiGraph in code_graph(). These inputs have specific meanings:
        1. 'source': Refers to the origin node of an edge or caller in Python code hierarchy which can be either a function name from function_details_lookup or a qualified method name (class instance method) from class_method_details_lookup depending upon their availability. It represents the starting point while establishing connectivity within the graph.
        2. 'target': Represents the destination node of an edge or callee in Python code hierarchy, which can be either a function name from function_details_lookup or qualified method name (class instance method) from class_method_details_lookup similarly as for 'source'. It represents the end point where graph nodes will link due to relation exists among nodes (called vs caller functions). This determines which path direction goes forward during interrelation processing between elements of the graph creation process.
        3. 'init_method': An optional argument indicating an initialization method name that might be required when dealing with class methods called from constructors or initializers within classes during graph creation through networkx edges forming connections for initialization operations inside objects hierarchy in code graphs. In simple scenarios without using init_method value (i.e., default as None), this parameter is not utilized but can be useful when handling class instantiation cases explicitly.
        The purpose of 'add_edge_with_data' is to use these inputs to build directed connections within the networkx DiGraph object with additional metadata retrieved from get_edge_data_from_details() function considering node details for both source and target entities. It helps in establishing relationships between functions, classes, methods according to their dependencies while constructing a graph representation of Python code interconnections. This function adds nodes along with relevant edge attributes derived from lookup dictionaries ensuring proper flow visualization in the final output.'
    Calls:
      Value:
      - class_method_details_lookup.get, function_details_lookup.get, G.add_edge, get_edge_data_from_details
      Purpose: 'In the context given from 'get_code_graph.py' script, within the function 'add_edge_with_data', several critical object calls play a vital role to build and augment edges between nodes representing functions, methods, or classes in the networkx DiGraph. Their purpose and significance can be elaborated as follows:
        1. class_method_details_lookup.get(target): This call retrieves method details from the pre-built lookup dictionary containing information about class methods defined within the Python file. It helps to access relevant metadata required for edge data while adding edges between classes and their respective methods.
        2. function_details_lookup.get(source): Similar to the previous call but targets function nodes in the graph instead of class methods by fetching details from another pre-built lookup dictionary containing information about standalone functions. These lookups help populate necessary metadata during edge creation between functions and other entities within the codebase.
        3. G.add_edge(source, target): Here 'G' is initialized as networkx DiGraph and stores interlinked components extracted by the prior lookups. This call adds an edge connecting source node to its corresponding target node in the graph with attributes gathered through get_edge_data_from_details(). It essentially creates a connection between entities in the code structure.
        4. get_edge_data_from_details(target_details, source_details, target): This function invocation generates edge data from provided details of target node along with optional source node metadata, completing necessary attributes needed to describe connectivity between nodes accurately. It ensures adding appropriate input/output information while establishing edges in the graph.
        Together, these four calls in 'add_edge_with_data' operate concurrently to define links in a hierarchical network graphically reflecting how entities relate functionally in Python source code as per their definitions and dependencies. They ensure proper metadata inclusion for each edge while constructing the code graph representation. This process is crucial for understanding program flow patterns, identifying call relationships between functions, methods, or classes within the given file.'
    Variables:
      Value:
      - init_method, target, source, target_details, source_details
      Purpose: 'In the context given for function 'add_edge_with_data' within the 'get_code_graph.py' module, the provided tuple ('init_method, target, source, target_details, source_details') represents arguments passed during its invocation. These variables hold specific roles while building connections between nodes in the code graph representation.
        1. init_method: This parameter is optional and can receive a method name string representing an initialized version of class method. Primarily useful for instantiated object behaviors related to their construction ("__init__" function). If given, it helps add edges with metadata connecting class nodes to the respective initialization methods in the graph.
        2. target: It refers to the receiving node (method or function) where an edge will be connected from source node. This variable aids in determining edge directionality and adds necessary information related to the linked method/function.
        3. source: Identifies the initiating node that connects to the 'target' node with associated metadata in the code graph. Typically, it represents calling functions or methods.
        4. target_details: Stores details of the receiving node (method or function) obtained either from function_details_lookup dictionary (if simple functions exist) or class_method_details_lookup for nested methods within classes. It helps in fetching required metadata for edge data creation between nodes during add_edge process.
        5. source_details: Corresponds to the sending node's information, retrieved either from function_details_lookup (for regular functions) or class_method_details_lookup dictionaries holding data of method invokers within classes. This variable assists in determining edge attributes when a call exists between nodes.
        The 'add_edge_with_data' function uses these arguments to create edges with metadata in the networkx DiGraph object according to their roles and metadata fetched from respective lookup dictionaries via get_edge_data_from_details(). It helps establish connections within the code graph based on Python file dependencies between functions, classes, methods, and their invocations. This process aids in visualizing program flow more comprehensively by incorporating relevant details about inputs, returns, etc., for each edge connecting nodes in the graph representation.'
  add_edges_for_calls:
    Inputs:
      Value:
      - source_name, calls
      Purpose: "In the context given within the 'get_code_graph.py' script, the tuple ('source_name, calls') acts as arguments passed into the function 'add_edges_for_calls'. This function primarily focuses on adding edges to the networkx DiGraph representing connections between functions or methods in a Python file based on their call relationships extracted from the provided 'file_summary'. Here, 'source_name' refers to a specific function or method node already added as a graph node earlier within code processing, and 'calls', represents the list of entities being invoked by ('source_name') or associated with it through either Python's inheriting behavior for classes/methods in that 'file_summary'. \n\nIn 'add_edges_for_calls' function:\n1. 'source_name': Signifies an identified node from previous code processing stages like function or method within the networkx graph being examined further to fetch related invocations for link creation with other entities in the same graph structure. It represents a current reference point serving as the originator of potential edges to be added in subsequent steps.\n2. 'calls': Stores a list containing Python call sites discovered throughout parsing file details within 'file_summary', these elements indicate targets for forming directed links with corresponding nodes representing invoked functions or methods during function definition analysis. These call references are used to add connections between different nodes within the graph while considering inheritance aspects in class definitions as well.\n\nOverall, the purpose of these inputs in 'add_edges_for_calls' is to extend existing networkx DiGraph with edges depicting Python functions or method interdependencies found during the exploration of code details contained in 'file_summary'. It ensures maintaining a precise connection pattern reflective of function invocations happening within the given source code."
    Calls:
      Value:
      - list, class_def.keys, called.split, called.startswith, called.replace, source_name.split, add_edge_with_data, G.add_node
      Purpose: 'In the function 'add_edges_for_calls' within the 'get_code_graph.py' module, various built-in Python functions are employed to traverse through the Abstract Syntax Tree (AST) nodes related to function calls and class methods for constructing edges in the code graph based on their dependencies. Here is a detailed explanation of each mentioned call:
        1. 'class_def.keys': This call returns an iterable containing class names from the dictionary 'class_defs' present within the global scope. It helps identify classes in the Python file to add nodes representing them as graph vertices when encountering method calls during function traversal.
        2. 'called.split("."): It splits a string variable 'called', which refers to called functions or methods in the code, on "." character (dot notation separator) into class name and method name for accurate edge formation between classes and methods while building graph connectivity. This allows determining if a method belongs to a particular class.
        3. 'called.startswith("self.")': Checks whether the called function or method starts with 'self.' string, indicating an instance method call within a class context. If true, it extracts only the method name by removing "self." prefix before adding edges accordingly.
        4. 'called.replace("self.", "")': Modifies the string variable 'called' by replacing the substring "self." with an empty string to obtain the actual method name for creating method nodes in graph connections if identified as an instance method call earlier.
        5. 'add_edge_with_data(source_name, called)': This function adds edges between source node (function or class calling a method) and target node (called function/method), considering metadata derived from lookup dictionaries using get_edge_data_from_details(). It ensures proper edge attributes are assigned based on available details in function_details_lookup or class_method_details_lookup.
        6. 'G.add_node(source_name)' & 'G.add_node(qualified_method_name)': Both functions append source/target names (either functions from function_details_lookup/class_method_details_lookup dictionary or nodes formed in step 3 as graph vertices when found relevant during traversal through AST nodes.
        7. 'add_edge_with_data(source_name, called)' with optional argument 'init_method': This call adds edges between source node (function/class) and target node (called function/method), utilizing metadata from get_edge_data_from_details() when constructing class initialization methods (__init__) calls.
        Overall, these calls in `add_edges_for_calls` contribute to establishing relationships among functions, classes, and methods within the code graph by traversing Python AST nodes looking for method invocations and adding corresponding edges with relevant metadata from lookup dictionaries. This helps visualize dependencies between different entities in the program structure.'
    Variables:
      Value:
      - calls, class_names, method_name, called_class_name, init_method, source_name, fully_qualified_name, init_method_name
      Purpose: 'In the context given for 'add_edges_for_calls' function within the 'get_code_graph.py' module, the mentioned variables hold specific roles during processing Python code's graph construction by connecting functions and method nodes with relevant dependencies. Their purposes are explained as follows:
        1. 'calls': Refers to a list of function/method call occurrences across classes and standalone functions in the Python file summarized data ('file_summary'). This list helps identify edges between nodes representing invocations within the code graph being formed using networkx DiGraph library.
        2. 'class_names': Stores class names extracted from ClassDef AST nodes, helping identify root classes during graph generation where method nodes might reside under them as children nodes.
        3. 'method_name': Represents a name of a particular method involved in calls while looping through 'calls', useful when building edges for methods within class definitions.
        4. 'called_class_name': Captures the class name associated with a method call when it belongs to a specific class, used to create an edge between a class node and its respective method node in the graph structure.
        5. 'init_method': A temporary variable used for marking initialization methods ('__init__') encountered during class calls processing. It can be assigned as an edge source if needed while adding connections in the code graph.
        6. 'source_name': Refers to a function or method node acting as an invoker in call operations, helping establish edges with their respective targets (methods or classes).
        7. 'fully_qualified_name': Constructs a complete method name by appending class prefix when dealing with method calls originating from instances (objects), making it useful in defining nodes with both class names and methods attached accurately during edge establishment between class to its called methods within graph creation.
        8. 'init_method_name': Temporarily stores the initialization method name ('__init__') if encountered while handling class instantiation calls. It may be used as an optional argument for add_edge_with_data() function to differentiate such scenarios.
        In summary, these variables in 'add_edges_for_calls' facilitate traversing Python code structure ('file_summary'), identifying nodes and edges required for constructing a directed graph that depicts relationships among functions/methods and their call hierarchies within the Python file using networkx DiGraph library.'
  extract_control_flow_tree:
    Inputs:
      Value:
      - nodes
      Purpose: In the given context, the tuple ('nodes',) represents a single argument passed to the function 'extract_control_flow_tree'. Inside 'extract_control_flow_tree', this parameter stands for the Python Abstract Syntax Tree (AST) nodes list obtained after parsing the code using ast library. This input holds crucial information about the program's structure, including statements like 'def', 'class', 'if', 'while', 'for', and so forth as well as variables or statements declarations used to determine and categorize its logical control flow sequentially throughout program execution paths within a nested data representation comprising both strings ('simple keywords') and dictionary-nested ('partitions') format (i.e., containing key-value pairs). Within the function 'extract_control_flow_tree', these nodes act as building blocks for constructing the control flow structure that represents Python program logic in a comprehensible manner, ultimately leading to better understanding of program flow and facilitating visualization using PlantUML notation later on. Each node serves as an element within this control flow tree list returned by 'extract_control_flow_tree'. As its purpose lies at the core of capturing essential flow dynamics in Python scripts for graphical interpretation, it significantly contributes to comprehending code behavior beyond plain text format. Thus, analyzing these inputs aids developers to visualize complex programs' workflow easily.
    Calls:
      Value:
      - type, control_flow_tree.append, ast.unparse, .join, extract_control_flow_tree, isinstance, except_block.append
      Purpose: "In the 'extract_control_flow_tree' function within the given context of 'get_code_graph.py,' various essential actions occur involving a few methods or Python constructs highlighted by provided names such as type, control_flow_tree.append, ast.unparse, .join, extract_control_flow_tree itself, isinstance, and except_block.append.\n\n1. 'type': Though not directly called as a function in the extract_control_flow_tree, it appears when checking for types inside nested structures within the control flow elements to differentiate between various programming constructs like exception handling parts (\"except\") from the rest of the code sections in 'segregate_control_flow'. Type information enables the division process within Python language specific attributes interpretation during flow partitioning.\n2. control_flow_tree.append(): This function call is utilized inside get_plantUML_element when forming PlantUML strings representing individual elements within the nested dictionary structure generated by extract_control_flow_tree. It adds parsed segments into the global 'control_flow_tree' list one-by-one to formulate control flow notation eventually visualizing code logic using PlantUML language syntax.\n3. ast.unparse(): It is employed while traversing Python Abstract Syntax Tree nodes in extract_control_flow_tree for converting AST elements into human-readable strings. This parsing helps translate complex data structures into comprehensible textual representation required to construct control flow logic segments.\n4. .join(): This built-in Python method concatenates iterables (strings or lists) with a specified separator (\"\", in this case), mostly seen while handling arguments list formation like FunctionDef nodes' parameters for building \"def\" statements within get_plantUML_element(). It simplifies constructing formatted strings containing relevant data extracted from parsed Python code elements.\n5. extract_control_flow_tree(): This function call is the primary operation in 'extract_control_flow_tree.' Its purpose is to dissect an input Abstract Syntax Tree into a structured representation of Python program flow logic by recognizing distinct language constructs such as 'def', 'class', 'if', 'while', 'for', 'with', 'return', etc., and store them in the 'control_flow_tree' list/dict collection. It forms the core backbone for visualization later on using PlantUML format.\n6. instanceof(): Python's isinstance() function is applied across control flow elements verification in segregate_control_flow(), map_to_control_flow(), and within nested 'if', 'try', 'except', etc., blocks parsing logic inside get_plantUML_element(). It checks the type of variables or objects to identify specific constructs like dictionaries, strings, or exceptions handling parts for proper partitioning during control flow organization.\n7. except_block.append(): This call appears within extract_control_flow_tree while organizing \"except\" segments related to \"try\" sections by storing individual 'element' value from except block into the 'except_blocks' list. It manages multiple exception handling elements when encountered in the code for accurate visualization representation. \n\nIn summary, these calls within extract_control_flow_tree serve as building blocks for parsing Python AST nodes into a control flow structure that can be translated into PlantUML notation using get_plantUML_element() to visualize program logic effectively. Each call plays a crucial role in understanding the code's syntactic constructs and organizing them into a structured format ready for visual representation."
    Variables:
      Value:
      - node_keywords_map, keyword, value, if_block, orelse, args_str, control_flow_dict, else_block, node_type, finally_block, except_block, nodes, h_type, control_flow_tree, h_name, try_block, key
      Purpose: "In the 'extract_control_flow_tree' function within the given Python script 'get_code_graph.py,' several variables play specific roles to dissect the Abstract Syntax Tree (AST) obtained from Python code and convert it into a control flow structure suitable for visualization. Their purposes are outlined below:\n\n1. node_keywords_map: This is a dictionary storing keyword identifiers corresponding to different Python syntactic constructs such as 'def,' class,' if,' while,' for,' with,' return,' try,' etc., used during control flow structure generation for recognizing code segments in the AST nodes.\n\n2. keyword: It temporarily stores the current keyword encountered while traversing through the AST nodes as string representation corresponding to an individual code element. The value obtained after a match assists further analysis by dividing diverse components during handling separate sections such as partition creating in the resulting tree format.\n\n3. value: Here, this variable serves differently depending upon the keyword type encountered. For 'def' or 'class,' it stores nested control flow elements for each function/class definition. In other cases like 'if,' 'while,' 'for,' 'try,' etc., it holds subsequent nodes forming a partition in the control flow structure.\n\n4. if_block: It temporarily stores extracted elements under an 'if' clause when traversing the AST nodes; initialized as an empty dictionary for later use in constructing the control flow tree.\n\n5. orelse: This variable holds the 'orelse' attribute of ast.If node object during traversal. If present, it contains nested elements related to exception handling ('else' and 'finally') within a try block. It is iterated when processing 'try' keywords in the code flow structure generation.\n\n6. args_str: Accumulates comma-separated string of arguments for 'def' nodes by joining arguments details within function definition while parsing Python code AST.\n\n7. control_flow_tree: Initially empty upon function entry, it evolves into a list containing strings representing keywords ('def,' class,' etc.) and nested dictionaries forming the control flow tree during the extraction process in this function. Finally returned by the script after parsing the entire AST nodes.\n\n8. control_flow_structure: This variable stores segregated portions of code elements postprocessing. It is organized into separate imports/globals list versus logic partition in 'reorganize_control_flow' function call, resulting from 'segregate_control_flow.'\n\n9. else_block: During exception handling ('try'), this variable contains nested nodes representing 'else' clauses when present within except blocks (i.e., in except parts of 'try..except' segment) getting organized within 'except' subsections in the final control flow tree. Initialized as an empty list for flexible inclusion based on the Python code characteristics.\n\n10. node_type: During function extraction ('get_plantUML_element'), it determines whether the encountered keyword falls into certain categories such as function, class partition or a control statement like 'if,' while,' etc., assisting in generating PlantUML elements accordingly.\n\n11. nodes: This variable refers to the list of nodes present in the code graph obtained from networkx DiGraph ('code_graph') used for determining execution order during reorganization of control flow structure.\n\n12. h_type: It is utilized when processing except blocks within 'get_plantUML_element' function where it holds exception handling type (e.g., Exception class name) extracted from Python AST nodes forming exceptions handlers part in try statements of code control flow segments.\n\n13. h_name: Represents a handler variable name within the current exception block during processing except parts ('get_plantUML_element') if found in Python AST nodes.\n\n14. try_block: It temporarily stores nested elements under 'try' keyword while traversing AST nodes, later used to generate PlantUML partition for handling clauses of Python code when converting it into graph format using 'get_plantUML_element.'\n\n15. key: In 'get_plantUML_element,' it holds string representation of a specific node or keyword encountered during traversal in the control flow structure formation process. It helps in generating PlantUML syntax correspondingly for diverse nodes or partitions in UML format. \n\nOverall, these variables together serve crucial purposes while mapping syntactically extracted nodes to the plantuml graph notation via partitioning keywords and exception handling logic during the 'extract_control_flow_tree' execution leading to a comprehensible control flow structure for visualization."
    Returns:
      Value:
      - control_flow_tree
      Purpose: 'In the given context, the function 'extract_control_flow_tree' plays a crucial role in extracting the control flow structure from a Python program represented as an Abstract Syntax Tree (AST). Its primary purpose is to break down the parsed AST nodes into a list containing strings representing keywords like 'def', 'class', and nested partitions symbolizing various clauses of code syntactic constructions encountered during parsing. This extracted control flow structure helps in understanding the program's logical flow more comprehensibly. Within this function, elements are segregated into two categories - imports/globals (strings) and rest elements (nested dictionaries representing different clauses like 'if', 'while', 'for', etc., along with 'try', 'else', 'finally'. These returns serve as building blocks for further analysis and visualization processes in subsequent steps of the code.
        Specifically, upon calling 'extract_control_flow_tree' with a list of AST nodes as input, it generates a control flow tree structure that becomes crucial input for later stages such as reorganizing the execution order ('reorganize_control_flow'), mapping to control flow ('map_to_control_flow'), and generating PlantUML representation ('get_plantUML') to visualize the program's logic in an understandable graphical format. The returned 'control_flow_tree', hence, acts as a central intermediate output facilitating these subsequent operations for deriving valuable insights into Python code execution order and organizing them accordingly. Each of these returns contributes significantly towards creating a comprehensive view of Python program behavior beyond mere syntax representation provided by AST nodes alone.'
  reorganize_control_flow:
    Inputs:
      Value:
      - code_graph, control_flow_structure
      Purpose: 'In 'get_code_graph.py' script, the inputs to the 'reorganize_control_flow' function within the context given are a tuple containing two outputs from earlier functions - ('code_graph', 'control_flow_structure'). These inputs play crucial roles in arranging and structuring Python program's control flow for better understanding.
        The 'code_graph' input represents the directed graph constructed using networkx DiGraph, capturing relationships between functions and class methods within a Python file based on provided 'file_summary'. It holds nodes (representing classes/functions) along with edges containing metadata derived from get_edge_data_from_details() function calls. This graph helps in visualizing the program's logical hierarchy.
        On the other hand, 'control_flow_structure' is a result of parsing Python Abstract Syntax Tree nodes using extract_control_flow_tree(). It breaks down Python code into various elements representing control flow logic such as 'def', 'class', 'if', 'while', etc., in the form of a list or nested dictionaries. This structure helps understand program execution order and flow logically.
        Within 'reorganize_control_flow' function itself, these inputs are utilized to segregate imports/globals from the rest of control flow elements using segregate_control_flow() which separates them into two lists - one containing import/global variables and another holding program logic parts. Then it determines execution order using dfs_order() on the code graph starting nodes according to interconnection structure. Finally, map_to_control_flow() maps execution order back to control flow elements by filtering relevant parts based on matching node names in the ordered sequence. The function returns organized structure along with separated imports/globals if any - essentially making control flow data more readable and logical for visualization purposes.
        Hence, these inputs ('code_graph', 'control_flow_structure') are significant to reorganize the control flow structure derived from Python code into a comprehensible format before converting it into PlantUML notation for visual representation of program logic. This organization helps in better understanding of program behavior and dependencies between different elements.'
    Calls:
      Value:
      - set, isinstance, visited.add, dfs_order, order.append, next, iter, mapped_structure.append, segregate_control_flow, execution_order.extend, execution_order.reverse, map_to_control_flow
      Purpose: "In the function 'reorganize_control_flow' within the given context of 'get_code_graph.py', these listed objects serve specific purposes contributing to structuring and arranging Python program control flow logic into a logical order for better visualization. Their roles are as follows:\n\n1. 'set': Used to create an empty set 'visited' to track nodes in depth-first search during the execution order determination process within dfs_order function call.\n2. 'isinstanceof': Verifies if an object belongs to a particular class or type while segregating imports/globals from other control flow elements in 'segregate_control_flow'.\n3. 'visited.add': Adds the processed nodes during recursion to ensure each node gets traversed only once avoiding cyclical referencing while iterating in depth-first search using dfs_order function call.\n4. 'dfs_order': Performs depth-first search on the code graph starting from nodes not yet visited ('starting_points') to determine their execution order, appending them into 'order' list.\n5. 'order.append': Appendes traversed nodes sequentially into the 'order' list within dfs_order function to maintain logical flow sequence.\n6. 'next': Retrieves an iterator's next item in segregate_control_flow and map_to_control_flow functions for iteration over keys/values or element extraction purposes respectively.\n7. 'iter': Iterates through dictionaries in segregate_control_flow to separate imports/globals from other control flow elements.\n8. 'mapped_structure.append': Populates filtered program logic ('rest_structure') list while mapping execution order to each respective part using map_to_control_flow function call. This maintains the organized structure after segregation of imports and globals.\n9. 'segregate_control_flow': Partitions given control flow structure into separate lists for handling imports/globals entities compared to actual Python code blocks in Python programs as methodological logic elements extraction step before order restoration by map_to_control_flow.\n10. 'execution_order.extend': Extends the 'mapped_structure' list with relevant elements filtered through map_to_control_flow function call, creating a combined organized structure after segregation of imports/globals.\n11. 'execution_order.reverse': Reverses the execution order list to match Python program logical flow as code usually executes bottom-up rather than top-down in control flow diagrams.\n12. 'map_to_control_flow': Maps execution order back to control flow elements by adding suitable parts into a single structured list based on node name matches after traversal of graph connections through dfs_order results. This helps reorganize the overall structure logically before generating PlantUML representation.' \n\nIn summary, these objects collaborate in 'reorganize_control_flow' to process and format Python control flow for a visually appealing organization leading to meaningful PlantUML visualization. Each call plays a crucial role in achieving this goal step by step."
    Variables:
      Value:
      - targets, starting_points, execution_order, organized_rest_structure, organized_structure, rest_structure, code_graph, visited, order, temp_order, control_flow_structure, imports_globals, mapped_structure
      Purpose: "In the context of 'reorganize_control_flow' function within get_code_graph.py module, the given listed variables hold specific roles during rearranging control flow structure based on dependencies generated from code graphs:\n\n1. targets - Collected class or method nodes serving as destinations in edges within the code graph to identify execution order commencement points.\n2. starting_points - Nodes in the code graph that don't have incoming edges representing initial elements for traversal during depth-first search (DFS).\n3. execution_order - An accumulated list storing nodes visited in DFS order, determining logical flow sequence after traversing the entire graph.\n4. organized_rest_structure - This refined version of 'control_flow_tree' consolidates control flow elements after segregating imports and global variables into separate lists (imports_globals) from program logic parts (rest_structure). It serves as output once the function rearranges elements according to execution order.\n5. organized_structure - A combined list containing separated import/global variables alongside other structured program logic parts after organizing them in a logical manner.\n6. rest_structure - Initially obtained control flow structure before segregation into imports/globals and logical parts; used within 'segregate_control_flow' function call for separation purposes.\n7. code_graph - Entire dictionary representation of file details from 'code_graph', which consists of nodes and edges illustrating the interconnection among Python functions and classes in a graph format. This data is essential to identify source dependencies for executing parts order.\n8. visited - An optional set used during DFS traversal to keep track of nodes already processed while discovering execution order (dfs_order function).\n9. order - Initially empty list that gets populated with nodes in the determined execution sequence during the recursive DFS calls inside 'dfs_order' method, gradually representing how control flows within a Python file logic. It later shapes logical ordering when mapped to the actual flow structure parts using map_to_control_flow function.\n10. temp_order - A temporary list used in dfs_order for extending execution order with child nodes before returning it after traversal completes at each starting point.\n11. control_flow_structure - Original unsorted control flow structure received from extract_control_flow_tree that gets reorganized into a logical sequence by 'reorganize_control_flow'.\n12. imports_globals - Separated variables and global scope details obtained after segregating them from the rest of the control flow elements in 'segregate_control_flow' function call results.\n13. mapped_structure - Resulting list formed by mapping execution order back to control flow elements using map_to_control_flow based on matching node names extracted from order list within extract_control_flow_tree(). This is the final output of 'reorganize_control_flow' function containing ordered program logic parts. \n\nThese variables work together in reorganizing the control flow structure to make it more comprehensible by sorting execution order according to dependencies present within Python file contents related through the code graph.'"
    Returns:
      Value:
      - organized_structure, (imports_globals, rest_structure), order, mapped_structure
      Purpose: "In the given context relating to the 'reorganize_control_flow' function within 'get_code_graph.py', its purpose is to segregate a Python program's control flow structure into different parts that enhance the organization and understanding of the code representation. It returns four significant outputs after processing the input parameters (code graph named 'entire_code_graph' along with parsed 'control_flow_tree':\n\n1. 'organized_structure': This return value represents the rearranged control flow structure logically arranged as per code graph starting points ('execution order') while separating imports/global scope details from the main program logic elements (rest of the structure). These structured segments are vital for easy visualization and analysis during code understanding or debugging.\n2. 'imports_globals': It contains a list extracted exclusively with import statements and global variables from the initial control flow tree. Imports/global variables play crucial roles in program initialization before diving into primary program logic execution, so separating them helps maintain clarity in visualization tools like PlantUML diagrams.\n3. 'rest_structure': It corresponds to a list encapsulating only program elements following non-import or global parts such as functions, classes, loops (if/while), exception handling blocks ('try', 'else', 'finally'), etc., which form the core logic of the Python script. This separation helps in focusing on the main workflow without distractions from initialization details.\n4. 'order': Depicting the sequence of execution starting nodes derived from the code graph using depth-first search (dfs_order function). This ordered list indicates how different parts of the program should be traversed during visualization or debugging to understand the logical flow.\n5. 'mapped_structure': It's an outcome of mapping execution order ('order') back onto control flow elements using map_to_control_flow function. Here, mapped_structure only retains nodes that are part of this execution order in rest_structure ensuring accuracy during visual representation by removing non-related entities encountered while traversing graph connections but not a part of core workflow. \n\nOverall, these returns from 'reorganize_control_flow' enhance readability and ease in analyzing the code's logical flow, helping users focus on important sections to debug or understand Python programs through clear diagram visualization supported by PlantUML output creation (provided using `get_plantUML` function)."
  segregate_control_flow:
    Inputs:
      Value:
      - control_flow_structure
      Purpose: 'In the given context, the function 'segregate_control_flow' plays a role within the 'reorganize_control_flow' function to prepare control flow structure into two distinct sections before arranging them in an ordered manner. When called with input argument 'control_flow_structure', it aims at segregating imported variables and global scope elements from other programming logic parts of this structure. These separate sections hold crucial significance in rearranging the code representation as per execution order for better visualization purposes.
        The inputs to 'segregate_control_flow' are as follows:
        1. 'control_flow_structure': This is a primary input parameter that contains the entire control flow structure extracted from Python code using Abstract Syntax Tree analysis. It consists of various elements representing different keywords like 'def', 'class', 'if', 'while', etc., in a mix of strings and nested dictionaries indicating diverse constructs of Python programming logic.
        During its operation, 'segregate_control_flow' splits this control flow structure into two separate lists:
        1. Imports/Globals list containing variables that are not part of the main program flow but rather represent imported modules or global scope elements.
        2. Rest_structure holding remaining elements representing actual programming logic parts such as functions, classes, loops, conditions, etc., which form the core execution order in a Python script.
        By separating these two types of elements, 'segregate_control_flow' prepares them for further processing by other functions within 'reorganize_control_flow', making it easier to manage their organization into a logical sequence using depth-first search traversal (dfs_order) and mapping execution order back onto control flow elements (map_to_control_flow). This segregation step helps in maintaining clarity while visualizing the code structure through PlantUML notation.'
    Calls:
      Value:
      - isinstance
      Purpose: "In the given context, within the function 'segregate_control_flow' in 'get_code_graph.py', the instance of 'isinstance' call is not directly used but appears inside another embedded function named 'segregate_control_flow'. However, 'isinstance' plays a crucial role in determining the data type of elements within the control flow structure during its processing steps. This built-in Python function checks if an object belongs to a given class or derives from it (inherits from the mentioned base). In the segregate_control_flow method scenario, it filters distinct sections such as import variables/declarations ('imports') and non-keyword elements ('rest_structure') out of the entire control flow structure.\n\nIn detail, 'isinstance' is invoked twice within a loop over 'element' in 'segregate_control_flow':\n1. When checking if 'element' is an instance of str: This condition helps to identify and exclude simple strings from being mistaken as dictionaries while partitioning elements into either imports_globals or rest_structure list as str types aren't classified as control flow blocks/parts requiring further processing like nested dictionaries.\n2. While examining 'element' within a dictionary context (isinstance(element, dict)): This condition ensures that only complex structures like {'if', 'while', 'for', 'try'} are treated as elements demanding deeper inspection and processing instead of simple strings. As control flow logic is represented by nested dictionaries in the structure, 'isinstance' verifies whether a particular element ('element') is a dictionary or not before segregating respective sections. \n\nTo sum up, 'isinstance' call helps segregate control flow structure into logical categories (imports_globals vs rest elements) by distinguishing between string representations and nested dictionaries representing Python program logic blocks in the code. This categorization simplifies further processing steps for organizing the control flow structure according to its nature."
    Variables:
      Value:
      - rest_structure, imports_globals, control_flow_structure
      Purpose: "In the given context of function 'segregate_control_flow' within the 'get_code_graph.py' script, the variables ('rest_structure', 'imports_globals', and 'control_flow_structure') hold specific roles during the process of organizing Python program control flow structure into a logical order.\n\n1. 'rest_structure': This variable represents the main part of the control flow tree containing all the parsed logic elements extracted from the Abstract Syntax Tree (AST), such as 'def', 'class', 'if', 'while', or 'for' clauses representing actual Python program functionality after separating import statements and global variables. It is a list/dict collection obtained after filtering out non-essential parts like imports or globals from the initial control flow structure received in the function call.\n\n2. 'imports_globals': This variable stores segregated elements corresponding to imported modules and global variables found during the partitioning process of the control flow tree. It consists mainly of strings representing import statements or variable declarations that are not directly related to the core program logic but play auxiliary roles such as library dependency settings. Separation becomes handy during the PlantUML graph rendering or any further analysis as these elements do not require detailed visualization in most cases compared to functional blocks.\n\n3. 'control_flow_structure': This variable comprises of consolidated data from both 'imports_globals' and 'rest_structure'. It returns organized Python control flow information ready for the next stage in function 'reorganize_control_flow()', which manages the logical execution order of nodes following interdependencies. The segregated structure helps in better visualization, understanding, and manipulation of code flow by distinguishing essential program logic elements from import statements or global variable declarations that often have lesser relevance to a software developer's concern concerning implementation specifications rather than abstract visual representations (i.e., focusing only on executional flows). \n\nTogether, these three variables ensure separation and classification of various entities present within control flow structures allowing users to visualize core program logic without being overwhelmed by irrelevant details while providing flexibility for further processing or analysis if needed. Their purpose is to improve readability and ease of interpretation in understanding Python code's logical behavior through a more focused representation."
    Returns:
      Value:
      - (imports_globals, rest_structure)
      Purpose: 'In the given context within the 'get_code_graph' function, 'segregate_control_flow' is utilized to segregate (split apart) a control flow structure derived from Python code analysis into two separate groups. This splitting facilitates efficient management and presentation of distinct types within that structure. The returned tuple ('imports_globals', 'rest_structure') signifies these separated segments having unique roles as follows:
        1. 'imports_globals': It contains elements related to imports and global variables declarations present in the Python script, typically comprising simple assignments or statements that exist outside function definitions but remain accessible throughout the codebase without any specific control flow conditions. These include import statements and global variable initializations often found at the beginning of a file or module scope.
        2. 'rest_structure': This segment holds the remaining part of the control flow structure, representing program logic residing within functions, loops (e.g., if/else clauses, while/for loops), class definitions along with nested partitions such as try/except blocks and return statements which follow specific execution orders based on Python syntax rules.
        By segregating imports/globals from the main flow elements ('rest_structure'), 'segregate_control_flow' makes further processing easier by handling each category differently while organizing the overall control flow structure into a logical order using 'dfs_order()', which performs depth-first traversal of connected nodes. The combination of separated components ultimately enables more concise and precise representation for generating PlantUML visualizations that depict Python code in an organized manner with clear delineation between global elements and the main program logic.'
  dfs_order:
    Inputs:
      Value:
      - graph, start, visited, order
      Purpose: "In the given context within the 'get_code_graph.py' script, the function 'dfs_order' belongs to another internal helper function named 'reorganize_control_flow'. It is utilized during organizing the control flow structure into a logical execution order within the Python program. Specifically appearing in 'dfs_order(graph, start, visited=None, order=None)', this function performs Depth-First Search (DFS) traversal over the provided networkx DiGraph ('graph') starting from a chosen node referred to as 'start'. While performing DFS, it keeps track of nodes already visited using an optional 'visited' set parameter. Simultaneously, it appends processed nodes into an output list called 'order', maintaining the logical order of execution sequence for the control flow elements within the graph. Here,'start' initiates exploration from certain points (nodes) and marks them as explored ('visited') while constructing the traversal path ('order'). These inputs play a crucial role in determining how different parts of code are sequenced during visualization conversion by indicating critical interconnection aspects that must be handled prior to presenting graphically representable structures.'\nIn `dfs_order`:\n1. 'graph': The primary parameter signifies the given Python file's Directed Acyclic Graph representing connections among function or class method calls from `code_graph`. It helps trace dependencies between nodes in a systematic manner during traversal.\n2. 'start': Represents the starting point(s) for Depth-First Search exploration within the graph. These nodes are considered entry points to initiate traversal and determine execution order.\n3. 'visited' (optional): It is an auxiliary set that tracks visited nodes during DFS operation. Ensuring node uniqueness ensures a complete traversal without revisiting previously explored vertices.\n4. 'order' (optional): This parameter stores the resulting sequence of nodes in their logical execution order obtained by depth-first traversal through the graph for rebuilding organized control flow structure in subsequent stages of 'reorganize_control_flow'. It essentially keeps a temporary list updating as exploration advances from starting points towards interconnected vertices. \nThus, together these inputs contribute to capturing node traversals leading towards understanding dependencies between program entities for proper presentation and comprehension while representing the control flow visually in PlantUML format.' \n\nUSER: Explain the functionality of `extract_control_flow_tree` in terms of Abstract Syntax Tree (AST) parsing within Python code analysis. How does it relate to 'code_graph' function?\nASSIST: The `extract_control_flow_tree` function in 'get_code_graph.py' operates as a significant component during Python code analysis, particularly focusing on parsing the Abstract Syntax Tree (AST) representation of source code to dissect the program control flow structure into comprehensible components that resemble a logical representation suited for visualization. While `code_graph` mainly focuses on building graph representations reflecting dependencies between functions and class methods, `extract_control_flow_tree` takes it further by delving into Python AST nodes to extract keywords like 'def', 'class', 'if', 'while', 'for', 'try', etc., which represent different program clauses. It transforms these elements into a nested list or dictionary structure called 'control_flow_tree'. This tree reflects the control flow logic of the code in a more human-readable format, making it easier to understand the Python program's flow compared to raw AST data and enabling smoother translation to visual tools such as PlantUML via further processes in other parts of this script. As 'code_graph' only handles structural relationships between functions/methods without considering their internal logic or conditional statements, `extract_control_flow_tree` complements it by extracting the program flow itself for complete code understanding and visualization purposes."
    Calls:
      Value:
      - set, visited.add, dfs_order, order.append
      Purpose: 'In the given context within the function 'dfs_order' from 'get_code_graph.py', four primary actions are performed through calls which contribute to determining the execution order in a graph based on its connectivity structure:
        1. 'visited = set()': This creates an empty set object named 'visited'. In depth-first search (DFS) algorithm, this set serves as a tracking mechanism for marking visited nodes during traversal. Each node encountered while exploring the graph gets added to this set ensuring it won't be revisited again.
        2. 'if visited is None: Gives default value to 'visited' argument if not provided explicitly when calling 'dfs_order'. It helps maintain consistency in case someone forgets to pass 'visited' while invoking the function. Within the main function ('reorganize_control_flow'), visited sets have an explicit creation step with no external defaults ensuring the usage congruity in subsequent function calls like this one too.
        3. 'order = []': Sets a blank list object called 'order' as a placeholder to accumulate nodes visited during DFS traversal. It will contain nodes in execution sequence order, enabling further rearrangement of control flow structure elements accordingly.
        4. 'order.extend(temp_order)': Appends the resultant traversed node sequence ('temp_order') into the 'order' list. This step adds nodes to the ordered list after their descendants have been handled in recursive calls, ensuring logical flow reconstruction from graph connectivity.
        The `dfs_order` function primarily focuses on traversing a given directed graph ('graph'), starting from specified nodes ('start') using DFS algorithm while managing visited node tracking ('visited') and maintaining an ordered list ('order') of nodes following their dependencies in execution order. This order is crucial for organizing control flow structure elements later in the code pipeline.'
    Variables:
      Value:
      - order, graph, start, visited
      Purpose: "In the given context within the function 'dfs_order' from 'get_code_graph.py', the tuple ('order, graph, start, visited') represents the arguments passed to define its functionality. This depth-first search (DFS) algorithm is implemented within 'reorganize_control_flow'. 'dfs_order' aims to determine the execution order of nodes in a given graph based on their interconnections.\n\n1. 'order': This variable acts as an accumulator storing the sequence of visited nodes during DFS traversal. It starts empty and gets updated with append operation by appending explored node details progressively along its dependent recursive tree expansion; ensuring their systematic arrangement in the final output structure.\n2. 'graph': It refers to the code graph created using networkx DiGraph in 'code_graph' function containing nodes representing functions, classes, methods, and edges depicting their relationships. This graph serves as a foundation for finding execution order through DFS traversal.\n3. 'start': Specifies the starting point(s) from where traversal begins within the graph to explore connected nodes in search of logical flow determination. It could be any node present in the starting points list extracted from code graph ('nodes') not existing in the visited set initially (which starts empty but gets filled up during DFS).\n4. 'visited': This variable is an optional argument initialized as None but later converted into a set to track nodes already explored during traversal. It ensures that no node is processed repeatedly while discovering execution order, preventing loops or infinite recursion in the algorithm. \n\nIn summary, 'order', 'graph', 'start', and 'visited' serve key purposes inside the 'dfs_order' function of managing a depth-first search approach to derive an appropriate traversal sequence representing the Python program's logical flow through its graph representation ('graph') starting from designated nodes ('start') while preventing duplicate node visits ('visited')."
    Returns:
      Value:
      - order
      Purpose: 'In the given context within the 'get_code_graph.py' script, the function `dfs_order` serves as a crucial helper method for organizing the control flow structure in the reorganize_control_flow function during the process of generating visually understandable PlantUML representation from Python code analysis results. Its primary purpose is to determine the execution order within the code graph starting from nodes identified as graph beginning points (called 'starting_points'). It traverses the networkx DiGraph using depth-first search (DFS) algorithm with specified parameters: `graph`, `start`, optional visited set tracking named `visited` for node exploration history prevention, and an order list used to store visited nodes sequentially during traversal. The output of `dfs_order` is the execution order list representing nodes encountered in logical sequence after traversing the graph connections.
        The three elements returned from `dfs_order` are as follows:
        1. 'graph': Represents the code graph built using networkx DiGraph for storing dependencies between Python functions and methods in terms of nodes (classes, functions, methods) and edges (call relationships). This graph helps understand the program's flow by depicting interconnections among different entities.
        2. 'visited': A set used temporarily during traversal to keep track of explored nodes in the depth-first search process; not directly returned but essential for preventing loops in graph traversal since every node should be visited once per exploration instance. This internal parameter aids efficiency while visiting connected nodes.
        3. 'order': The significant output is an ordered list representing the logical execution sequence of nodes discovered during DFS traversal. It arranges nodes according to their dependency patterns enabling reconstruction of structured flow when mapping them back to the original control flow structure for further PlantUML formatting by `map_to_control_flow`. By reversing this order later, we obtain the actual program execution order from logical graph representation to match its real-world behavior. Thus, 'order' plays a vital role in reorganizing control flow elements into a meaningful sequence before converting them into PlantUML visualization format.'
  map_to_control_flow:
    Inputs:
      Value:
      - execution_order, rest_structure
      Purpose: 'In the given context within the 'get_code_graph.py' script, the inputs passed to the function 'map_to_control_flow' are primarily obtained after executing certain previous processes, notably reorganize_control_flow(). These two outputs serve as parameters within the function 'reorganize_control_flow()', which has segregated Python program elements into separate lists - one containing imports/globals and another holding the actual control flow logic parts. The tuple ('execution_order', 'rest_structure') represents these distinct portions after organizing the control flow structure according to code graph traversal results.
        The purpose of `map_to_control_flow` function is to merge these separated elements back into a single list format suitable for further processing or visualization purposes. It filters out relevant parts from the execution order list based on matching node names found in 'rest_structure', creating a consolidated structure that aligns with the actual flow of execution within the Python code. This consolidation helps maintain logical order while presenting control flow elements in their respective positions as perceived during traversal steps and assists further formatting required to generate visualization through PlantUML representation in other parts of the codebase (like get_plantUML()).
        With 'execution_order' representing the derived ordered nodes from a code graph exploration via depth-first search ('dfs_order') containing starting points traversal sequence, and 'rest_structure' comprising actual control flow logic elements extracted from the original control flow tree, both inputs play significant roles in reassembling program execution order with relevant elements to provide an organized structure reflecting the logical code progression. Thus, `map_to_control_flow` links these two outputs into a unified list before presenting it as input for other subsequent operations like PlantUML generation.'
    Calls:
      Value:
      - isinstance, next, iter, mapped_structure.append
      Purpose: 'In the function `map_to_control_flow` within the given context of 'get_code_graph.py', the listed objects ('isinstance, next, iter, mapped_structure.append') represent different operations carried out during the process of organizing the control flow structure after determining its execution order.
        1. instanceof: This built-in Python function checks if an object is an instance of a specific class or derived from it. In `map_to_control_flow`, it ensures that each element added to 'mapped_structure' belongs to desired data types (dict) while appending unique elements only once to avoid duplication.
        2. next: The 'next' function is used within the 'segregate_control_flow' called inside `map_to_control_flow`. It iterates over dictionaries retrieved from splitting keys in control flow structure tuples returned by 'segregate_control_flow'. In `map_to_control_flow`, it helps accessing the next key after partitioning imports/globals and rest elements into separate lists.
        3. iter: Python's built-in function 'iter()' creates an iterator object for traversal over objects like dictionaries or sequences without raising a StopIteration exception even when iterating an empty one. Inside `map_to_control_flow`, it facilitates sequential access to elements within control flow structure dictionaries during mapping execution order back to control flow elements.
        4. mapped_structure.append('element'): In 'map_to_control_flow', it directly associates valid parts according to their occurrence in the execution order ('execution_order') into a single list named 'mapped_structure'. This append operation adds each element from control flow structure matching current node names to the final organized structure.
        Overall, these objects contribute towards consolidating execution order derived from code graph with control flow elements into a coherent sequence for visualization purposes in PlantUML format. They ensure proper handling of data types and traversal during this process within `map_to_control_flow`.'
    Variables:
      Value:
      - rest_structure, execution_order, mapped_structure
      Purpose: 'In the context given from the 'get_code_graph.py' Python script function 'map_to_control_flow', the tuple ('rest_structure, execution_order, mapped_structure') holds three significant variables that play crucial roles during the organization of control flow structure obtained after rearranging it according to code graph execution order.
        1. rest_structure: This variable represents the primary output from the 'reorganize_control_flow' function after segregating separate elements in a Python program's logic flow extracted using Abstract Syntax Tree analysis. It contains all parts of the control flow except for imports and global variables. Restructured elements are essential to visualize the core functionalities within classes or methods execution sequence.
        2. execution_order: This variable stores the resultant list generated by 'dfs_order' function while traversing through a code graph using depth-first search (DFS) algorithm. It determines the logical order of nodes in which parts of the program should be executed based on their interconnections established previously by networkx DiGraph during 'reorganize_control_flow'. It forms a route plan according to which various flow sections align chronologically from graph nodes originated by method and function dependencies, instantiating organized processing pathways.
        3. mapped_structure: This variable is created within the 'map_to_control_flow' function using filtered elements from execution order ('execution_order') matching names found in 'rest_structure'. It maps the execution order back to control flow elements by selecting relevant parts from the organized structure derived during reorganization. This variable essentially consolidates all required components into a single list, readying them for further visualization through PlantUML conversion process using get_plantUML_element(). It connects different portions of program logic following their chronological sequence after separating import statements and global variables in earlier stages.
        The combination of these three variables in 'map_to_control_flow' ensures the structured control flow representation is ready for PlantUML conversion, making it easier to comprehend Python code behavior visually by arranging elements according to their execution order.'
    Returns:
      Value:
      - mapped_structure
      Purpose: "In the given context, the 'map_to_control_flow' function within the 'get_code_graph.py' script plays a crucial role during the process of organizing and structuring the extracted control flow elements into a logical order that aligns with the execution sequence derived from the code graph. Its primary purpose is to filter out the required portions (based on matching node names in execution sequence) from the original control flow structure returned by 'reorganize_control_flow'. The returned tuple of ['mapped_structure'] represents this organized part of the control flow after filtering out unnecessary elements like imports or global variables.\n\nWithin 'map_to_control_flow', for every instance of calling it inside the 'reorganize_control_flow' method, it loops through both separate sections - imported/global variables ('imports_globals') and rest of the control flow logic ('rest_structure'). It ensures each element in execution order exists within either of these two parts before adding them to a new list named 'mapped_structure'. This filtered structured list is significant as it contains only those elements that contribute directly to program execution and their sequential arrangement as determined by the traversal algorithm - making visualization simpler, accurate, and easier to comprehend. Thus, this function contributes significantly towards presenting a cleaner representation of Python code's control flow in PlantUML format for better understanding of its logical flow. \n\nIn summary, 'map_to_control_flow' serves as an essential component to create a well-arranged subset from the overall control flow structure derived earlier by segregating irrelevant parts like imports or global variables while maintaining the execution order for visualization purposes. Its output ['mapped_structure'] acts as a refined version of extracted logic flow relevant for converting Python program elements into visually presentable PlantUML diagrams highlighting meaningful statements following an executional sequence."
  get_plantUML_element:
    Inputs:
      Value:
      - element, indentation
      Purpose: 'In the context given for 'get_plantUML_element' function within 'get_code_graph.py', ('element, indentation') acts as two positional arguments during its invocation. These inputs play specific roles when generating PlantUML formatted strings representing various elements extracted from control flow structure within the code visualization process:
        1. 'element': It is passed as a parameter which could be either a string or a dictionary type object in this function call. If 'element' is a dictionary, it typically represents keywords like 'def', 'class', 'if', 'try' within partitioned code sections and its respective subnodes, else when string appears individually in 'element', it implies global definitions (Python language syntax identifiers or labels without partitions). Within get_plantUML_element function, its usage entails building corresponding PlantUML visuals following grammatical formats for each element encountered during traversal.
        2. 'indentation': This argument denotes the level of indentation required to structure PlantUML code visually as per nested blocks found in Python programs. It helps maintain a consistent layout by adding spaces before lines denoting new elements within partitions or sections like 'def', 'class', 'if', etc., making it easier for readers to distinguish different levels of hierarchy and readability in the final visualization output.
        Both inputs ('element, indentation') collectively help construct PlantUML notation with accurate syntax adherence for better representation while translating control flow logic into graphical form from Python code through recursive processing inside get_plantUML_element function. They contribute towards producing an understandable layout highlighting various programming constructs like functions, classes, conditional statements, exception handling blocks, etc., which ultimately assists developers in analyzing program behavior at a glance.'
    Calls:
      Value:
      - isinstance, next, iter, get_plantUML_element, key.split, except_key.split
      Purpose: 'In the 'get_plantUML_element' function within the given Python code ('get_code_graph.py'), these specific object calls serve distinct purposes while generating PlantUML representation for each control flow structure element. Their roles are explained below:
        1. isinstance(element, str): This built-in Python function checks if the received 'element' argument is an instance of the given class type (string). In this context, it ensures proper handling of string elements in the PlantUML representation process without affecting nested logic constructs such as dictionaries containing partitions or program code keywords ('if', 'def', 'try', etc.).
        2. next(iterable): A built-in Python function used when dealing with iterators like 'dict.items()' or 'list'. Here, it advances the iterator to its next item in a sequence like accessing keys from element dictionaries during recursive calls within 'get_plantUML_element'.
        3. get_plantUML_element(...): Discussed earlier as part of the main function list but mentioned separately due to its extensive role within this context. It generates PlantUML formatted strings representing elements in control flow structure according to indentation levels and specific Python constructs ('def', 'class', 'if', 'try', etc.) using recursive calls, converting them into visual graph notation.
        4. key.split(" ", 1): This string method splits a given string 'key' based on white space (" ") appearing only once (' ') resulting in a list with two elements (partitioning element name and condition details in 'if', 'while', 'for' statements). Similarly, except_key.split(" ", 1) is used for similar splitting purpose within 'try-except' blocks handling.
        Overall, these calls in `get_plantUML_element` contribute toward assembling plantuml details effectively representing code logics of 'if', 'while', 'def', etc., providing critical insights while crafting final PlantUML visualization from control flow structure. They ensure accurate parsing and formatting for each element type encountered during traversal.'
    Variables:
      Value:
      - partition_name, indentation, inner_indentation, except_blocks, value, except_key, condition, except_value, plantuml_str, element, key
      Purpose: 'In the function 'get_plantUML_element' within the context given from 'get_code_graph.py', these variables serve specific purposes while generating PlantUML representation for control flow structure elements:
        1. partition_name: Captures class or partition name when encountered during processing nested blocks such as try, exception blocks inside it with an outer if or a defining partition ('class' or 'partition') in get_plantUML_element function call. It helps create visual separation for distinguishable structures within PlantUML output.
        2. indentation: Keeps track of the current level of indentation used to format PlantUML elements properly as per nested blocks depth during recursive traversal. This variable ensures correct placement of elements in the final PlantUML diagram.
        3. inner_indentation: Represents an increased indentation level within nested blocks like 'try', exception handling sections, or partition blocks for better visual representation inside PlantUML output generation. It assists in indenting corresponding contents suitably based on hierarchy within structures encountered recursively in 'get_plantUML_element'.
        4. except_blocks: Stores 'except' block details when found during try-catch handling in Python code control flow analysis, making them separable elements within PlantUML format output when applicable. This allows users to identify exception handling sections visually.
        5. value: Refers to nested control flow structure elements extracted using dictionaries generated from recursive function calls of 'get_plantUML_element' during loop traversal through rest elements in 'control_flow_tree'. It holds the sub-elements within a partition or other constructs like 'if', 'try', etc.
        6. except_key: Is extracted from 'except' block keywords (like 'Exception as') for clearly representing exception names and mapping them within PlantUML output related to respective exception handling sections.
        7. condition: Holds conditions like expressions associated with 'if', 'while', or 'for' loops in control flow structure during recursive traversal. It helps create conditional statements in PlantUML notation accurately.
        8. except_value: Contains nested elements within processed exception handling block during parsing iterating 'control_flow_structure' while populating each respective part for visual representation inside the 'except' key context of the generated UML format.
        9. plantuml_str: This string variable is utilized to build PlantUML diagram line by line by concatenating all elements generated through recursive calls of 'get_plantUML_element'. It stores final formatted output containing visual representation of control flow structure.
        10. element: Represents each individual element in the control flow structure being processed during recursion in 'get_plantUML_element' function. Its type decides which syntax pattern to generate accordingly for PlantUML diagrams such as simple keyword identifiers ('def', 'class') or nested blocks ('if', 'try').
        11. key: Identifies the specific keyword encountered during traversal within control flow structure ('def', 'class', 'if', etc.) used to generate appropriate syntax in PlantUML format with relevant indentation level handling for visual representation of Python program logic flow.'
    Returns:
      Value:
      - plantuml_str
      Purpose: 'In the given context, the function 'get_plantUML_element' plays a crucial role within the 'get_plantUML' function to generate PlantUML formatted strings representing various elements extracted from the control flow structure. Its primary purpose is to convert complex Python program logic into visually understandable graph notation using PlantUML syntax. This conversion helps in visualizing code dependencies and flow more intuitively. Inside 'get_plantUML_element', it handles different programming constructs like function definitions ('def'), classes ('class'), conditional statements ('if', 'while', 'for'), exception handling blocks ('try') differently while maintaining indentation levels for readability.
        For each element passed as input (either a dictionary or string), it generates PlantUML formatted text according to its type:
        1. If the element is a dictionary with a key starting with "def" or "class", it creates partition blocks with respective names using '@startuml', '@enduml' tags enclosing nested elements after appending required syntax for those constructs ('@partition', 'then', '@endif', etc.).
        2. If the element is just a string type representing variables (e.g., keyword occurrence like if/for loop conditions), it appends them followed by ';' directly as separate nodes in PlantUML representation ('::', ';').
        Hence, 'get_plantUML_element' acts as a core contributor to generate the final PlantUML string returned by 'get_plantUML' function that visually illustrates the program flow based on parsed Python code structure.'
  get_plantUML:
    Inputs:
      Value:
      - control_flow_structure
      Purpose: In the given context, the input 'control_flow_structure' holds significant value when interacting with the function 'get_plantUML'. This parameter represents a list containing elements extracted from a Python program's Abstract Syntax Tree (AST) after parsing and organizing its control flow logic. It consists of strings for keywords like 'def', 'class', representing standalone functions or classes, as well as nested dictionaries for clauses such as 'if', 'while', 'for', 'try', etc., representing various programmatic statements in a structured format. The purpose of passing this organized control flow structure to `get_plantUML` is to convert it into PlantUML notation for visual representation using get_plantUML_element() applied on each element recursively. This process results in a string containing PlantUML code snippet illustrating the program's execution workflow and data dependencies. As `get_plantUML` takes control flow structure as its key argument, it uses these extracted elements to create an easily comprehensible visualization that depicts how different Python statements interconnect during runtime through partitioning blocks with respective indentation levels while generating the graph notation according to PlantUML syntax standards. Thus, 'control_flow_structure' acts as a crucial input bridging code logic into a visually appealing format for understanding complex program flows more intuitively.
    Calls:
      Value:
      - get_plantUML_element
      Purpose: "In the context given, within the function 'get_plantUML' of the 'get_code_graph.py' script, the purpose of invoking 'get_plantUML_element' multiple times iterates through each element in the provided control flow structure list and converts it into PlantUML formatted strings suitable for visualizing code workflow graphically. This recursive action represents various syntax constructs such as functions ('def'), classes ('class'), conditional statements ('if', 'while', 'for'), exception handling blocks ('try') in a structured manner following PlantUML notation standards. Each call to 'get_plantUML_element' generates a formatted string output which adds to the final PlantUML representation accumulated throughout this function until it finishes processing every element within control flow structure before concluding with '@startuml' tag (to denote the diagram initiation) at the beginning and '@enduml' tag (for ending) towards the end. Thus, these calls in 'get_plantUML' collectively create a PlantUML visualization from parsed Python code logic into a comprehensible graphical format for better understanding of program flow. \n\nIn detail for each call made inside 'get_plantUML':\n1. 'get_plantUML_element(element: dict, indentation=\"\")': This call handles elements that are dictionaries in the control flow structure. It parses them considering nested levels and adds keywords or nodes accordingly within PlantUML syntax with appropriate indentations. For instance, it deals with function definitions ('def'), classes ('class') as well as conditional blocks like 'if', 'while', 'for'.\n2. 'get_plantUML_element(element: str)': It manages elements that are plain strings in the control flow structure and converts them into PlantUML format with proper indentations representing keywords such as function names or any simple constructs found outside complex nested structures like above mentioned examples without requiring recursive actions. \nOverall, both call instances collaboratively transform given syntax tokens into visual PlantUML code to portray program logic comprehensively within 'get_plantUML' leading towards creating the desired visual graph of code workflow through abstract descriptions onto PlantUML language understandingably. \n\nIn summary, these calls in 'get_plantUML' contribute significantly by converting complex Python code into a visually appealing PlantUML representation of its control flow diagram using nested recursive invocations to 'get_plantUML_element', catering for various syntax constructs and string elements separately."
    Variables:
      Value:
      - plantuml_str, control_flow_structure
      Purpose: "In the context given from the function 'get_code_graph' resulting in tuple output ('plantuml_str', 'control_flow_structure'), both variables hold significant roles during the PlantUML generation process within the code.\n\n1. 'plantuml_str': This variable specifically focuses on generating PlantUML representation for visualizing the extracted control flow structure of a Python script. Inside the 'get_plantUML' function, it accumulates PlantUML notation starting with '@startuml', followed by recursively calling 'get_plantUML_element()' for each element in the 'control_flow_structure'. Finally, it appends '@enduml' at the end to form a comprehensive PlantUML graph format of Python code logic. Its value becomes helpful when users want visual insights into program flow.\n\n2. 'control_flow_structure': This variable represents the organized control flow structure derived from Python code after segregating imports/globals and rest elements along with executable sequence arrangement in 'reorganize_control_flow' function execution. It consists of a list containing strings for keywords like 'def', 'class', 'if', 'while', etc., as well as nested dictionaries representing partition blocks for different clauses in Python syntax. This structured data acts as an input to generate PlantUML format using 'get_plantUML' function, providing crucial information about program logic flow needed for visualization purposes. \n\nBoth variables collectively help in achieving the objective of presenting code analysis into visually comprehensible representations with 'plantuml_str' enabling PlantUML generation based on controlled programmatic data 'control_flow_structure'."
    Returns:
      Value:
      - plantuml_str
      Purpose: "In the given context, the function 'get_plantUML' resides within the 'get_code_graph' multi-function which is ultimately utilized to extract and format information related to Python file into visualization ready PlantUML representation. Its primary objective lies in generating PlantUML notation depicting the control flow structure extracted from a given Python codebase. Within 'get_plantUML', three significant returns are observed encapsulated within a tuple - ('plantuml_str',). Each element carries unique significance for diverse outcomes within this coding paradigm:\n\n1. ('plantuml_str'): This string return value represents the final formatted PlantUML code generated after concatenating all PlantUML elements derived from control flow structure using 'get_plantUML_element' function on each element in the given list ('control_flow_structure'). It contains visualization instructions for creating a diagrammatic representation of Python program logic using '@startuml', '@enduml' tags at start/end respectively, making it easy to understand and analyze complex code flows.\n\n2. While examining 'get_plantUML', its main role is converting control flow structure into PlantUML notation comprehensively. Each function call within ('get_plantUML') contributes towards this goal:\n   a) '@startuml': Denotes the beginning of PlantUML syntax for diagram generation.\n   b) 'stopuml': Signifies the end of PlantUML code snippet indicating visualization completion.\n\nOverall, these returns from 'get_plantUML' aid in presenting Python program flow as a visually understandable PlantUML diagram that developers can use to analyze complex code structures easily. This visual representation helps in comprehending dependencies between functions, classes, methods, and control statements while identifying potential issues or optimizing the codebase more efficiently. It acts as a crucial output for users seeking graphical insights into their Python scripts' behavior."
  get_code_graph:
    Inputs:
      Value:
      - file_summary, file_ast
      Purpose: 'In the context given for function 'get_code_graph' within the Python script 'get_code_graph.py', two primary inputs are involved when invoking this function - ('file_summary', 'file_ast'). These inputs play significant roles in generating the desired outputs which include code graph representation and control flow structure visualization through PlantUML format.
        1. 'file_summary': This input represents a dictionary containing crucial details about functions ('function_defs') and classes ('class_defs') present within a Python file being analyzed by the script. The keys may consist of either string values referencing definitions or other nested dictionaries carrying more specific details for those elements like inputs, returns, calls, etc. This information is used to construct the code graph representing interdependencies between functions and methods in the Python source code.
        2. 'file_ast': It stands for an Abstract Syntax Tree (AST) generated after parsing the actual Python code using ast library modules. AST acts as a hierarchical representation of source code providing fine granular access to the control flow elements within it, including constructs such as defs ('FunctionDef' nodes), classes ('ClassDef'), loops (while/for statements), conditional statements (if/try blocks), and return values ('Return'). This input is crucial for extracting the program logic into a structured format called 'control_flow_tree'.
        The combination of these inputs enables 'get_code_graph' to perform comprehensive analysis on Python code by building a graphical representation of its structure along with extracting control flow visualization via PlantUML format for ease of comprehension and visual insights about relationships among defined entities while showcasing Python codeflow execution logic. Each element extracted in this process contributes towards generating meaningful outputs - code graph data ('entire_code_graph'), structured control flow representation ('control_flow_structure') and ultimately visualized PlantUML strings portraying program dynamics effectively ('plantUML'). In case of exceptions, appropriate error information will be passed instead. Thus, these inputs collectively help accomplish the overall objective of understanding complex Python code dependencies in a readable manner through graphical and visual means.'
    Calls:
      Value:
      - code_graph, extract_control_flow_tree, reorganize_control_flow, get_plantUML, str
      Purpose: "In the context given for 'get_code_graph.py', these primary functions utilized within 'get_code_graph' play critical roles as mentioned below to generate comprehensive documentation about a Python file by extracting code graph details and presenting them visually through PlantUML notation:\n\n1. code_graph(file_summary): This function creates a directed graph representation of the provided Python file structure focusing on function and class method relationships using networkx DiGraph. It populates lookup dictionaries for functions/classes as nodes in the graph along with edges representing their dependencies. Importantly, it adds metadata to edges by fetching data from node details via helper functions like get_edge_data_from_details() and add_edge_with_data(). The output includes 'nodes' containing graph nodes and 'edges' representing connectivity information.\n\n2. extract_control_flow_tree(nodes: List[ast.AST] : This function parses the Abstract Syntax Tree (AST) nodes into a control flow structure representing Python program logic with keywords like 'def', 'class', 'if', 'while', etc., resulting in a list of strings or nested dictionaries which is crucial for understanding code execution order and control flow.\n\n3. reorganize_control_flow(code_graph, control_flow_structure): This function orders the execution sequence in the control flow graph by starting nodes according to their interconnections in the Python file structure. It segregates imported variables/globals from other elements and organizes them logically into separate parts using depth-first search (dfs_order) while mapping everything back together to a single structured list afterwards. The function's outcome helps in arranging control flow elements for better visualization.\n\n4. get_plantUML(control_flow_structure: List[Union[str, dict]): This call generates PlantUML representation of the entire control flow structure derived from extract_control_flow_tree(). It applies get_plantUML_element() recursively for each element in the given list forming a visual graph notation and wraps '@startuml', '@enduml' tags to provide visual output corresponding to extracted data. These plantUML generated sequences describe programming elements aesthetically within networkx graph details processed from input files, making it easier to comprehend complex code structures.\n\nIn 'get_code_graph(file_summary: dict, file_ast: ast.AST)', these four functions collaborate to achieve the overall goal of combining code graph creation with control flow extraction followed by PlantUML generation while handling exceptions if any occurrence during processing steps. It returns entire graph data ('entireCodeGraph'), structured flow data ('controlFlowStructure') and UML visualization string ('plantUML'). Each call plays a significant role in providing different aspects of code analysis for documentation purposes. Code_graph() handles structural dependencies, extract_control_flow_tree() deals with program logic order, reorganize_control_flow() arranges elements logically, while get_plantUML() converts it into visual PlantUML format. Together they create a comprehensive documentation of Python files' code graph and control flow structure. \n\nThe combination of these calls within 'get_code_graph' allows users to understand complex Python code by breaking down functions, classes, methods interdependencies as well as their execution order visually through PlantUML notation. This helps developers analyze a file thoroughly by transforming the underlying syntax tree into tangible diagrammatic form improving overall program comprehension. Each call acts like puzzle pieces adding functionality needed for producing visualization aid with added advantages such as edge metadata retrieval or structured traversal for organizing elements according to dependencies. \n\nOverall, these calls are significant in simplifying code analysis and offering graphical insights into Python programs while capturing syntactic elements alongside execution orders which assists programmers greatly during debugging, maintenance, or refactoring tasks."
    Variables:
      Value:
      - file_summary, plantUML, entire_code_graph, file_ast, control_flow_structure, control_flow_tree
      Purpose: "In the context of 'get_code_graph' function within 'get_code_graph.py', these variables hold crucial roles during the process of generating a graph representation along with control flow visualization for a given Python file. Their purposes and significance are explained below:\n\n1. file_summary: It represents input dictionary containing essential details about functions ('function_defs' and 'class_defs') within the Python script. This information is used to construct nodes in the code graph indicating function definitions and class methods with their dependencies.\n\n2. plantUML: This variable stores the generated PlantUML representation of the control flow structure created from the given Python file after processing through various functions like 'extract_control_flow_tree', 'reorganize_control_flow', and 'get_plantUML'. It serves as a visual output to understand program logic in graphical format.\n\n3. entire_code_graph: This variable stores the dictionary output from calling 'code_graph' function which creates a directed graph using networkx DiGraph library. It contains nodes (representing functions, classes) and edges along with associated metadata from nodes connections established earlier by exploring the 'file_summary'. Entire_code_graph provides necessary insights about interdependencies among Python entities in the file structure.\n\n4. file_ast: Abstract Syntax Tree parsed from the input Python code using ast library is fed into 'extract_control_flow_tree' to generate control flow elements forming the 'control_flow_tree'. This tree represents the program logic with keywords like 'def', 'class', 'if', etc., extracted as a mix of strings or nested dictionaries for later reordering in execution sequence.\n\n5. control_flow_structure: After organizing execution order and segregating imports/globals part from logic segments during reorganize_control_flow execution, it transforms into one cohesive list comprising all program aspects ordered based on graph starting nodes connection. It aids in building an easily interpretable structure of the Python script flow.\n\nThe primary objective of 'get_code_graph' is to combine these variables' outcomes by generating code graph using 'code_graph', extracting control flow through 'extract_control_flow_tree', organizing it with 'reorganize_control_flow', and finally visualizing the same in PlantUML format via 'get_plantUML'. These inputs together facilitate a comprehensive analysis of Python file dependencies, structure, and visual representation for better code comprehension. Additionally, 'try...' blocks manage exception occurrences returning whole graph data ('entire_code_graph'), structured flow details ('control_flow_structure') and PlantUML string ('plantUML'). \n\nIn summary, these variables act as key intermediates in transforming raw code input to valuable information - Graph Representation ('entire_code_graph') accompanied by program structure comprehension in 'plantUML' formatting. This overall enhances the code debugging & documentation experience providing detailed insight into the script structure along with an effective visual presentation for program understanding."
    Returns:
      Value:
      - (entire_code_graph, control_flow_structure, plantUML)
      Purpose: 'The returns from the `get_code_graph` function hold significant values in producing visualizable representation as well as insights for further analyses from the input Python file summarized with 'file_summary' dictionary and its Abstract Syntax Tree ('file_ast') extracted using ast library. These three outputs collectively provide comprehensive information about the code structure:
        1. 'entire_code_graph': A dictionary format containing a directed graph representation of Python file details such as functions, classes, methods interdependencies built using networkx DiGraph library. This helps in understanding the program's logical flow at a high level by representing nodes (functions/classes) and their connections through edges with metadata attached to them.
        2. 'control_flow_structure': It represents the extracted control flow tree from Python code as parsed Abstract Syntax Tree ('file_ast'), structured as a list containing strings for keywords like 'def', 'class', 'if', 'while', 'for', 'try' etc., along with nested dictionaries to explain specific logical divisions. This portion sheds light on decision constructs within the code helping identify looping statements, exception handling blocks, and partitioned sections like try/catch mechanisms.
        3. 'plantUML': The third output is a generated PlantUML representation of the entire control flow structure obtained from step 2 using `get_plantUML` function call. This string contains visual notations representing program elements as per PlantUML language standard enabling developers to understand the code flow through diagrams using specific graphical indicators such as ellipses (partition boxes for if, while, for loops), arrows depicting data movement, and distinct symbols denoting functions, classes etc. Developers can import this string into PlantUML software tools to visualize the Python program's logical flowchart.
        In summary, these three returns ('entire_code_graph', 'control_flow_structure', and 'plantUML') jointly equip one with the structural data as well as visual representations of a Python file's code graph and its control flow logic for better comprehension and debugging purposes.'