file_info:
  file_code: "\"\"\"\nFor each Python file within a given directory, this module is\
    \ designed to generate, save, \nand return datasets that include responses to\
    \ questions about the code. \nRequirements:\n[req00] The process_single_python_file\
    \ function shall:\n    a. Accept parameters for Python file path, start directory,\
    \ model config \n       pathname, questions dict, use of LLM, and output dir.\n\
    \    b. If 'use_llm' is True, use 'get_model' to instantiate LLM model config.\n\
    \    c. Use 'get_python_file_details' to retrieve Python file info.\n    d. Use\
    \ 'get_python_datasets' to acquire instruct.json datasets.\n    e. Use 'save_python_data'\
    \ to store file details and instruct.json data.\n[req01] The py2dataset function\
    \ shall:\n    a. Accept parameters for start directory, output dir, questions\
    \ path, model\n       config path, use of LLM, and quiet mode.\n    b. Adjust\
    \ logging level based on 'quiet'.\n    c. Use current working dir if no valid\
    \ start dir is provided.\n    d. Get output dir with 'get_output_dir'.\n    e.\
    \ Retrieve questions dict with 'get_questions'.\n    f. Search for Python files\
    \ using 'rglob', excluding those starting with \"_\".\n    g. For each Python\
    \ file, spawn a child process with 'process_single_python_file'\n       to get\
    \ file details and instruct.json data, if single_process is False.\n    h. Combine\
    \ instruct.json files with 'combine_json_files'.\n    i. Return datasets.\n[req02]\
    \ The clone_github_repo function shall:\n    a. Accept a url.\n    b. Clone repository\
    \ or fetch the latest changes.\n    c. Return local repository path.\n[req03]\
    \ The main function shall:\n    a. Accept and process command-line args.\n   \
    \ b. Determine py2dataset parameters based on processed arguments.\n    c. Call\
    \ py2dataset with derived parameters.\n\"\"\"\nimport sys\nimport logging\nfrom\
    \ pathlib import Path\nfrom typing import Dict, List\nfrom multiprocessing import\
    \ Process\nimport subprocess\nimport os\nimport git\nimport shlex\n\nfrom get_python_file_details\
    \ import get_python_file_details\nfrom get_python_datasets import get_python_datasets\n\
    from get_params import (\n    get_questions,\n    get_model,\n    get_output_dir,\n\
    \    get_start_dir,\n)\nfrom save_output import combine_json_files, save_python_data\n\
    \n\ndef process_single_python_file(\n    python_pathname: str,\n    relative_path:\
    \ Path,\n    output_dir: str,\n    model_config_pathname: str,\n    questions:\
    \ Dict,\n    use_llm: bool,\n    model_config: Dict,\n    detailed: bool,\n) ->\
    \ None:\n    \"\"\"\n    Processes a single Python file to generate question-answer\
    \ pairs and instructions.\n    Args:\n        python_pathname (str): Path to the\
    \ Python file.\n        start (str): Starting directory for Python files.\n  \
    \      output_dir (str): Directory to write the output files.\n        model_config_pathname\
    \ (str): Path and filename of the model configuration file.\n        questions\
    \ (Dict): Dictionary of questions to answer about the Python file.\n        use_llm\
    \ (bool): Use llm to answer code purpose question.\n        model_config (Dict):\
    \ Configuration dictionary for the LLM.\n        detailed (bool): Perform detailed\
    \ analysis if True.\n    \"\"\"\n    logging.info(f\"Processing file: {python_pathname}\"\
    )\n    if model_config is None and use_llm:\n        model_config = get_model(model_config_pathname)\n\
    \n    file_details = get_python_file_details(python_pathname)\n    if not file_details:\n\
    \        logging.error(f\"Failed to get file details for {python_pathname}\")\n\
    \        return\n\n    instruct_data = get_python_datasets(\n        python_pathname,\n\
    \        file_details,\n        relative_path,\n        questions,\n        model_config,\n\
    \        detailed,\n    )\n\n    if instruct_data:\n        save_python_data(file_details,\
    \ instruct_data, relative_path, output_dir)\n    else:\n        logging.error(f\"\
    Failed getting {python_pathname} dataset\")\n\n    del instruct_data, file_details,\
    \ model_config\n\n\ndef py2dataset(\n    start: str = \"\",\n    output_dir: str\
    \ = \"\",\n    questions_pathname: str = \"\",\n    model_config_pathname: str\
    \ = \"\",\n    use_llm: bool = False,\n    quiet: bool = False,\n    single_process:\
    \ bool = False,\n    detailed: bool = False,\n    html: bool = False,\n    skip_regen:\
    \ bool = False,\n) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Generates datasets\
    \ by processing Python files within a specified directory.\n    Args:\n      \
    \  start (str, optional): Starting directory for Python files or GitHub repository\
    \ Python files. Default: current working directory.\n        output_dir (str,\
    \ optional): Directory to write the output files. Default: ./dataset/.\n     \
    \   questions_pathname (str, optional): Path and filename of the questions file.\
    \ Default: ./py2dataset_questions.json.\n        model_config_pathname (str, optional):\
    \ Path and filename of the model configuration file. Default: ./py2dataset_model_config.yaml.\n\
    \        use_llm (bool, optional): Use llm to answer code purpose question. Default:\
    \ False.\n        quiet (bool, optional): Limit logging output. Default: False.\n\
    \        single_process (bool, optional): Use a single process to process Python\
    \ files if --use_llm. Default: False.\n        detailed (bool, optional): Include\
    \ detailed analysis. Default: False.\n        html (bool, optional): Generate\
    \ HTML output. Default: False.\n        skip_regen (bool, optional): Skip regeneration\
    \ of existing instruct.json files. Default: False.\n    Returns:\n        Dict[str,\
    \ List[Dict]]: Generated datasets.\n    \"\"\"\n    if quiet:\n        logging.getLogger().setLevel(logging.WARNING)\n\
    \    else:\n        logging.getLogger().setLevel(logging.INFO)\n\n    sys.setrecursionlimit(3000)\
    \  # Set recursion limit higher for AST parsing\n\n    model_config = None\n \
    \   if use_llm and single_process:\n        model_config = get_model(model_config_pathname)\n\
    \n    params = {\n        \"python_pathname\": \"\",\n        \"relative_path\"\
    : \"\",\n        \"output_dir\": get_output_dir(output_dir),\n        \"model_config_pathname\"\
    : model_config_pathname,\n        \"questions\": get_questions(questions_pathname),\n\
    \        \"use_llm\": use_llm,\n        \"model_config\": model_config,\n    \
    \    \"detailed\": detailed,\n    }\n\n    for python_pathname in Path(start).rglob(\"\
    *.py\"):\n        \n        if \"__pycache__\" in python_pathname.parts:\n   \
    \         continue\n        if python_pathname.name == \"__init__.py\":\n    \
    \        continue\n        \n        params[\"python_pathname\"] = str(python_pathname)\n\
    \        params[\"relative_path\"] = Path(\n            os.path.relpath(python_pathname,\
    \ os.path.dirname(get_start_dir(start)))\n        )\n\n        # determine if\
    \ corresponding instruct.json exists and skip if skip_regen\n        base_pathname\
    \ = Path(params[\"output_dir\"]) / params[\"relative_path\"]\n        instruct_pathname\
    \ = base_pathname.with_suffix(\".py.instruct.json\")\n        if instruct_pathname.exists()\
    \ and skip_regen:\n            continue\n        \n        # process each python\
    \ file in a separate process to manage memory\n        if params[\"model_config\"\
    ] is None and params[\"use_llm\"]:\n            proc = Process(target=process_single_python_file,\
    \ kwargs=params)\n            proc.start()\n            proc.join()\n        else:\
    \  # or process all files using use a single process\n            process_single_python_file(**params)\n\
    \n    return combine_json_files(output_dir, html, params[\"questions\"])\n\n\n\
    def clone_github_repo(url: str) -> str:\n    \"\"\"\n    Clone repository or fetch\
    \ the latest changes and return local repository path.\n    Args:\n        url\
    \ (str): The url of the github repository.\n    Returns:\n        str: The path\
    \ to the cloned repository.\n    \"\"\"\n    try:\n        command = f\"git ls-remote\
    \ {shlex.quote(url)}\"\n        subprocess.run(\n            command,\n      \
    \      shell=True,\n            check=True,\n            stdout=subprocess.DEVNULL,\n\
    \            stderr=subprocess.DEVNULL,\n        )\n        repo_name = url.split(\"\
    /\")[-1]\n        githubrepos_dir = os.path.join(os.getcwd(), \"githubrepos\"\
    )\n        os.makedirs(githubrepos_dir, exist_ok=True)\n        path = os.path.join(githubrepos_dir,\
    \ repo_name)\n        if not os.path.exists(path):\n            git.Repo.clone_from(url,\
    \ path)\n        else:\n            repo = git.Repo(path)\n            with repo.git.custom_environment(\n\
    \                GIT_SSH_COMMAND=\"ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no\"\
    \n            ):\n                repo.git.fetch()\n                default_branch\
    \ = repo.head.reference.tracking_branch().remote_head\n                repo.git.reset(\"\
    --hard\", default_branch)\n    except subprocess.CalledProcessError:\n       \
    \ logging.info(f\"Invalid or inaccessible repository: {url}\")\n        path =\
    \ \"\"\n\n    return path\n\n\ndef main():\n    \"\"\"\n    Command-line entry\
    \ point for processing Python files and generating datasets.\n    Optional command-line\
    \ arguments:\n    --start (str, optional): Starting directory for Python files\
    \ or GitHub repository Python files. Default: cwd.\n    --output_dir (str, optional):\
    \ Directory to write the output files. Default: ./dataset/.\n    --questions_pathname\
    \ (str, optional): Path and filename of the questions file. Default: ./py2dataset_questions.json.\n\
    \    --model_config_pathname (str, optional): Path and filename of the model configuration\
    \ file. Default: ./py2dataset_model_config.yaml.\n    --use_llm (bool, optional):\
    \ Use llm to answer code purpose question. Default: False.\n    --quiet (bool,\
    \ optional): Limit logging output. Default: False.\n    --single_process (bool,\
    \ optional): Use a single process to process Python files if --use_llm. Default:\
    \ False.\n    --detailed (bool, optional): Include detailed analysis. Default:\
    \ False.\n    --html (bool, optional): Generate HTML output. Default: False.\n\
    \    --I (str, optional): Enable interactive mode. Default: False.\n    --skip_regen\
    \ (str, optional): Skip regeneration of existing instruct.json files. Default:\
    \ False.\n    --help: Display help message.\n    \"\"\"\n    if \"--help\" in\
    \ sys.argv:\n        print(__doc__)\n        sys.exit()\n\n    # return boolean\
    \ value based on the user input\n    def get_bool_from_input(input_str: str, current_value:\
    \ bool) -> bool:\n        if input_str.lower() in [\"t\", \"true\", \"y\", \"\
    yes\"]:\n            return True\n        elif input_str.lower() in [\"f\", \"\
    false\", \"n\", \"no\"]:\n            return False\n        return current_value\n\
    \n    # Defaults\n    params = {\n        \"start\": \".\",\n        \"output_dir\"\
    : \"./dataset/\",\n        \"questions_pathname\": \"./py2dataset_questions.json\"\
    ,\n        \"model_config_pathname\": \"./py2dataset_model_config.yaml\",\n  \
    \      \"use_llm\": False,\n        \"quiet\": False,\n        \"single_process\"\
    : False,\n        \"detailed\": False,\n        \"html\": False,\n        \"skip_regen\"\
    : False,\n        \"I\": False,\n    }\n\n    arg_string = \" \".join(sys.argv[1:])\n\
    \    for arg in params:  # parse command-line arguments\n        if \"--\" + arg\
    \ in arg_string:\n            if isinstance(params[arg], bool):\n            \
    \    params[arg] = True\n                arg_string = arg_string.replace(\"--\"\
    \ + arg, \"\")\n            else:\n                value_segment = arg_string.split(\"\
    --\" + arg + \" \")[1]\n                params[arg] = value_segment.split(\" --\"\
    )[0].strip('\"')\n                arg_string = arg_string.replace(\"--\" + arg\
    \ + \" \" + params[arg], \"\")\n\n    if params[\"I\"]:  # query user for parameters\
    \ to change\n        print(\"Interactive mode, enter new values or press enter\
    \ to keep.\")\n        for arg in params:\n            if arg != \"I\":\n    \
    \            user_input = input(f\"{arg} [{params[arg]}]: \").strip()\n      \
    \          if isinstance(params[arg], bool):\n                    params[arg]\
    \ = get_bool_from_input(user_input, params[arg])\n                elif user_input:\n\
    \                    params[arg] = user_input\n                print(f\"{arg}:\
    \ {params[arg]}\")\n    params.pop(\"I\")\n\n    if params[\"start\"].startswith(\"\
    https://github.com/\"):\n        params[\"start\"] = clone_github_repo(params[\"\
    start\"])\n    elif not os.path.isdir(params[\"start\"]):\n        print(f\"'{params['start']}'\
    \ Invalid. Using current working directory.\")\n        params[\"start\"] = os.getcwd()\n\
    \n    py2dataset(**params)\n\n\nif __name__ == \"__main__\":\n    main()\n"
  file_dependencies:
  - multiprocessing
  - get_python_datasets
  - sys
  - logging
  - get_params
  - git
  - pathlib
  - typing
  - save_output
  - subprocess
  - os
  - get_python_file_details
  - shlex
  file_functions:
  - process_single_python_file
  - py2dataset
  - clone_github_repo
  - main
  - get_bool_from_input
  file_classes: []
  file_constants: []
  file_summary: '{dependencies: [multiprocessing, get_python_datasets, sys, logging,
    get_params, git, pathlib, typing, save_output, subprocess, os, get_python_file_details,
    shlex], function_defs: [{process_single_python_file: {inputs: [python_pathname,
    relative_path, output_dir, model_config_pathname, questions, use_llm, model_config,
    detailed], calls: [logging.info, get_model, get_python_file_details, logging.error,
    get_python_datasets, save_python_data], call_inputs: {logging.info: [f''Processing
    file: {python_pathname}''], get_model: [model_config_pathname], get_python_file_details:
    [python_pathname], logging.error: [f''Failed to get file details for {python_pathname}'',
    f''Failed getting {python_pathname} dataset''], get_python_datasets: [python_pathname,
    file_details, relative_path, questions, model_config, detailed], save_python_data:
    [file_details, instruct_data, relative_path, output_dir]}, returns: [None]}},
    {py2dataset: {inputs: [start, output_dir, questions_pathname, model_config_pathname,
    use_llm, quiet, single_process, detailed, html, skip_regen], calls: [logging.getLogger().setLevel,
    logging.getLogger, sys.setrecursionlimit, get_model, get_output_dir, get_questions,
    Path(start).rglob, Path, str, os.path.relpath, os.path.dirname, get_start_dir,
    base_pathname.with_suffix, instruct_pathname.exists, Process, proc.start, proc.join,
    process_single_python_file, combine_json_files], call_inputs: {logging.getLogger().setLevel:
    [logging.WARNING, logging.INFO], logging.getLogger: [], sys.setrecursionlimit:
    [3000], get_model: [model_config_pathname], get_output_dir: [output_dir], get_questions:
    [questions_pathname], Path(start).rglob: [''*.py''], Path: [start, os.path.relpath(python_pathname,
    os.path.dirname(get_start_dir(start))), params[''output_dir'']], str: [python_pathname],
    os.path.relpath: [python_pathname, os.path.dirname(get_start_dir(start))], os.path.dirname:
    [get_start_dir(start)], get_start_dir: [start], base_pathname.with_suffix: [''.py.instruct.json''],
    instruct_pathname.exists: [], Process: [], proc.start: [], proc.join: [], process_single_python_file:
    [], combine_json_files: [output_dir, html, params[''questions'']]}, returns: [combine_json_files(output_dir,
    html, params[''questions''])]}}, {clone_github_repo: {inputs: [url], calls: [shlex.quote,
    subprocess.run, url.split, os.path.join, os.getcwd, os.makedirs, os.path.exists,
    git.Repo.clone_from, git.Repo, repo.git.custom_environment, repo.git.fetch, repo.head.reference.tracking_branch,
    repo.git.reset, logging.info], call_inputs: {shlex.quote: [url], subprocess.run:
    [command], url.split: [''/''], os.path.join: [os.getcwd(), ''githubrepos'', githubrepos_dir,
    repo_name], os.getcwd: [], os.makedirs: [githubrepos_dir], os.path.exists: [path],
    git.Repo.clone_from: [url, path], git.Repo: [path], repo.git.custom_environment:
    [], repo.git.fetch: [], repo.head.reference.tracking_branch: [], repo.git.reset:
    [''--hard'', default_branch], logging.info: [f''Invalid or inaccessible repository:
    {url}'']}, returns: [path]}}, {main: {inputs: [], calls: [print, sys.exit, input_str.lower,
    '' ''.join, isinstance, arg_string.replace, arg_string.split, value_segment.split(''
    --'')[0].strip, value_segment.split, input(f''{arg} [{params[arg]}]: '').strip,
    input, get_bool_from_input, params.pop, params[''start''].startswith, clone_github_repo,
    os.path.isdir, os.getcwd, py2dataset], call_inputs: {print: [__doc__, ''Interactive
    mode, enter new values or press enter to keep.'', f''{arg}: {params[arg]}'', f\''{params[''start'']}''
    Invalid. Using current working directory.\], sys.exit: [], input_str.lower: [],
    '' ''.join: [sys.argv[1:]], isinstance: [params[arg], bool, params[arg], bool],
    arg_string.replace: [''--'' + arg, '''', ''--'' + arg + '' '' + params[arg], ''''],
    arg_string.split: [''--'' + arg + '' ''], value_segment.split('' --'')[0].strip:
    [''\''], value_segment.split: ['' --''], input(f''{arg} [{params[arg]}]: '').strip:
    [], input: [f''{arg} [{params[arg]}]: ''], get_bool_from_input: [user_input, params[arg]],
    params.pop: [''I''], params[''start''].startswith: [''https://github.com/''],
    clone_github_repo: [params[''start'']], os.path.isdir: [params[''start'']], os.getcwd:
    [], py2dataset: []}, returns: [current_value, True, False]}}, {get_bool_from_input:
    {inputs: [input_str, current_value], calls: [input_str.lower], call_inputs: {input_str.lower:
    []}, returns: [current_value, True, False]}}], class_defs: []}'
  file_code_simplified: "import sys\nimport logging\nfrom pathlib import Path\nfrom\
    \ typing import Dict, List\nfrom multiprocessing import Process\nimport subprocess\n\
    import os\nimport git\nimport shlex\nfrom get_python_file_details import get_python_file_details\n\
    from get_python_datasets import get_python_datasets\nfrom get_params import get_questions,\
    \ get_model, get_output_dir, get_start_dir\nfrom save_output import combine_json_files,\
    \ save_python_data\n\ndef process_single_python_file(python_pathname: str, relative_path:\
    \ Path, output_dir: str, model_config_pathname: str, questions: Dict, use_llm:\
    \ bool, model_config: Dict, detailed: bool) -> None:\n    logging.info(f'Processing\
    \ file: {python_pathname}')\n    if model_config is None and use_llm:\n      \
    \  model_config = get_model(model_config_pathname)\n    file_details = get_python_file_details(python_pathname)\n\
    \    if not file_details:\n        logging.error(f'Failed to get file details\
    \ for {python_pathname}')\n        return\n    instruct_data = get_python_datasets(python_pathname,\
    \ file_details, relative_path, questions, model_config, detailed)\n    if instruct_data:\n\
    \        save_python_data(file_details, instruct_data, relative_path, output_dir)\n\
    \    else:\n        logging.error(f'Failed getting {python_pathname} dataset')\n\
    \    del instruct_data, file_details, model_config\n\ndef py2dataset(start: str='',\
    \ output_dir: str='', questions_pathname: str='', model_config_pathname: str='',\
    \ use_llm: bool=False, quiet: bool=False, single_process: bool=False, detailed:\
    \ bool=False, html: bool=False, skip_regen: bool=False) -> Dict[str, List[Dict]]:\n\
    \    if quiet:\n        logging.getLogger().setLevel(logging.WARNING)\n    else:\n\
    \        logging.getLogger().setLevel(logging.INFO)\n    sys.setrecursionlimit(3000)\n\
    \    model_config = None\n    if use_llm and single_process:\n        model_config\
    \ = get_model(model_config_pathname)\n    params = {'python_pathname': '', 'relative_path':\
    \ '', 'output_dir': get_output_dir(output_dir), 'model_config_pathname': model_config_pathname,\
    \ 'questions': get_questions(questions_pathname), 'use_llm': use_llm, 'model_config':\
    \ model_config, 'detailed': detailed}\n    for python_pathname in Path(start).rglob('*.py'):\n\
    \        if '__pycache__' in python_pathname.parts:\n            continue\n  \
    \      if python_pathname.name == '__init__.py':\n            continue\n     \
    \   params['python_pathname'] = str(python_pathname)\n        params['relative_path']\
    \ = Path(os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start))))\n\
    \        base_pathname = Path(params['output_dir']) / params['relative_path']\n\
    \        instruct_pathname = base_pathname.with_suffix('.py.instruct.json')\n\
    \        if instruct_pathname.exists() and skip_regen:\n            continue\n\
    \        if params['model_config'] is None and params['use_llm']:\n          \
    \  proc = Process(target=process_single_python_file, kwargs=params)\n        \
    \    proc.start()\n            proc.join()\n        else:\n            process_single_python_file(**params)\n\
    \    return combine_json_files(output_dir, html, params['questions'])\n\ndef clone_github_repo(url:\
    \ str) -> str:\n    try:\n        command = f'git ls-remote {shlex.quote(url)}'\n\
    \        subprocess.run(command, shell=True, check=True, stdout=subprocess.DEVNULL,\
    \ stderr=subprocess.DEVNULL)\n        repo_name = url.split('/')[-1]\n       \
    \ githubrepos_dir = os.path.join(os.getcwd(), 'githubrepos')\n        os.makedirs(githubrepos_dir,\
    \ exist_ok=True)\n        path = os.path.join(githubrepos_dir, repo_name)\n  \
    \      if not os.path.exists(path):\n            git.Repo.clone_from(url, path)\n\
    \        else:\n            repo = git.Repo(path)\n            with repo.git.custom_environment(GIT_SSH_COMMAND='ssh\
    \ -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'):\n           \
    \     repo.git.fetch()\n                default_branch = repo.head.reference.tracking_branch().remote_head\n\
    \                repo.git.reset('--hard', default_branch)\n    except subprocess.CalledProcessError:\n\
    \        logging.info(f'Invalid or inaccessible repository: {url}')\n        path\
    \ = ''\n    return path\n\ndef main():\n    if '--help' in sys.argv:\n       \
    \ print(__doc__)\n        sys.exit()\n\n    def get_bool_from_input(input_str:\
    \ str, current_value: bool) -> bool:\n        if input_str.lower() in ['t', 'true',\
    \ 'y', 'yes']:\n            return True\n        elif input_str.lower() in ['f',\
    \ 'false', 'n', 'no']:\n            return False\n        return current_value\n\
    \    params = {'start': '.', 'output_dir': './dataset/', 'questions_pathname':\
    \ './py2dataset_questions.json', 'model_config_pathname': './py2dataset_model_config.yaml',\
    \ 'use_llm': False, 'quiet': False, 'single_process': False, 'detailed': False,\
    \ 'html': False, 'skip_regen': False, 'I': False}\n    arg_string = ' '.join(sys.argv[1:])\n\
    \    for arg in params:\n        if '--' + arg in arg_string:\n            if\
    \ isinstance(params[arg], bool):\n                params[arg] = True\n       \
    \         arg_string = arg_string.replace('--' + arg, '')\n            else:\n\
    \                value_segment = arg_string.split('--' + arg + ' ')[1]\n     \
    \           params[arg] = value_segment.split(' --')[0].strip('\"')\n        \
    \        arg_string = arg_string.replace('--' + arg + ' ' + params[arg], '')\n\
    \    if params['I']:\n        print('Interactive mode, enter new values or press\
    \ enter to keep.')\n        for arg in params:\n            if arg != 'I':\n \
    \               user_input = input(f'{arg} [{params[arg]}]: ').strip()\n     \
    \           if isinstance(params[arg], bool):\n                    params[arg]\
    \ = get_bool_from_input(user_input, params[arg])\n                elif user_input:\n\
    \                    params[arg] = user_input\n                print(f'{arg}:\
    \ {params[arg]}')\n    params.pop('I')\n    if params['start'].startswith('https://github.com/'):\n\
    \        params['start'] = clone_github_repo(params['start'])\n    elif not os.path.isdir(params['start']):\n\
    \        print(f\"'{params['start']}' Invalid. Using current working directory.\"\
    )\n        params['start'] = os.getcwd()\n    py2dataset(**params)\nif __name__\
    \ == '__main__':\n    main()"
  entire_code_graph:
    nodes:
    - process_single_python_file
    - py2dataset
    - clone_github_repo
    - main
    - get_bool_from_input
    - logging.info
    - get_model
    - get_python_file_details
    - logging.error
    - get_python_datasets
    - save_python_data
    - logging.getLogger().setLevel
    - logging.getLogger
    - sys.setrecursionlimit
    - get_output_dir
    - get_questions
    - Path(start).rglob
    - Path
    - str
    - os.path.relpath
    - os.path.dirname
    - get_start_dir
    - base_pathname.with_suffix
    - instruct_pathname.exists
    - Process
    - proc.start
    - proc.join
    - combine_json_files
    - shlex.quote
    - subprocess.run
    - url.split
    - os.path.join
    - os.getcwd
    - os.makedirs
    - os.path.exists
    - git.Repo.clone_from
    - git.Repo
    - repo.git.custom_environment
    - repo.git.fetch
    - repo.head.reference.tracking_branch
    - repo.git.reset
    - print
    - sys.exit
    - input_str.lower
    - ''' ''.join'
    - isinstance
    - arg_string.replace
    - arg_string.split
    - value_segment.split(' --')[0].strip
    - value_segment.split
    - 'input(f''{arg} [{params[arg]}]: '').strip'
    - input
    - params.pop
    - params['start'].startswith
    - os.path.isdir
    edges:
    - source: process_single_python_file
      target: logging.info
      target_inputs:
      - 'f''Processing file: {python_pathname}'''
    - source: process_single_python_file
      target: get_model
      target_inputs:
      - model_config_pathname
    - source: process_single_python_file
      target: get_python_file_details
      target_inputs:
      - python_pathname
    - source: process_single_python_file
      target: logging.error
      target_inputs:
      - f'Failed to get file details for {python_pathname}'
      - f'Failed getting {python_pathname} dataset'
    - source: process_single_python_file
      target: get_python_datasets
      target_inputs:
      - python_pathname
      - file_details
      - relative_path
      - questions
      - model_config
      - detailed
    - source: process_single_python_file
      target: save_python_data
      target_inputs:
      - file_details
      - instruct_data
      - relative_path
      - output_dir
    - source: py2dataset
      target: logging.getLogger().setLevel
      target_inputs:
      - logging.WARNING
      - logging.INFO
    - source: py2dataset
      target: logging.getLogger
      target_inputs: []
    - source: py2dataset
      target: sys.setrecursionlimit
      target_inputs:
      - '3000'
    - source: py2dataset
      target: get_model
      target_inputs:
      - model_config_pathname
    - source: py2dataset
      target: get_output_dir
      target_inputs:
      - output_dir
    - source: py2dataset
      target: get_questions
      target_inputs:
      - questions_pathname
    - source: py2dataset
      target: Path(start).rglob
      target_inputs:
      - '''*.py'''
    - source: py2dataset
      target: Path
      target_inputs:
      - start
      - os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start)))
      - params['output_dir']
    - source: py2dataset
      target: str
      target_inputs:
      - python_pathname
    - source: py2dataset
      target: os.path.relpath
      target_inputs:
      - python_pathname
      - os.path.dirname(get_start_dir(start))
    - source: py2dataset
      target: os.path.dirname
      target_inputs:
      - get_start_dir(start)
    - source: py2dataset
      target: get_start_dir
      target_inputs:
      - start
    - source: py2dataset
      target: base_pathname.with_suffix
      target_inputs:
      - '''.py.instruct.json'''
    - source: py2dataset
      target: instruct_pathname.exists
      target_inputs: []
    - source: py2dataset
      target: Process
      target_inputs: []
    - source: py2dataset
      target: proc.start
      target_inputs: []
    - source: py2dataset
      target: proc.join
      target_inputs: []
    - source: py2dataset
      target: process_single_python_file
      target_inputs: []
      target_returns:
      - None
    - source: py2dataset
      target: combine_json_files
      target_inputs:
      - output_dir
      - html
      - params['questions']
    - source: clone_github_repo
      target: shlex.quote
      target_inputs:
      - url
    - source: clone_github_repo
      target: subprocess.run
      target_inputs:
      - command
    - source: clone_github_repo
      target: url.split
      target_inputs:
      - '''/'''
    - source: clone_github_repo
      target: os.path.join
      target_inputs:
      - os.getcwd()
      - '''githubrepos'''
      - githubrepos_dir
      - repo_name
    - source: clone_github_repo
      target: os.getcwd
      target_inputs: []
    - source: clone_github_repo
      target: os.makedirs
      target_inputs:
      - githubrepos_dir
    - source: clone_github_repo
      target: os.path.exists
      target_inputs:
      - path
    - source: clone_github_repo
      target: git.Repo.clone_from
      target_inputs:
      - url
      - path
    - source: clone_github_repo
      target: git.Repo
      target_inputs:
      - path
    - source: clone_github_repo
      target: repo.git.custom_environment
      target_inputs: []
    - source: clone_github_repo
      target: repo.git.fetch
      target_inputs: []
    - source: clone_github_repo
      target: repo.head.reference.tracking_branch
      target_inputs: []
    - source: clone_github_repo
      target: repo.git.reset
      target_inputs:
      - '''--hard'''
      - default_branch
    - source: clone_github_repo
      target: logging.info
      target_inputs:
      - 'f''Invalid or inaccessible repository: {url}'''
    - source: main
      target: print
      target_inputs:
      - __doc__
      - '''Interactive mode, enter new values or press enter to keep.'''
      - 'f''{arg}: {params[arg]}'''
      - f"'{params['start']}' Invalid. Using current working directory."
    - source: main
      target: sys.exit
      target_inputs: []
    - source: main
      target: input_str.lower
      target_inputs: []
    - source: main
      target: ''' ''.join'
      target_inputs:
      - sys.argv[1:]
    - source: main
      target: isinstance
      target_inputs:
      - params[arg]
      - bool
      - params[arg]
      - bool
    - source: main
      target: arg_string.replace
      target_inputs:
      - '''--'' + arg'
      - ''''''
      - '''--'' + arg + '' '' + params[arg]'
      - ''''''
    - source: main
      target: arg_string.split
      target_inputs:
      - '''--'' + arg + '' '''
    - source: main
      target: value_segment.split(' --')[0].strip
      target_inputs:
      - '''"'''
    - source: main
      target: value_segment.split
      target_inputs:
      - ''' --'''
    - source: main
      target: 'input(f''{arg} [{params[arg]}]: '').strip'
      target_inputs: []
    - source: main
      target: input
      target_inputs:
      - 'f''{arg} [{params[arg]}]: '''
    - source: main
      target: get_bool_from_input
      target_inputs:
      - user_input
      - params[arg]
      target_returns:
      - 'False'
      - 'True'
      - current_value
    - source: main
      target: params.pop
      target_inputs:
      - '''I'''
    - source: main
      target: params['start'].startswith
      target_inputs:
      - '''https://github.com/'''
    - source: main
      target: clone_github_repo
      target_inputs:
      - params['start']
      target_returns:
      - path
    - source: main
      target: os.path.isdir
      target_inputs:
      - params['start']
    - source: main
      target: os.getcwd
      target_inputs: []
    - source: main
      target: py2dataset
      target_inputs: []
      target_returns:
      - combine_json_files(output_dir, html, params['questions'])
    - source: get_bool_from_input
      target: input_str.lower
      target_inputs: []
  control_flow_structure:
  - def main():
    - if '--help' in sys.argv:
      - print(__doc__)
      - sys.exit()
    - 'def get_bool_from_input(input_str: str, current_value: bool)':
      - if input_str.lower() in ['t', 'true', 'y', 'yes']:
        - return:
          - 'True'
        elif input_str.lower() in ['f', 'false', 'n', 'no']:
        - return:
          - 'False'
      - return:
        - current_value
    - 'params = {''start'': ''.'', ''output_dir'': ''./dataset/'', ''questions_pathname'':
      ''./py2dataset_questions.json'', ''model_config_pathname'': ''./py2dataset_model_config.yaml'',
      ''use_llm'': False, ''quiet'': False, ''single_process'': False, ''detailed'':
      False, ''html'': False, ''skip_regen'': False, ''I'': False}'
    - arg_string = ' '.join(sys.argv[1:])
    - for arg in params:
      - if '--' + arg in arg_string:
        - if isinstance(params[arg], bool):
          - params[arg] = True
          - arg_string = arg_string.replace('--' + arg, '')
          else:
          - value_segment = arg_string.split('--' + arg + ' ')[1]
          - params[arg] = value_segment.split(' --')[0].strip('"')
          - arg_string = arg_string.replace('--' + arg + ' ' + params[arg], '')
    - if params['I']:
      - print('Interactive mode, enter new values or press enter to keep.')
      - for arg in params:
        - if arg != 'I':
          - 'user_input = input(f''{arg} [{params[arg]}]: '').strip()'
          - if isinstance(params[arg], bool):
            - params[arg] = get_bool_from_input(user_input, params[arg])
            elif user_input:
            - params[arg] = user_input
          - 'print(f''{arg}: {params[arg]}'')'
    - params.pop('I')
    - if params['start'].startswith('https://github.com/'):
      - params['start'] = clone_github_repo(params['start'])
      elif not os.path.isdir(params['start']):
      - print(f"'{params['start']}' Invalid. Using current working directory.")
      - params['start'] = os.getcwd()
    - py2dataset(**params)
  - if __name__ == '__main__':
    - main()
  - import sys
  - import logging
  - from pathlib import Path
  - from typing import Dict, List
  - from multiprocessing import Process
  - import subprocess
  - import os
  - import git
  - import shlex
  - from get_python_file_details import get_python_file_details
  - from get_python_datasets import get_python_datasets
  - from get_params import get_questions, get_model, get_output_dir, get_start_dir
  - from save_output import combine_json_files, save_python_data
  - ? 'def process_single_python_file(python_pathname: str, relative_path: Path, output_dir:
      str, model_config_pathname: str, questions: Dict, use_llm: bool, model_config:
      Dict, detailed: bool)'
    : - 'logging.info(f''Processing file: {python_pathname}'')'
      - if model_config is None and use_llm:
        - model_config = get_model(model_config_pathname)
      - file_details = get_python_file_details(python_pathname)
      - if not file_details:
        - logging.error(f'Failed to get file details for {python_pathname}')
        - return: []
      - instruct_data = get_python_datasets(python_pathname, file_details, relative_path,
        questions, model_config, detailed)
      - if instruct_data:
        - save_python_data(file_details, instruct_data, relative_path, output_dir)
        else:
        - logging.error(f'Failed getting {python_pathname} dataset')
      - del instruct_data, file_details, model_config
  - ? 'def py2dataset(start: str, output_dir: str, questions_pathname: str, model_config_pathname:
      str, use_llm: bool, quiet: bool, single_process: bool, detailed: bool, html:
      bool, skip_regen: bool)'
    : - if quiet:
        - logging.getLogger().setLevel(logging.WARNING)
        else:
        - logging.getLogger().setLevel(logging.INFO)
      - sys.setrecursionlimit(3000)
      - model_config = None
      - if use_llm and single_process:
        - model_config = get_model(model_config_pathname)
      - 'params = {''python_pathname'': '''', ''relative_path'': '''', ''output_dir'':
        get_output_dir(output_dir), ''model_config_pathname'': model_config_pathname,
        ''questions'': get_questions(questions_pathname), ''use_llm'': use_llm, ''model_config'':
        model_config, ''detailed'': detailed}'
      - for python_pathname in Path(start).rglob('*.py'):
        - if '__pycache__' in python_pathname.parts:
          - continue
        - if python_pathname.name == '__init__.py':
          - continue
        - params['python_pathname'] = str(python_pathname)
        - params['relative_path'] = Path(os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start))))
        - base_pathname = Path(params['output_dir']) / params['relative_path']
        - instruct_pathname = base_pathname.with_suffix('.py.instruct.json')
        - if instruct_pathname.exists() and skip_regen:
          - continue
        - if params['model_config'] is None and params['use_llm']:
          - proc = Process(target=process_single_python_file, kwargs=params)
          - proc.start()
          - proc.join()
          else:
          - process_single_python_file(**params)
      - return:
        - combine_json_files(output_dir, html, params['questions'])
  - 'def clone_github_repo(url: str)':
    - try:
      - command = f'git ls-remote {shlex.quote(url)}'
      - subprocess.run(command, shell=True, check=True, stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL)
      - repo_name = url.split('/')[-1]
      - githubrepos_dir = os.path.join(os.getcwd(), 'githubrepos')
      - os.makedirs(githubrepos_dir, exist_ok=True)
      - path = os.path.join(githubrepos_dir, repo_name)
      - if not os.path.exists(path):
        - git.Repo.clone_from(url, path)
        else:
        - repo = git.Repo(path)
        - with repo.git.custom_environment(GIT_SSH_COMMAND='ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'):
          - repo.git.fetch()
          - default_branch = repo.head.reference.tracking_branch().remote_head
          - repo.git.reset('--hard', default_branch)
      except:
      - 'except subprocess.CalledProcessError as :':
        - 'logging.info(f''Invalid or inaccessible repository: {url}'')'
        - path = ''
    - return:
      - path
  plant_uml: "@startuml\n  def [{\"if '--help' in sys.argv\": ['print(__doc__)', 'sys.exit()']},\
    \ {'def get_bool_from_input(input_str: str, current_value: bool)': [{\"if input_str.lower()\
    \ in ['t', 'true', 'y', 'yes']\": [{'return': ['True']}], \"elif input_str.lower()\
    \ in ['f', 'false', 'n', 'no']\": [{'return': ['False']}]}, {'return': ['current_value']}]},\
    \ \"params = {'start': '.', 'output_dir': './dataset/', 'questions_pathname':\
    \ './py2dataset_questions.json', 'model_config_pathname': './py2dataset_model_config.yaml',\
    \ 'use_llm': False, 'quiet': False, 'single_process': False, 'detailed': False,\
    \ 'html': False, 'skip_regen': False, 'I': False}\", \"arg_string = ' '.join(sys.argv[1:])\"\
    , {'for arg in params': [{\"if '--' + arg in arg_string\": [{'if isinstance(params[arg],\
    \ bool)': ['params[arg] = True', \"arg_string = arg_string.replace('--' + arg,\
    \ '')\"], 'else': [\"value_segment = arg_string.split('--' + arg + ' ')[1]\",\
    \ 'params[arg] = value_segment.split(\\' --\\')[0].strip(\\'\"\\')', \"arg_string\
    \ = arg_string.replace('--' + arg + ' ' + params[arg], '')\"]}]}]}, {\"if params['I']\"\
    : [\"print('Interactive mode, enter new values or press enter to keep.')\", {'for\
    \ arg in params': [{\"if arg != 'I'\": [\"user_input = input(f'{arg} [{params[arg]}]:\
    \ ').strip()\", {'if isinstance(params[arg], bool)': ['params[arg] = get_bool_from_input(user_input,\
    \ params[arg])'], 'elif user_input': ['params[arg] = user_input']}, \"print(f'{arg}:\
    \ {params[arg]}')\"]}]}]}, \"params.pop('I')\", {\"if params['start'].startswith('https://github.com/')\"\
    : [\"params['start'] = clone_github_repo(params['start'])\"], \"elif not os.path.isdir(params['start'])\"\
    : ['print(f\"\\'{params[\\'start\\']}\\' Invalid. Using current working directory.\"\
    )', \"params['start'] = os.getcwd()\"]}, 'py2dataset(**params)'] {\n    if (['print(__doc__)',\
    \ 'sys.exit()']) {\n      :print(__doc__);\n      :sys.exit();\n    }\n    def\
    \ [{\"if input_str.lower() in ['t', 'true', 'y', 'yes']\": [{'return': ['True']}],\
    \ \"elif input_str.lower() in ['f', 'false', 'n', 'no']\": [{'return': ['False']}]},\
    \ {'return': ['current_value']}] {\n      if ([{'return': ['True']}]) {\n    \
    \    :return;\n        :True;\n      }\n      :return;\n      :current_value;\n\
    \    }\n    :params = {'start': '.', 'output_dir': './dataset/', 'questions_pathname':\
    \ './py2dataset_questions.json', 'model_config_pathname': './py2dataset_model_config.yaml',\
    \ 'use_llm': False, 'quiet': False, 'single_process': False, 'detailed': False,\
    \ 'html': False, 'skip_regen': False, 'I': False};\n    :arg_string = ' '.join(sys.argv[1:]);\n\
    \    while ([{\"if '--' + arg in arg_string\": [{'if isinstance(params[arg], bool)':\
    \ ['params[arg] = True', \"arg_string = arg_string.replace('--' + arg, '')\"],\
    \ 'else': [\"value_segment = arg_string.split('--' + arg + ' ')[1]\", 'params[arg]\
    \ = value_segment.split(\\' --\\')[0].strip(\\'\"\\')', \"arg_string = arg_string.replace('--'\
    \ + arg + ' ' + params[arg], '')\"]}]}]) {\n      if ([{'if isinstance(params[arg],\
    \ bool)': ['params[arg] = True', \"arg_string = arg_string.replace('--' + arg,\
    \ '')\"], 'else': [\"value_segment = arg_string.split('--' + arg + ' ')[1]\",\
    \ 'params[arg] = value_segment.split(\\' --\\')[0].strip(\\'\"\\')', \"arg_string\
    \ = arg_string.replace('--' + arg + ' ' + params[arg], '')\"]}]) {\n        if\
    \ (['params[arg] = True', \"arg_string = arg_string.replace('--' + arg, '')\"\
    ]) {\n          :params[arg] = True;\n          :arg_string = arg_string.replace('--'\
    \ + arg, '');\n        }\n      }\n    }\n    if ([\"print('Interactive mode,\
    \ enter new values or press enter to keep.')\", {'for arg in params': [{\"if arg\
    \ != 'I'\": [\"user_input = input(f'{arg} [{params[arg]}]: ').strip()\", {'if\
    \ isinstance(params[arg], bool)': ['params[arg] = get_bool_from_input(user_input,\
    \ params[arg])'], 'elif user_input': ['params[arg] = user_input']}, \"print(f'{arg}:\
    \ {params[arg]}')\"]}]}]) {\n      :print('Interactive mode, enter new values\
    \ or press enter to keep.');\n      while ([{\"if arg != 'I'\": [\"user_input\
    \ = input(f'{arg} [{params[arg]}]: ').strip()\", {'if isinstance(params[arg],\
    \ bool)': ['params[arg] = get_bool_from_input(user_input, params[arg])'], 'elif\
    \ user_input': ['params[arg] = user_input']}, \"print(f'{arg}: {params[arg]}')\"\
    ]}]) {\n        if ([\"user_input = input(f'{arg} [{params[arg]}]: ').strip()\"\
    , {'if isinstance(params[arg], bool)': ['params[arg] = get_bool_from_input(user_input,\
    \ params[arg])'], 'elif user_input': ['params[arg] = user_input']}, \"print(f'{arg}:\
    \ {params[arg]}')\"]) {\n          :user_input = input(f'{arg} [{params[arg]}]:\
    \ ').strip();\n          if (['params[arg] = get_bool_from_input(user_input, params[arg])'])\
    \ {\n            :params[arg] = get_bool_from_input(user_input, params[arg]);\n\
    \          }\n          :print(f'{arg}: {params[arg]}');\n        }\n      }\n\
    \    }\n    :params.pop('I');\n    if ([\"params['start'] = clone_github_repo(params['start'])\"\
    ]) {\n      :params['start'] = clone_github_repo(params['start']);\n    }\n  \
    \  :py2dataset(**params);\n  }\n  if (['main()']) {\n    :main();\n  }\n  :import\
    \ sys;\n  :import logging;\n  :from pathlib import Path;\n  :from typing import\
    \ Dict, List;\n  :from multiprocessing import Process;\n  :import subprocess;\n\
    \  :import os;\n  :import git;\n  :import shlex;\n  :from get_python_file_details\
    \ import get_python_file_details;\n  :from get_python_datasets import get_python_datasets;\n\
    \  :from get_params import get_questions, get_model, get_output_dir, get_start_dir;\n\
    \  :from save_output import combine_json_files, save_python_data;\n  def [\"logging.info(f'Processing\
    \ file: {python_pathname}')\", {'if model_config is None and use_llm': ['model_config\
    \ = get_model(model_config_pathname)']}, 'file_details = get_python_file_details(python_pathname)',\
    \ {'if not file_details': [\"logging.error(f'Failed to get file details for {python_pathname}')\"\
    , {'return': []}]}, 'instruct_data = get_python_datasets(python_pathname, file_details,\
    \ relative_path, questions, model_config, detailed)', {'if instruct_data': ['save_python_data(file_details,\
    \ instruct_data, relative_path, output_dir)'], 'else': [\"logging.error(f'Failed\
    \ getting {python_pathname} dataset')\"]}, 'del instruct_data, file_details, model_config']\
    \ {\n    :logging.info(f'Processing file: {python_pathname}');\n    if (['model_config\
    \ = get_model(model_config_pathname)']) {\n      :model_config = get_model(model_config_pathname);\n\
    \    }\n    :file_details = get_python_file_details(python_pathname);\n    if\
    \ ([\"logging.error(f'Failed to get file details for {python_pathname}')\", {'return':\
    \ []}]) {\n      :logging.error(f'Failed to get file details for {python_pathname}');\n\
    \      :return;\n    }\n    :instruct_data = get_python_datasets(python_pathname,\
    \ file_details, relative_path, questions, model_config, detailed);\n    if (['save_python_data(file_details,\
    \ instruct_data, relative_path, output_dir)']) {\n      :save_python_data(file_details,\
    \ instruct_data, relative_path, output_dir);\n    }\n    :del instruct_data, file_details,\
    \ model_config;\n  }\n  def [{'if quiet': ['logging.getLogger().setLevel(logging.WARNING)'],\
    \ 'else': ['logging.getLogger().setLevel(logging.INFO)']}, 'sys.setrecursionlimit(3000)',\
    \ 'model_config = None', {'if use_llm and single_process': ['model_config = get_model(model_config_pathname)']},\
    \ \"params = {'python_pathname': '', 'relative_path': '', 'output_dir': get_output_dir(output_dir),\
    \ 'model_config_pathname': model_config_pathname, 'questions': get_questions(questions_pathname),\
    \ 'use_llm': use_llm, 'model_config': model_config, 'detailed': detailed}\", {\"\
    for python_pathname in Path(start).rglob('*.py')\": [{\"if '__pycache__' in python_pathname.parts\"\
    : ['continue']}, {\"if python_pathname.name == '__init__.py'\": ['continue']},\
    \ \"params['python_pathname'] = str(python_pathname)\", \"params['relative_path']\
    \ = Path(os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start))))\"\
    , \"base_pathname = Path(params['output_dir']) / params['relative_path']\", \"\
    instruct_pathname = base_pathname.with_suffix('.py.instruct.json')\", {'if instruct_pathname.exists()\
    \ and skip_regen': ['continue']}, {\"if params['model_config'] is None and params['use_llm']\"\
    : ['proc = Process(target=process_single_python_file, kwargs=params)', 'proc.start()',\
    \ 'proc.join()'], 'else': ['process_single_python_file(**params)']}]}, {'return':\
    \ [\"combine_json_files(output_dir, html, params['questions'])\"]}] {\n    if\
    \ (['logging.getLogger().setLevel(logging.WARNING)']) {\n      :logging.getLogger().setLevel(logging.WARNING);\n\
    \    }\n    :sys.setrecursionlimit(3000);\n    :model_config = None;\n    if (['model_config\
    \ = get_model(model_config_pathname)']) {\n      :model_config = get_model(model_config_pathname);\n\
    \    }\n    :params = {'python_pathname': '', 'relative_path': '', 'output_dir':\
    \ get_output_dir(output_dir), 'model_config_pathname': model_config_pathname,\
    \ 'questions': get_questions(questions_pathname), 'use_llm': use_llm, 'model_config':\
    \ model_config, 'detailed': detailed};\n    while ([{\"if '__pycache__' in python_pathname.parts\"\
    : ['continue']}, {\"if python_pathname.name == '__init__.py'\": ['continue']},\
    \ \"params['python_pathname'] = str(python_pathname)\", \"params['relative_path']\
    \ = Path(os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start))))\"\
    , \"base_pathname = Path(params['output_dir']) / params['relative_path']\", \"\
    instruct_pathname = base_pathname.with_suffix('.py.instruct.json')\", {'if instruct_pathname.exists()\
    \ and skip_regen': ['continue']}, {\"if params['model_config'] is None and params['use_llm']\"\
    : ['proc = Process(target=process_single_python_file, kwargs=params)', 'proc.start()',\
    \ 'proc.join()'], 'else': ['process_single_python_file(**params)']}]) {\n    \
    \  if (['continue']) {\n        :continue;\n      }\n      if (['continue']) {\n\
    \        :continue;\n      }\n      :params['python_pathname'] = str(python_pathname);\n\
    \      :params['relative_path'] = Path(os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start))));\n\
    \      :base_pathname = Path(params['output_dir']) / params['relative_path'];\n\
    \      :instruct_pathname = base_pathname.with_suffix('.py.instruct.json');\n\
    \      if (['continue']) {\n        :continue;\n      }\n      if (['proc = Process(target=process_single_python_file,\
    \ kwargs=params)', 'proc.start()', 'proc.join()']) {\n        :proc = Process(target=process_single_python_file,\
    \ kwargs=params);\n        :proc.start();\n        :proc.join();\n      }\n  \
    \  }\n    :return;\n    :combine_json_files(output_dir, html, params['questions']);\n\
    \  }\n  def [{'try': [\"command = f'git ls-remote {shlex.quote(url)}'\", 'subprocess.run(command,\
    \ shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)',\
    \ \"repo_name = url.split('/')[-1]\", \"githubrepos_dir = os.path.join(os.getcwd(),\
    \ 'githubrepos')\", 'os.makedirs(githubrepos_dir, exist_ok=True)', 'path = os.path.join(githubrepos_dir,\
    \ repo_name)', {'if not os.path.exists(path)': ['git.Repo.clone_from(url, path)'],\
    \ 'else': ['repo = git.Repo(path)', {\"with repo.git.custom_environment(GIT_SSH_COMMAND='ssh\
    \ -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no')\": ['repo.git.fetch()',\
    \ 'default_branch = repo.head.reference.tracking_branch().remote_head', \"repo.git.reset('--hard',\
    \ default_branch)\"]}]}], 'except': [{'except subprocess.CalledProcessError as\
    \ :': [\"logging.info(f'Invalid or inaccessible repository: {url}')\", \"path\
    \ = ''\"]}]}, {'return': ['path']}] {\n    :try;\n    :command = f'git ls-remote\
    \ {shlex.quote(url)}';\n    :subprocess.run(command, shell=True, check=True, stdout=subprocess.DEVNULL,\
    \ stderr=subprocess.DEVNULL);\n    :repo_name = url.split('/')[-1];\n    :githubrepos_dir\
    \ = os.path.join(os.getcwd(), 'githubrepos');\n    :os.makedirs(githubrepos_dir,\
    \ exist_ok=True);\n    :path = os.path.join(githubrepos_dir, repo_name);\n   \
    \ if (['git.Repo.clone_from(url, path)']) {\n      :git.Repo.clone_from(url, path);\n\
    \    }\n    :return;\n    :path;\n  }\nend\n@enduml"
functions:
  process_single_python_file:
    function_name: process_single_python_file
    function_code: "def process_single_python_file(python_pathname: str, relative_path:\
      \ Path, output_dir: str, model_config_pathname: str, questions: Dict, use_llm:\
      \ bool, model_config: Dict, detailed: bool) -> None:\n    \"\"\"\n    Processes\
      \ a single Python file to generate question-answer pairs and instructions.\n\
      \    Args:\n        python_pathname (str): Path to the Python file.\n      \
      \  start (str): Starting directory for Python files.\n        output_dir (str):\
      \ Directory to write the output files.\n        model_config_pathname (str):\
      \ Path and filename of the model configuration file.\n        questions (Dict):\
      \ Dictionary of questions to answer about the Python file.\n        use_llm\
      \ (bool): Use llm to answer code purpose question.\n        model_config (Dict):\
      \ Configuration dictionary for the LLM.\n        detailed (bool): Perform detailed\
      \ analysis if True.\n    \"\"\"\n    logging.info(f'Processing file: {python_pathname}')\n\
      \    if model_config is None and use_llm:\n        model_config = get_model(model_config_pathname)\n\
      \    file_details = get_python_file_details(python_pathname)\n    if not file_details:\n\
      \        logging.error(f'Failed to get file details for {python_pathname}')\n\
      \        return\n    instruct_data = get_python_datasets(python_pathname, file_details,\
      \ relative_path, questions, model_config, detailed)\n    if instruct_data:\n\
      \        save_python_data(file_details, instruct_data, relative_path, output_dir)\n\
      \    else:\n        logging.error(f'Failed getting {python_pathname} dataset')\n\
      \    del instruct_data, file_details, model_config"
    function_docstring: "\n    Processes a single Python file to generate question-answer\
      \ pairs and instructions.\n    Args:\n        python_pathname (str): Path to\
      \ the Python file.\n        start (str): Starting directory for Python files.\n\
      \        output_dir (str): Directory to write the output files.\n        model_config_pathname\
      \ (str): Path and filename of the model configuration file.\n        questions\
      \ (Dict): Dictionary of questions to answer about the Python file.\n       \
      \ use_llm (bool): Use llm to answer code purpose question.\n        model_config\
      \ (Dict): Configuration dictionary for the LLM.\n        detailed (bool): Perform\
      \ detailed analysis if True.\n    "
    function_inputs:
    - python_pathname
    - relative_path
    - output_dir
    - model_config_pathname
    - questions
    - use_llm
    - model_config
    - detailed
    function_defaults: []
    function_returns:
    - None
    function_calls:
    - logging.info
    - get_model
    - get_python_file_details
    - logging.error
    - get_python_datasets
    - save_python_data
    function_call_inputs:
      logging.info:
      - 'f''Processing file: {python_pathname}'''
      get_model:
      - model_config_pathname
      get_python_file_details:
      - python_pathname
      logging.error:
      - f'Failed to get file details for {python_pathname}'
      - f'Failed getting {python_pathname} dataset'
      get_python_datasets:
      - python_pathname
      - file_details
      - relative_path
      - questions
      - model_config
      - detailed
      save_python_data:
      - file_details
      - instruct_data
      - relative_path
      - output_dir
    function_variables:
    - use_llm
    - output_dir
    - questions
    - model_config_pathname
    - detailed
    - instruct_data
    - file_details
    - python_pathname
    - relative_path
    - model_config
    function_decorators: []
    function_annotations: []
    function_properties: []
  py2dataset:
    function_name: py2dataset
    function_code: "def py2dataset(start: str='', output_dir: str='', questions_pathname:\
      \ str='', model_config_pathname: str='', use_llm: bool=False, quiet: bool=False,\
      \ single_process: bool=False, detailed: bool=False, html: bool=False, skip_regen:\
      \ bool=False) -> Dict[str, List[Dict]]:\n    \"\"\"\n    Generates datasets\
      \ by processing Python files within a specified directory.\n    Args:\n    \
      \    start (str, optional): Starting directory for Python files or GitHub repository\
      \ Python files. Default: current working directory.\n        output_dir (str,\
      \ optional): Directory to write the output files. Default: ./dataset/.\n   \
      \     questions_pathname (str, optional): Path and filename of the questions\
      \ file. Default: ./py2dataset_questions.json.\n        model_config_pathname\
      \ (str, optional): Path and filename of the model configuration file. Default:\
      \ ./py2dataset_model_config.yaml.\n        use_llm (bool, optional): Use llm\
      \ to answer code purpose question. Default: False.\n        quiet (bool, optional):\
      \ Limit logging output. Default: False.\n        single_process (bool, optional):\
      \ Use a single process to process Python files if --use_llm. Default: False.\n\
      \        detailed (bool, optional): Include detailed analysis. Default: False.\n\
      \        html (bool, optional): Generate HTML output. Default: False.\n    \
      \    skip_regen (bool, optional): Skip regeneration of existing instruct.json\
      \ files. Default: False.\n    Returns:\n        Dict[str, List[Dict]]: Generated\
      \ datasets.\n    \"\"\"\n    if quiet:\n        logging.getLogger().setLevel(logging.WARNING)\n\
      \    else:\n        logging.getLogger().setLevel(logging.INFO)\n    sys.setrecursionlimit(3000)\n\
      \    model_config = None\n    if use_llm and single_process:\n        model_config\
      \ = get_model(model_config_pathname)\n    params = {'python_pathname': '', 'relative_path':\
      \ '', 'output_dir': get_output_dir(output_dir), 'model_config_pathname': model_config_pathname,\
      \ 'questions': get_questions(questions_pathname), 'use_llm': use_llm, 'model_config':\
      \ model_config, 'detailed': detailed}\n    for python_pathname in Path(start).rglob('*.py'):\n\
      \        if '__pycache__' in python_pathname.parts:\n            continue\n\
      \        if python_pathname.name == '__init__.py':\n            continue\n \
      \       params['python_pathname'] = str(python_pathname)\n        params['relative_path']\
      \ = Path(os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start))))\n\
      \        base_pathname = Path(params['output_dir']) / params['relative_path']\n\
      \        instruct_pathname = base_pathname.with_suffix('.py.instruct.json')\n\
      \        if instruct_pathname.exists() and skip_regen:\n            continue\n\
      \        if params['model_config'] is None and params['use_llm']:\n        \
      \    proc = Process(target=process_single_python_file, kwargs=params)\n    \
      \        proc.start()\n            proc.join()\n        else:\n            process_single_python_file(**params)\n\
      \    return combine_json_files(output_dir, html, params['questions'])"
    function_docstring: "\n    Generates datasets by processing Python files within\
      \ a specified directory.\n    Args:\n        start (str, optional): Starting\
      \ directory for Python files or GitHub repository Python files. Default: current\
      \ working directory.\n        output_dir (str, optional): Directory to write\
      \ the output files. Default: ./dataset/.\n        questions_pathname (str, optional):\
      \ Path and filename of the questions file. Default: ./py2dataset_questions.json.\n\
      \        model_config_pathname (str, optional): Path and filename of the model\
      \ configuration file. Default: ./py2dataset_model_config.yaml.\n        use_llm\
      \ (bool, optional): Use llm to answer code purpose question. Default: False.\n\
      \        quiet (bool, optional): Limit logging output. Default: False.\n   \
      \     single_process (bool, optional): Use a single process to process Python\
      \ files if --use_llm. Default: False.\n        detailed (bool, optional): Include\
      \ detailed analysis. Default: False.\n        html (bool, optional): Generate\
      \ HTML output. Default: False.\n        skip_regen (bool, optional): Skip regeneration\
      \ of existing instruct.json files. Default: False.\n    Returns:\n        Dict[str,\
      \ List[Dict]]: Generated datasets.\n    "
    function_inputs:
    - start
    - output_dir
    - questions_pathname
    - model_config_pathname
    - use_llm
    - quiet
    - single_process
    - detailed
    - html
    - skip_regen
    function_defaults:
    - ''''''
    - ''''''
    - ''''''
    - ''''''
    - 'False'
    - 'False'
    - 'False'
    - 'False'
    - 'False'
    - 'False'
    function_returns:
    - combine_json_files(output_dir, html, params['questions'])
    function_calls:
    - logging.getLogger().setLevel
    - logging.getLogger
    - sys.setrecursionlimit
    - get_model
    - get_output_dir
    - get_questions
    - Path(start).rglob
    - Path
    - str
    - os.path.relpath
    - os.path.dirname
    - get_start_dir
    - base_pathname.with_suffix
    - instruct_pathname.exists
    - Process
    - proc.start
    - proc.join
    - process_single_python_file
    - combine_json_files
    function_call_inputs:
      logging.getLogger().setLevel:
      - logging.WARNING
      - logging.INFO
      logging.getLogger: []
      sys.setrecursionlimit:
      - '3000'
      get_model:
      - model_config_pathname
      get_output_dir:
      - output_dir
      get_questions:
      - questions_pathname
      Path(start).rglob:
      - '''*.py'''
      Path:
      - start
      - os.path.relpath(python_pathname, os.path.dirname(get_start_dir(start)))
      - params['output_dir']
      str:
      - python_pathname
      os.path.relpath:
      - python_pathname
      - os.path.dirname(get_start_dir(start))
      os.path.dirname:
      - get_start_dir(start)
      get_start_dir:
      - start
      base_pathname.with_suffix:
      - '''.py.instruct.json'''
      instruct_pathname.exists: []
      Process: []
      proc.start: []
      proc.join: []
      process_single_python_file: []
      combine_json_files:
      - output_dir
      - html
      - params['questions']
    function_variables:
    - instruct_pathname
    - skip_regen
    - use_llm
    - output_dir
    - model_config_pathname
    - detailed
    - params
    - base_pathname
    - single_process
    - quiet
    - proc
    - questions_pathname
    - html
    - model_config
    - start
    function_decorators: []
    function_annotations: []
    function_properties: []
  clone_github_repo:
    function_name: clone_github_repo
    function_code: "def clone_github_repo(url: str) -> str:\n    \"\"\"\n    Clone\
      \ repository or fetch the latest changes and return local repository path.\n\
      \    Args:\n        url (str): The url of the github repository.\n    Returns:\n\
      \        str: The path to the cloned repository.\n    \"\"\"\n    try:\n   \
      \     command = f'git ls-remote {shlex.quote(url)}'\n        subprocess.run(command,\
      \ shell=True, check=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)\n\
      \        repo_name = url.split('/')[-1]\n        githubrepos_dir = os.path.join(os.getcwd(),\
      \ 'githubrepos')\n        os.makedirs(githubrepos_dir, exist_ok=True)\n    \
      \    path = os.path.join(githubrepos_dir, repo_name)\n        if not os.path.exists(path):\n\
      \            git.Repo.clone_from(url, path)\n        else:\n            repo\
      \ = git.Repo(path)\n            with repo.git.custom_environment(GIT_SSH_COMMAND='ssh\
      \ -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no'):\n         \
      \       repo.git.fetch()\n                default_branch = repo.head.reference.tracking_branch().remote_head\n\
      \                repo.git.reset('--hard', default_branch)\n    except subprocess.CalledProcessError:\n\
      \        logging.info(f'Invalid or inaccessible repository: {url}')\n      \
      \  path = ''\n    return path"
    function_docstring: "\n    Clone repository or fetch the latest changes and return\
      \ local repository path.\n    Args:\n        url (str): The url of the github\
      \ repository.\n    Returns:\n        str: The path to the cloned repository.\n\
      \    "
    function_inputs:
    - url
    function_defaults: []
    function_returns:
    - path
    function_calls:
    - shlex.quote
    - subprocess.run
    - url.split
    - os.path.join
    - os.getcwd
    - os.makedirs
    - os.path.exists
    - git.Repo.clone_from
    - git.Repo
    - repo.git.custom_environment
    - repo.git.fetch
    - repo.head.reference.tracking_branch
    - repo.git.reset
    - logging.info
    function_call_inputs:
      shlex.quote:
      - url
      subprocess.run:
      - command
      url.split:
      - '''/'''
      os.path.join:
      - os.getcwd()
      - '''githubrepos'''
      - githubrepos_dir
      - repo_name
      os.getcwd: []
      os.makedirs:
      - githubrepos_dir
      os.path.exists:
      - path
      git.Repo.clone_from:
      - url
      - path
      git.Repo:
      - path
      repo.git.custom_environment: []
      repo.git.fetch: []
      repo.head.reference.tracking_branch: []
      repo.git.reset:
      - '''--hard'''
      - default_branch
      logging.info:
      - 'f''Invalid or inaccessible repository: {url}'''
    function_variables:
    - repo_name
    - githubrepos_dir
    - command
    - repo
    - default_branch
    - url
    - path
    function_decorators: []
    function_annotations: []
    function_properties: []
  main:
    function_name: main
    function_code: "def main():\n    \"\"\"\n    Command-line entry point for processing\
      \ Python files and generating datasets.\n    Optional command-line arguments:\n\
      \    --start (str, optional): Starting directory for Python files or GitHub\
      \ repository Python files. Default: cwd.\n    --output_dir (str, optional):\
      \ Directory to write the output files. Default: ./dataset/.\n    --questions_pathname\
      \ (str, optional): Path and filename of the questions file. Default: ./py2dataset_questions.json.\n\
      \    --model_config_pathname (str, optional): Path and filename of the model\
      \ configuration file. Default: ./py2dataset_model_config.yaml.\n    --use_llm\
      \ (bool, optional): Use llm to answer code purpose question. Default: False.\n\
      \    --quiet (bool, optional): Limit logging output. Default: False.\n    --single_process\
      \ (bool, optional): Use a single process to process Python files if --use_llm.\
      \ Default: False.\n    --detailed (bool, optional): Include detailed analysis.\
      \ Default: False.\n    --html (bool, optional): Generate HTML output. Default:\
      \ False.\n    --I (str, optional): Enable interactive mode. Default: False.\n\
      \    --skip_regen (str, optional): Skip regeneration of existing instruct.json\
      \ files. Default: False.\n    --help: Display help message.\n    \"\"\"\n  \
      \  if '--help' in sys.argv:\n        print(__doc__)\n        sys.exit()\n\n\
      \    def get_bool_from_input(input_str: str, current_value: bool) -> bool:\n\
      \        if input_str.lower() in ['t', 'true', 'y', 'yes']:\n            return\
      \ True\n        elif input_str.lower() in ['f', 'false', 'n', 'no']:\n     \
      \       return False\n        return current_value\n    params = {'start': '.',\
      \ 'output_dir': './dataset/', 'questions_pathname': './py2dataset_questions.json',\
      \ 'model_config_pathname': './py2dataset_model_config.yaml', 'use_llm': False,\
      \ 'quiet': False, 'single_process': False, 'detailed': False, 'html': False,\
      \ 'skip_regen': False, 'I': False}\n    arg_string = ' '.join(sys.argv[1:])\n\
      \    for arg in params:\n        if '--' + arg in arg_string:\n            if\
      \ isinstance(params[arg], bool):\n                params[arg] = True\n     \
      \           arg_string = arg_string.replace('--' + arg, '')\n            else:\n\
      \                value_segment = arg_string.split('--' + arg + ' ')[1]\n   \
      \             params[arg] = value_segment.split(' --')[0].strip('\"')\n    \
      \            arg_string = arg_string.replace('--' + arg + ' ' + params[arg],\
      \ '')\n    if params['I']:\n        print('Interactive mode, enter new values\
      \ or press enter to keep.')\n        for arg in params:\n            if arg\
      \ != 'I':\n                user_input = input(f'{arg} [{params[arg]}]: ').strip()\n\
      \                if isinstance(params[arg], bool):\n                    params[arg]\
      \ = get_bool_from_input(user_input, params[arg])\n                elif user_input:\n\
      \                    params[arg] = user_input\n                print(f'{arg}:\
      \ {params[arg]}')\n    params.pop('I')\n    if params['start'].startswith('https://github.com/'):\n\
      \        params['start'] = clone_github_repo(params['start'])\n    elif not\
      \ os.path.isdir(params['start']):\n        print(f\"'{params['start']}' Invalid.\
      \ Using current working directory.\")\n        params['start'] = os.getcwd()\n\
      \    py2dataset(**params)"
    function_docstring: "\n    Command-line entry point for processing Python files\
      \ and generating datasets.\n    Optional command-line arguments:\n    --start\
      \ (str, optional): Starting directory for Python files or GitHub repository\
      \ Python files. Default: cwd.\n    --output_dir (str, optional): Directory to\
      \ write the output files. Default: ./dataset/.\n    --questions_pathname (str,\
      \ optional): Path and filename of the questions file. Default: ./py2dataset_questions.json.\n\
      \    --model_config_pathname (str, optional): Path and filename of the model\
      \ configuration file. Default: ./py2dataset_model_config.yaml.\n    --use_llm\
      \ (bool, optional): Use llm to answer code purpose question. Default: False.\n\
      \    --quiet (bool, optional): Limit logging output. Default: False.\n    --single_process\
      \ (bool, optional): Use a single process to process Python files if --use_llm.\
      \ Default: False.\n    --detailed (bool, optional): Include detailed analysis.\
      \ Default: False.\n    --html (bool, optional): Generate HTML output. Default:\
      \ False.\n    --I (str, optional): Enable interactive mode. Default: False.\n\
      \    --skip_regen (str, optional): Skip regeneration of existing instruct.json\
      \ files. Default: False.\n    --help: Display help message.\n    "
    function_inputs: []
    function_defaults: []
    function_returns:
    - current_value
    - 'True'
    - 'False'
    function_calls:
    - print
    - sys.exit
    - input_str.lower
    - ''' ''.join'
    - isinstance
    - arg_string.replace
    - arg_string.split
    - value_segment.split(' --')[0].strip
    - value_segment.split
    - 'input(f''{arg} [{params[arg]}]: '').strip'
    - input
    - get_bool_from_input
    - params.pop
    - params['start'].startswith
    - clone_github_repo
    - os.path.isdir
    - os.getcwd
    - py2dataset
    function_call_inputs:
      print:
      - __doc__
      - '''Interactive mode, enter new values or press enter to keep.'''
      - 'f''{arg}: {params[arg]}'''
      - f"'{params['start']}' Invalid. Using current working directory."
      sys.exit: []
      input_str.lower: []
      ''' ''.join':
      - sys.argv[1:]
      isinstance:
      - params[arg]
      - bool
      - params[arg]
      - bool
      arg_string.replace:
      - '''--'' + arg'
      - ''''''
      - '''--'' + arg + '' '' + params[arg]'
      - ''''''
      arg_string.split:
      - '''--'' + arg + '' '''
      value_segment.split(' --')[0].strip:
      - '''"'''
      value_segment.split:
      - ''' --'''
      'input(f''{arg} [{params[arg]}]: '').strip': []
      input:
      - 'f''{arg} [{params[arg]}]: '''
      get_bool_from_input:
      - user_input
      - params[arg]
      params.pop:
      - '''I'''
      params['start'].startswith:
      - '''https://github.com/'''
      clone_github_repo:
      - params['start']
      os.path.isdir:
      - params['start']
      os.getcwd: []
      py2dataset: []
    function_variables:
    - arg_string
    - params
    - value_segment
    - user_input
    function_decorators: []
    function_annotations: []
    function_properties: []
  get_bool_from_input:
    function_name: get_bool_from_input
    function_code: "def get_bool_from_input(input_str: str, current_value: bool) ->\
      \ bool:\n    if input_str.lower() in ['t', 'true', 'y', 'yes']:\n        return\
      \ True\n    elif input_str.lower() in ['f', 'false', 'n', 'no']:\n        return\
      \ False\n    return current_value"
    function_docstring: null
    function_inputs:
    - input_str
    - current_value
    function_defaults: []
    function_returns:
    - current_value
    - 'True'
    - 'False'
    function_calls:
    - input_str.lower
    function_call_inputs:
      input_str.lower: []
    function_variables:
    - input_str
    - current_value
    function_decorators: []
    function_annotations: []
    function_properties: []
classes: {}
