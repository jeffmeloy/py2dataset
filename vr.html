<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Cinema Launcher</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { 
            margin: 0; 
            background: #121212; 
            font-family: sans-serif; 
            min-height: 100vh; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: #e0e0e0; 
        }
        
        #launcher {
            width: 100%;
            max-width: 850px;
            background: #1e1e1e;
            border: 1px solid #333;
            border-radius: 12px;
            padding: 20px;
            display: flex;
            flex-wrap: wrap; 
            gap: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            box-sizing: border-box;
        }

        .controls-col {
            flex: 1 1 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .preview-col {
            flex: 2 1 320px;
            border: 1px solid #333;
            border-radius: 8px;
            background: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 250px;
            aspect-ratio: 16/9;
            position: relative;
            overflow: hidden;
        }

        button.launch-btn {
            width: 100%;
            padding: 20px;
            font-size: 18px;
            font-weight: bold;
            color: white;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        button.launch-btn:hover { background: #3d3d3d; border-color: #555; }
        button.launch-btn:active { transform: translateY(2px); }
        button.launch-btn:disabled { background: #1a1a1a; color: #555; border-color: #333; cursor: not-allowed; }

        #btnEnter:not(:disabled) { background: #007bff; border-color: #0056b3; }
        #btnEnter:not(:disabled):hover { background: #0056b3; }

        .radio-group {
            display: flex;
            align-items: center;
            justify-content: space-around;
            padding: 15px;
            background: #181818;
            border: 1px solid #333;
            border-radius: 8px;
        }
        .radio-label {
            font-size: 16px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            color: #ccc;
        }
        .radio-label:hover { color: white; }
        input[type="radio"] { width: 20px; height: 20px; cursor: pointer; accent-color: #007bff; }

        #previewVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        .placeholder { color: #666; font-weight: bold; text-align: center; padding: 20px; user-select: none; }
        #fileInput { display: none; }
    </style>
</head>
<body>

<div id="launcher">
    <div class="controls-col">
        <button class="launch-btn" onclick="document.getElementById('fileInput').click()">
            Tap to Select Video
        </button>
        <input type="file" id="fileInput" accept="video/*">
        
        <div class="radio-group">
            <label class="radio-label"><input type="radio" name="mode" value="webgl" checked> WebGL (Cardboard)</label>
            <label class="radio-label"><input type="radio" name="mode" value="webxr"> WebXR (Headset)</label>
        </div>

        <button id="btnEnter" class="launch-btn" disabled>Enter VR</button>
    </div>

    <div class="preview-col">
        <div class="placeholder" id="vidPlaceholder">No Video Selected</div>
        <video id="previewVideo" controls playsinline></video>
    </div>
</div>

<script>
    let selectedBlobUrl = null;
    const fileInput = document.getElementById('fileInput');
    const previewVideo = document.getElementById('previewVideo');
    const placeholder = document.getElementById('vidPlaceholder');
    const btnEnter = document.getElementById('btnEnter');

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        selectedBlobUrl = URL.createObjectURL(file);
        
        previewVideo.src = selectedBlobUrl;
        previewVideo.style.display = 'block';
        placeholder.style.display = 'none';
        
        btnEnter.disabled = false;
        btnEnter.textContent = "START " + (document.querySelector('input[name="mode"]:checked').value === 'webgl' ? "WebGL" : "WebXR");
    });

    document.querySelectorAll('input[name="mode"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            if(!btnEnter.disabled) {
                btnEnter.textContent = "START " + (e.target.value === 'webgl' ? "WebGL" : "WebXR");
            }
        });
    });

    btnEnter.addEventListener('click', () => {
        if (!selectedBlobUrl) return;

        const de = document.documentElement;
        if (de.requestFullscreen) de.requestFullscreen().catch(()=>{});
        else if (de.webkitRequestFullscreen) de.webkitRequestFullscreen();

        const mode = document.querySelector('input[name="mode"]:checked').value;
        
        // Stash WebGL source for potential fallback from WebXR
        sessionStorage.setItem('_webgl_source', getWebGLSource());
        sessionStorage.setItem('_video_url', selectedBlobUrl);
        
        let finalHtml = (mode === 'webgl') ? getWebGLSource() : getWebXRSource();

        const injector = `
            <script>
                const _LAUNCH_URL = "${selectedBlobUrl}";
                window.addEventListener('DOMContentLoaded', () => {
                    const style = document.createElement('style');
                    style.innerHTML = '#setup { display: none !important; }';
                    document.head.appendChild(style);

                    ${mode === 'webgl' ? getWebGLBootstrapper() : getWebXRBootstrapper()}
                });
            <\/script>
        `;

        finalHtml = finalHtml.replace('</body>', injector + '</body>');

        document.open();
        document.write(finalHtml);
        document.close();
    });

    function getWebGLBootstrapper() {
        return `
            if(typeof initEngine === 'function') {
                srcURL = _LAUNCH_URL; 
                viewMode = 'full';
                initEngine();
                updateOverlay();
            }
        `;
    }

    function getWebXRBootstrapper() {
        return `
            window.videoSrc = _LAUNCH_URL; 
            const checkInit = setInterval(() => {
                if(typeof window.initVR === 'function') {
                    clearInterval(checkInit);
                    window.initVR(); 
                }
            }, 50);
        `;
    }

    function getWebGLSource() {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Player</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; color: white; }
        #setup { position: fixed; inset: 0; background: #121212; z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        .setup-box { width: 100%; max-width: 400px; background: #1e1e1e; padding: 20px; border-radius: 12px; display: flex; flex-direction: column; gap: 20px; border: 1px solid #333; }
        .file-btn { display: block; background: #333; padding: 15px; text-align: center; border-radius: 8px; cursor: pointer; border: 1px dashed #555; }
        #fileInput { display: none; }
        .preview-box { height: 180px; background: black; border: 1px solid #333; border-radius: 8px; overflow: hidden; position: relative; display: flex; align-items: center; justify-content: center; }
        #pVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        #placeholder { color: #555; pointer-events: none; }
        #startBtn { width: 100%; padding: 16px; background: #007bff; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px; }
        #startBtn:disabled { background: #333; color: #555; cursor: not-allowed; }
        #overlay { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.5); z-index: 9999; display: none; padding: 10px 0; transition: opacity 0.3s; }
        #overlay.visible { display: flex; opacity: 1; }
        #overlay.single { justify-content: center; } 
        #overlay.split { justify-content: space-around; }
        .ctrl-panel { width: 320px; display: flex; flex-direction: column; align-items: center; gap: 6px; padding: 0 5px; }
        .row { display: flex; gap: 6px; justify-content: center; width: 100%; align-items: center; }
        button { cursor: pointer; }
        .btn-icon { width: 32px; height: 32px; border-radius: 50%; background: #333; color: white; border: none; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; }
        .btn-pill { padding: 6px 12px; border-radius: 15px; background: #333; color: white; border: none; font-size: 11px; font-weight: bold; min-width: 50px; }
        .btn-pill.active { background: #007bff; color: white; }
        .btn-wide { width: 90%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 6px; font-weight: bold; margin-top: 4px; }
        .lbl { font-size: 10px; color: #ddd; text-transform: uppercase; margin-top: 5px; font-weight: bold; text-shadow: 0 1px 2px black; }
        .prog-track { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; position: relative; margin-bottom: 5px; cursor: pointer; }
        .prog-fill { height: 100%; background: #007bff; width: 0%; border-radius: 5px; pointer-events: none; }
        #webgl-canvas { position: absolute; top: 0; left: 0; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>
</head>
<body>
<div id="setup">
    <div class="setup-box">
        <div>
            <label for="fileInput" class="file-btn" id="fileLabel">Tap to Select Video</label>
            <input type="file" id="fileInput" accept="video/*">
        </div>
        <div class="preview-box">
            <span id="placeholder">No Video Selected</span>
            <video id="pVideo" playsinline muted controls></video>
        </div>
        <button id="startBtn" disabled>START</button>
    </div>
</div>
<div id="overlay"></div>
<script id="vs" type="x-shader/x-vertex">varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}<\/script>
<script id="fs" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D tDiffuse; uniform vec2 texSize; uniform float ipd; uniform float zoom; varying vec2 vUv;
    const float PI = 3.14159265359;
    float sinc(float x){ if(abs(x)<0.0001)return 1.0; float a=PI*x; return sin(a)/a; }
    float lw(float x){ if(abs(x)>=2.0)return 0.0; return sinc(x)*sinc(x*0.5); }
    vec4 textureLanczos(sampler2D smp, vec2 uv, vec2 size) {
        vec2 inv = 1.0/size; vec2 pos = uv*size; vec2 ipos = floor(pos-0.5)+0.5; vec2 f = pos-ipos;
        vec4 wX = vec4(lw(1.0+f.x), lw(f.x), lw(1.0-f.x), lw(2.0-f.x));
        vec4 wY = vec4(lw(1.0+f.y), lw(f.y), lw(1.0-f.y), lw(2.0-f.y));
        wX /= dot(wX, vec4(1.0)); wY /= dot(wY, vec4(1.0));
        vec4 r0 = texture2D(smp, (ipos+vec2(-1,-1))*inv)*wX.x + texture2D(smp, (ipos+vec2(0,-1))*inv)*wX.y + texture2D(smp, (ipos+vec2(1,-1))*inv)*wX.z + texture2D(smp, (ipos+vec2(2,-1))*inv)*wX.w;
        vec4 r1 = texture2D(smp, (ipos+vec2(-1, 0))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 0))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 0))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 0))*inv)*wX.w;
        vec4 r2 = texture2D(smp, (ipos+vec2(-1, 1))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 1))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 1))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 1))*inv)*wX.w;
        vec4 r3 = texture2D(smp, (ipos+vec2(-1, 2))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 2))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 2))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 2))*inv)*wX.w;
        return r0*wY.x + r1*wY.y + r2*wY.z + r3*wY.w;
    }
    vec2 distort(vec2 p){ vec2 c=vec2(0.5); vec2 v=p-c; float r2=dot(v,v); return c+v*(1.0+r2*(0.22+0.18*r2)); }
    void main(){
        vec2 d = distort(vUv);
        vec2 uv = (d-vec2(0.5))/zoom; uv.x+=ipd; uv+=vec2(0.5);
        if(uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0) gl_FragColor=vec4(0.0);
        else gl_FragColor=textureLanczos(tDiffuse, uv, texSize);
    }
<\/script>
<script>
    let viewMode = 'full', srcURL = null, hideTimer = null;
    const defs = { z: 1.0, d: 3.0, i: 0.0 };
    let params = { ...defs };
    let videoAspect = 16/9;
    const els = { setup: document.getElementById('setup'), pVid: document.getElementById('pVideo'), enter: document.getElementById('startBtn'), lbl: document.getElementById('fileLabel'), overlay: document.getElementById('overlay') };
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const f = e.target.files[0]; if(!f) return;
        srcURL = URL.createObjectURL(f); els.pVid.src = srcURL; els.pVid.style.display = 'block';
        document.getElementById('placeholder').style.display = 'none'; els.lbl.textContent = f.name; els.enter.disabled = false;
    });
    els.enter.addEventListener('click', async () => {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { try { await DeviceOrientationEvent.requestPermission(); } catch (e) {} }
        const de = document.documentElement; if(de.requestFullscreen) de.requestFullscreen();
        if(screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(()=>{});
        els.setup.style.display = 'none'; viewMode = 'full'; initEngine(); updateOverlay();
    });
    function updateOverlay() {
        const isFull = (viewMode === 'full'); els.overlay.className = isFull ? 'visible single' : 'visible split'; resetTimer();
        const controls = \`
            <div class="row"><div class="prog-track"><div class="prog-fill"></div></div></div>
            <div class="row"><button class="btn-icon rw">&laquo;</button><button class="btn-icon pp">▶</button><button class="btn-icon fw">&raquo;</button></div>
            <div class="lbl">View Mode</div>
            <div class="row"><button class="btn-pill m-full \${viewMode==='full'?'active':''}">FULL</button><button class="btn-pill m-2d \${viewMode==='vr-2d'?'active':''}">2D</button><button class="btn-pill m-3d \${viewMode==='vr-3d'?'active':''}">3D</button></div>
            <div class="lbl">Zoom</div>
            <div class="row"><button class="btn-icon zout">-</button><button class="btn-pill zrst">RESET</button><button class="btn-icon zin">+</button></div>
            <div class="lbl">Distance</div>
            <div class="row"><button class="btn-icon ddec">-</button><button class="btn-pill drst">RESET</button><button class="btn-icon dinc">+</button></div>
            <div class="lbl">IPD</div>
            <div class="row"><button class="btn-icon idec">-</button><button class="btn-pill irst">RESET</button><button class="btn-icon iinc">+</button></div>
            <button class="btn-wide rec">RE-CENTER</button>
        \`;
        els.overlay.innerHTML = isFull ? \`<div class="ctrl-panel">\${controls}</div>\` : \`<div class="ctrl-panel">\${controls}</div><div class="ctrl-panel">\${controls}</div>\`;
    }
    let scene, camera, renderer, effect, videoEl, screenGroup, tracker, videoTexture;
    function initEngine() {
        scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        screenGroup = new THREE.Group(); scene.add(screenGroup); scene.add(camera);
        tracker = new Tracker(); tracker.connect();
        videoEl = document.createElement('video'); videoEl.src = srcURL; videoEl.playsInline = true; videoEl.loop = false;
        videoEl.addEventListener('loadedmetadata', () => { if(videoEl.videoHeight) videoAspect = videoEl.videoWidth / videoEl.videoHeight; });
        
        videoTexture = new THREE.Texture(videoEl);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.generateMipmaps = false;
        
        if ('requestVideoFrameCallback' in videoEl) {
            const updateFrame = () => {
                videoTexture.needsUpdate = true;
                videoEl.requestVideoFrameCallback(updateFrame);
            };
            const startFrameSync = () => videoEl.requestVideoFrameCallback(updateFrame);
            videoEl.addEventListener('playing', startFrameSync, { once: true });
            if (!videoEl.paused && videoEl.readyState >= 2) startFrameSync();
        } else {
            const fallbackUpdate = () => {
                if (videoEl.readyState >= videoEl.HAVE_CURRENT_FRAME) {
                    videoTexture.needsUpdate = true;
                }
                requestAnimationFrame(fallbackUpdate);
            };
            fallbackUpdate();
        }
        
        const geo = new THREE.PlaneGeometry(6, 6); 
        const mStd = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({map:videoTexture, side:2})); mStd.name = 'screenStandard'; screenGroup.add(mStd);
        const vs = \`varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }\`;
        const fsL = \`precision highp float; uniform sampler2D map; varying vec2 vUv; void main() { gl_FragColor = texture2D(map, vec2(vUv.x*0.5, vUv.y)); }\`;
        const fsR = \`precision highp float; uniform sampler2D map; varying vec2 vUv; void main() { gl_FragColor = texture2D(map, vec2(vUv.x*0.5+0.5, vUv.y)); }\`;
        const mL = new THREE.Mesh(geo, new THREE.ShaderMaterial({uniforms:{map:{value:videoTexture}}, vertexShader:vs, fragmentShader:fsL, side:2})); mL.layers.set(1);
        const mR = new THREE.Mesh(geo, new THREE.ShaderMaterial({uniforms:{map:{value:videoTexture}}, vertexShader:vs, fragmentShader:fsR, side:2})); mR.layers.set(2);
        mL.name = mR.name = 'screenSBS'; screenGroup.add(mL); screenGroup.add(mR);
        renderer = new THREE.WebGLRenderer({antialias:false, powerPreference:"high-performance"});
        renderer.domElement.id = 'webgl-canvas'; renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); document.body.appendChild(renderer.domElement);
        videoTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
        effect = new StereoEffect(renderer, videoEl); effect.setSize(window.innerWidth, window.innerHeight);
        videoEl.play(); videoEl.addEventListener('timeupdate', updateProg);
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); if(effect) effect.setSize(window.innerWidth, window.innerHeight); });
        document.addEventListener('click', (e) => { if(e.target.closest('#overlay')) { resetTimer(); return; } if(els.overlay.classList.contains('visible')) hideOverlay(); else showOverlay(); });
        els.overlay.addEventListener('click', handleInput); animate();
    }
    function showOverlay() { els.overlay.classList.add('visible'); resetTimer(); }
    function hideOverlay() { els.overlay.classList.remove('visible'); }
    function resetTimer() { if(hideTimer) clearTimeout(hideTimer); hideTimer = setTimeout(hideOverlay, 3000); }
    function animate() {
        requestAnimationFrame(animate); tracker.update(); camera.quaternion.copy(tracker.getQ());
        let z = (viewMode === 'full') ? -1.8 * params.d / 3.0 : -params.d;
        let s = ((viewMode === 'full') ? 0.6 : 1.0) * params.z;
        let effectiveAspect = videoAspect; if(viewMode === 'vr-3d') effectiveAspect = videoAspect / 2.0;
        screenGroup.children.forEach(c => { c.position.z = z; c.scale.set(s, s / effectiveAspect, s); });
        const mStd = screenGroup.getObjectByName('screenStandard'); const mSBS = screenGroup.children.filter(c => c.name === 'screenSBS');
        if(viewMode === 'vr-3d') { if(mStd) mStd.visible = false; mSBS.forEach(m => m.visible = true); } else { if(mStd) mStd.visible = true; mSBS.forEach(m => m.visible = false); }
        if(viewMode === 'full') { renderer.setScissorTest(false); renderer.setViewport(0, 0, window.innerWidth, window.innerHeight); renderer.render(scene, camera); } else { effect.setUniforms(params.i, params.z); effect.render(scene, camera); }
    }
    function handleInput(e) {
        e.stopPropagation(); const t = e.target.closest('button, .prog-track'); if(!t) return; const cl = t.classList;
        if(cl.contains('m-full')) { viewMode='full'; params.z=1.0; params.d=3.0; updateOverlay(); }
        if(cl.contains('m-2d')) { viewMode='vr-2d'; updateOverlay(); }
        if(cl.contains('m-3d')) { viewMode='vr-3d'; updateOverlay(); }
        if(cl.contains('zin')) params.z += 0.1; if(cl.contains('zout')) params.z -= 0.1; if(cl.contains('zrst')) params.z = defs.z;
        if(cl.contains('dinc')) params.d += 0.5; if(cl.contains('ddec')) params.d -= 0.5; if(cl.contains('drst')) params.d = defs.d;
        if(cl.contains('iinc')) params.i += 0.005; if(cl.contains('idec')) params.i -= 0.005; if(cl.contains('irst')) params.i = defs.i;
        if(cl.contains('rec')) screenGroup.quaternion.copy(camera.quaternion);
        if(cl.contains('prog-track')) { const r = t.getBoundingClientRect(); videoEl.currentTime = ((e.clientX - r.left)/r.width) * videoEl.duration; }
        if(cl.contains('pp')) videoEl.paused ? videoEl.play() : videoEl.pause();
        if(cl.contains('rw')) videoEl.currentTime -= 10; if(cl.contains('fw')) videoEl.currentTime += 10;
        document.querySelectorAll('.pp').forEach(b => b.textContent = videoEl.paused ? '▶' : '||');
    }
    function updateProg() { const p = (videoEl.currentTime / videoEl.duration) * 100; document.querySelectorAll('.prog-fill').forEach(f => f.style.width = p + '%'); }
    class Tracker {
        constructor() { this.q = new THREE.Quaternion(); this.e = null; }
        connect() { window.addEventListener('deviceorientation', e => this.e = e); }
        getQ() { return this.q; }
        update() {
            if(!this.e) return; const d = this.e;
            const a = THREE.Math.degToRad(d.alpha || 0); const b = THREE.Math.degToRad(d.beta || 0); const g = THREE.Math.degToRad(d.gamma || 0);
            const o = (screen.orientation ? screen.orientation.angle : window.orientation || 0) * Math.PI / 180;
            const q0 = new THREE.Quaternion(); const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
            this.q.setFromEuler(new THREE.Euler(b, a, -g, 'YXZ')).multiply(q1).multiply(q0.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -o));
        }
    }
    function StereoEffect(r, videoElement) {
        const _s = new THREE.StereoCamera(); _s.aspect = 0.5;
        const dpr = window.devicePixelRatio || 1; const vidW = videoElement && videoElement.videoWidth ? videoElement.videoWidth : 1920;
        const sz = (sw, sh) => Math.min(Math.max(Math.floor(sw * dpr), vidW), 4096);
        let w = sz(window.innerWidth), h = sz(window.innerHeight);
        const opts = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, depthBuffer: false, stencilBuffer: false };
        let _tL = new THREE.WebGLRenderTarget(w, h, opts); let _tR = new THREE.WebGLRenderTarget(w, h, opts);
        const _m = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: {value: null}, texSize: {value: new THREE.Vector2(w, h)}, zoom: {value: 1}, ipd: {value: 0} },
            vertexShader: document.getElementById('vs').textContent, fragmentShader: document.getElementById('fs').textContent
        });
        const _sc = new THREE.Scene(); _sc.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), _m));
        const _c = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.setSize = (sw, sh) => {
            r.setSize(sw, sh); let nw = sz(sw), nh = sz(sh);
            if(nw !== w || nh !== h) { w = nw; h = nh; _tL.dispose(); _tR.dispose(); _tL = new THREE.WebGLRenderTarget(w, h, opts); _tR = new THREE.WebGLRenderTarget(w, h, opts); _m.uniforms.texSize.value.set(w, h); }
        };
        this.setUniforms = (i, z) => { _m.uniforms.ipd.value = i; _m.uniforms.zoom.value = z; };
        this.render = (s, c) => {
            s.updateMatrixWorld(); _s.update(c);
            if(viewMode === 'vr-3d') _s.cameraL.layers.set(1); else _s.cameraL.layers.set(0);
            r.setRenderTarget(_tL); r.clear(); r.render(s, _s.cameraL);
            if(viewMode === 'vr-3d') _s.cameraR.layers.set(2); else _s.cameraR.layers.set(0);
            r.setRenderTarget(_tR); r.clear(); r.render(s, _s.cameraR);
            r.setRenderTarget(null); const sw = window.innerWidth, sh = window.innerHeight; r.setScissorTest(true);
            r.setScissor(0, 0, sw/2, sh); r.setViewport(0, 0, sw/2, sh); _m.uniforms.tDiffuse.value = _tL.texture; _m.uniforms.ipd.value = params.i; r.render(_sc, _c);
            r.setScissor(sw/2, 0, sw/2, sh); r.setViewport(sw/2, 0, sw/2, sh); _m.uniforms.tDiffuse.value = _tR.texture; _m.uniforms.ipd.value = -params.i; r.render(_sc, _c);
            r.setScissorTest(false);
        };
    }
<\/script>
</body>
</html>`;
    }

    function getWebXRSource() {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Cinema Player</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; color: white; }
        canvas { display: block; width: 100vw; height: 100vh; touch-action: none; }
        #setup { position: fixed; inset: 0; background: #121212; z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        .setup-box { width: 100%; max-width: 400px; background: #1e1e1e; padding: 25px; border-radius: 16px; border: 1px solid #333; text-align: center; }
        .file-btn { display: block; background: #252525; padding: 20px; text-align: center; border-radius: 12px; cursor: pointer; border: 2px dashed #444; transition: 0.2s; }
        #fileInput { display: none; }
        #startBtn { width: 100%; padding: 16px; margin-top: 20px; background: #007bff; color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: bold; cursor: pointer; opacity: 0.5; pointer-events: none; }
        #startBtn.ready { opacity: 1; pointer-events: auto; }
        #overlay { position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.5); z-index: 9999; display: none; justify-content: center; padding: 10px 0; transition: opacity 0.3s; }
        #overlay.visible { display: flex; opacity: 1; }
        .ctrl-panel { width: 320px; display: flex; flex-direction: column; align-items: center; gap: 6px; padding: 0 5px; }
        .row { display: flex; gap: 6px; justify-content: center; width: 100%; align-items: center; }
        button { cursor: pointer; }
        .btn-icon { width: 32px; height: 32px; border-radius: 50%; background: #333; color: white; border: none; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: bold; }
        .btn-pill { padding: 6px 12px; border-radius: 15px; background: #333; color: white; border: none; font-size: 11px; font-weight: bold; min-width: 50px; }
        .btn-pill.active { background: #007bff; color: white; }
        .btn-wide { width: 90%; padding: 10px; background: #007bff; color: white; border: none; border-radius: 6px; font-weight: bold; margin-top: 4px; }
        .lbl { font-size: 10px; color: #ddd; text-transform: uppercase; margin-top: 5px; font-weight: bold; text-shadow: 0 1px 2px black; }
        .prog-track { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; position: relative; margin-bottom: 5px; cursor: pointer; }
        .prog-fill { height: 100%; background: #007bff; width: 0%; border-radius: 5px; pointer-events: none; }
    </style>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    <\/script>
</head>
<body>

<div id="setup">
    <div class="setup-box">
        <h2>VR Cinema</h2>
        <label for="fileInput" class="file-btn" id="fileLabel">Select Video File</label>
        <input type="file" id="fileInput" accept="video/*">
        <button id="startBtn">LOAD PLAYER</button>
    </div>
</div>

<div id="overlay"></div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { VRButton } from 'three/addons/webxr/VRButton.js';

    let scene, camera, renderer, controls;
    let video, videoTexture, screenGroup, mesh2D, meshLeft, meshRight;
    let currentDistance = 6.0;
    let currentScale = 1.0;
    let viewMode = 'vr-2d';
    let hideTimer = null;
    let vrBtn;

    const els = {
        setup: document.getElementById('setup'),
        fileInput: document.getElementById('fileInput'),
        startBtn: document.getElementById('startBtn'),
        label: document.getElementById('fileLabel'),
        overlay: document.getElementById('overlay')
    };

    els.fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        window.videoSrc = URL.createObjectURL(file);
        els.label.textContent = file.name;
        els.startBtn.classList.add('ready');
    });

    els.startBtn.addEventListener('click', () => {
        if (!window.videoSrc) return;
        els.setup.style.display = 'none';
        init();
    });

    window.initVR = function() { init(); };

    function init() {
        video = document.createElement('video');
        video.src = window.videoSrc;
        video.crossOrigin = "anonymous";
        video.playsInline = true;
        video.loop = true;
        video.play();
        video.addEventListener('timeupdate', updateProg);
        video.addEventListener('loadedmetadata', updateScreenTransform);

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        document.body.appendChild(renderer.domElement);

        vrBtn = VRButton.createButton(renderer);
        vrBtn.id = "VRButton";
        vrBtn.style.display = 'none';
        document.body.appendChild(vrBtn);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, -currentDistance);
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.rotateSpeed = -0.5;
        controls.update();

        createCinemaScreen();

        renderer.xr.addEventListener('sessionend', fallbackToWebGL);

        renderer.setAnimationLoop(() => {
            controls.update();
            renderer.render(scene, camera);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        document.addEventListener('click', (e) => { 
            if(e.target.closest('#overlay')) { resetTimer(); return; } 
            if(els.overlay.classList.contains('visible')) hideOverlay(); 
            else showOverlay(); 
        });
        
        els.overlay.addEventListener('click', handleInput);
        
        updateOverlay();
        showOverlay();
    }

    function fallbackToWebGL() {
        const webglSource = sessionStorage.getItem('_webgl_source');
        const videoUrl = sessionStorage.getItem('_video_url');
        if (!webglSource || !videoUrl) return;

        const state = {
            currentTime: video.currentTime,
            paused: video.paused,
            viewMode: viewMode,
            scale: currentScale,
            distance: currentDistance
        };

        const bootstrapper = \`
            <script>
                const _LAUNCH_URL = "\${videoUrl}";
                const _RESTORE_STATE = \${JSON.stringify(state)};
                window.addEventListener('DOMContentLoaded', () => {
                    const style = document.createElement('style');
                    style.innerHTML = '#setup { display: none !important; }';
                    document.head.appendChild(style);

                    srcURL = _LAUNCH_URL;
                    viewMode = _RESTORE_STATE.viewMode;
                    params.z = _RESTORE_STATE.scale;
                    params.d = _RESTORE_STATE.distance;
                    
                    initEngine();
                    
                    const waitForVideo = setInterval(() => {
                        if(videoEl && videoEl.readyState >= 1) {
                            clearInterval(waitForVideo);
                            videoEl.currentTime = _RESTORE_STATE.currentTime;
                            if(_RESTORE_STATE.paused) videoEl.pause();
                            updateOverlay();
                        }
                    }, 50);
                });
            <\\/script>
        \`;

        const finalHtml = webglSource.replace('</body>', bootstrapper + '</body>');

        document.open();
        document.write(finalHtml);
        document.close();
    }

    function createCinemaScreen() {
        videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;
        videoTexture.colorSpace = THREE.SRGBColorSpace;

        screenGroup = new THREE.Group();
        updateScreenTransform();
        scene.add(screenGroup);

        const geo = new THREE.PlaneGeometry(1, 1);

        mesh2D = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide }));
        mesh2D.layers.enable(1); mesh2D.layers.enable(2);
        screenGroup.add(mesh2D);

        const geoL = geo.clone();
        const uvL = geoL.attributes.uv;
        for(let i=0; i<uvL.count; i++) uvL.setX(i, uvL.getX(i) * 0.5);
        meshLeft = new THREE.Mesh(geoL, new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide }));
        meshLeft.layers.set(1); 
        meshLeft.visible = false;
        screenGroup.add(meshLeft);

        const geoR = geo.clone();
        const uvR = geoR.attributes.uv;
        for(let i=0; i<uvR.count; i++) uvR.setX(i, (uvR.getX(i) * 0.5) + 0.5);
        meshRight = new THREE.Mesh(geoR, new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide }));
        meshRight.layers.set(2);
        meshRight.visible = false;
        screenGroup.add(meshRight);
    }

    function updateOverlay() {
        resetTimer();
        const is2D = (viewMode === 'vr-2d' || viewMode === 'full');
        
        const controls = \`
            <div class="row">
                <div class="prog-track"><div class="prog-fill"></div></div>
            </div>
            <div class="row">
                <button class="btn-icon rw">&laquo;</button>
                <button class="btn-icon pp">▶</button>
                <button class="btn-icon fw">&raquo;</button>
            </div>
            <div class="lbl">View Mode</div>
            <div class="row">
                <button class="btn-pill m-2d \${is2D ? 'active' : ''}">2D</button>
                <button class="btn-pill m-3d \${!is2D ? 'active' : ''}">3D</button>
            </div>
            <div class="lbl">Zoom</div>
            <div class="row">
                <button class="btn-icon zout">-</button>
                <button class="btn-pill zrst">RESET</button>
                <button class="btn-icon zin">+</button>
            </div>
            <div class="lbl">Distance</div>
            <div class="row">
                <button class="btn-icon ddec">-</button>
                <button class="btn-pill drst">RESET</button>
                <button class="btn-icon dinc">+</button>
            </div>
            
            <div style="height: 25px;"></div>
            
            <button class="btn-wide enter-vr">ENTER VR</button>
        \`;
        
        els.overlay.innerHTML = \`<div class="ctrl-panel">\${controls}</div>\`;
    }

    function showOverlay() { els.overlay.classList.add('visible'); resetTimer(); }
    function hideOverlay() { els.overlay.classList.remove('visible'); }
    function resetTimer() { if(hideTimer) clearTimeout(hideTimer); hideTimer = setTimeout(hideOverlay, 4000); }

    function handleInput(e) {
        e.stopPropagation();
        const t = e.target.closest('button, .prog-track');
        if(!t) return;
        const cl = t.classList;

        if(cl.contains('pp')) { video.paused ? video.play() : video.pause(); }
        if(cl.contains('rw')) { video.currentTime -= 10; }
        if(cl.contains('fw')) { video.currentTime += 10; }
        
        if(cl.contains('m-2d')) { 
            viewMode = 'vr-2d';
            mesh2D.visible = true; meshLeft.visible = false; meshRight.visible = false;
            updateOverlay();
            updateScreenTransform();
        }
        if(cl.contains('m-3d')) { 
            viewMode = 'vr-3d';
            mesh2D.visible = false; meshLeft.visible = true; meshRight.visible = true; 
            meshLeft.layers.enable(0);
            updateOverlay();
            updateScreenTransform();
        }

        if(cl.contains('zin')) { currentScale += 0.1; }
        if(cl.contains('zout')) { currentScale -= 0.1; }
        if(cl.contains('zrst')) { currentScale = 1.0; }

        if(cl.contains('dinc')) { currentDistance += 0.5; }
        if(cl.contains('ddec')) { currentDistance -= 0.5; }
        if(cl.contains('drst')) { currentDistance = 6.0; }

        if(cl.contains('zin') || cl.contains('zout') || cl.contains('zrst') || 
           cl.contains('dinc') || cl.contains('ddec') || cl.contains('drst')) {
            updateScreenTransform();
        }

        if(cl.contains('prog-track')) {
            const r = t.getBoundingClientRect();
            video.currentTime = ((e.clientX - r.left)/r.width) * video.duration;
        }

        if(cl.contains('enter-vr')) {
            if(vrBtn) vrBtn.click();
            t.textContent = "CHECK HEADSET";
        }
    }

    function updateScreenTransform() {
        if(currentDistance < 2.0) currentDistance = 2.0;
        if(currentDistance > 20.0) currentDistance = 20.0;
        if(currentScale < 0.2) currentScale = 0.2;
        if(currentScale > 3.0) currentScale = 3.0;

        let vidAspect = (video.videoWidth && video.videoHeight) ? video.videoWidth / video.videoHeight : 1.777;

        if (viewMode === 'vr-3d') {
            vidAspect = vidAspect / 2.0;
        }

        const baseWidth = 8 * currentScale;
        const baseHeight = baseWidth / vidAspect;

        if(screenGroup) {
            screenGroup.position.set(0, 0, -currentDistance);
            screenGroup.scale.set(baseWidth, baseHeight, 1);
        }

        if(controls) {
            controls.target.set(0, 0, -currentDistance);
            controls.update();
        }
    }

    function updateProg() { 
        if(!video) return;
        const p = (video.currentTime / video.duration) * 100; 
        document.querySelectorAll('.prog-fill').forEach(f => f.style.width = p + '%');
        document.querySelectorAll('.pp').forEach(b => b.textContent = video.paused ? '▶' : '||');
    }
<\/script>
</body>
</html>`;
    }
</script>
</body>
</html>
