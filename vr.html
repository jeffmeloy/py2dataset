<!DOCTYPE html>
<html lang="en">
<head>
    <title>Hybrid VR Player (Lanczos)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
        /* --- GENERAL STYLES --- */
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; color: white; }
        
        /* --- SETUP SCREEN --- */
        #setup { position: fixed; inset: 0; background: #121212; z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px; }
        
        .setup-box { 
            width: 100%; max-width: 450px; 
            background: #1e1e1e; padding: 25px; 
            border-radius: 12px; border: 1px solid #333;
            display: flex; flex-direction: column; gap: 20px; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .file-btn { 
            display: block; background: #2a2a2a; color: #aaa;
            padding: 20px; text-align: center; border-radius: 8px; 
            cursor: pointer; border: 2px dashed #444; font-weight: bold;
            transition: 0.2s;
        }
        .file-btn:hover { border-color: #007bff; color: white; background: #333; }
        #fileInput { display: none; }

        .preview-box { 
            height: 220px; background: black; 
            border: 1px solid #333; border-radius: 8px; 
            overflow: hidden; position: relative; 
            display: flex; align-items: center; justify-content: center; 
        }
        
        #placeholder { color: #555; pointer-events: none; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; }
        
        /* Preview Video Styling */
        #pVideo { 
            width: 100%; height: 100%; 
            object-fit: contain; display: none; 
            outline: none;
        }

        #startBtn { 
            width: 100%; padding: 18px; 
            background: #007bff; color: white; 
            border: none; border-radius: 8px; 
            font-size: 16px; font-weight: bold; letter-spacing: 1px;
            cursor: pointer; margin-top: 5px; 
            text-transform: uppercase;
        }
        #startBtn:disabled { background: #333; color: #555; cursor: not-allowed; }

        /* --- OVERLAY UI --- */
        #overlay { 
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: linear-gradient(to top, rgba(0,0,0,0.9), rgba(0,0,0,0)); 
            z-index: 9999; display: none; padding: 20px 0; 
            transition: opacity 0.3s; 
        }
        #overlay.visible { display: flex; opacity: 1; }
        #overlay.single { justify-content: center; } 
        #overlay.split { justify-content: space-around; }
        
        .ctrl-panel { width: 340px; display: flex; flex-direction: column; align-items: center; gap: 8px; padding: 0 10px; }
        .row { display: flex; gap: 8px; justify-content: center; width: 100%; align-items: center; }
        
        button { cursor: pointer; outline: none; -webkit-tap-highlight-color: transparent; }
        
        .btn-icon { 
            width: 36px; height: 36px; border-radius: 50%; 
            background: rgba(255,255,255,0.1); color: white; 
            border: 1px solid rgba(255,255,255,0.2); 
            display: flex; align-items: center; justify-content: center; 
            font-size: 14px; 
        }
        .btn-icon:hover { background: rgba(255,255,255,0.3); }

        .btn-pill { 
            padding: 8px 16px; border-radius: 20px; 
            background: rgba(255,255,255,0.1); color: #ccc; 
            border: 1px solid rgba(255,255,255,0.2); 
            font-size: 11px; font-weight: bold; min-width: 60px; 
        }
        .btn-pill.active { background: #007bff; color: white; border-color: #007bff; }

        .btn-wide { 
            width: 100%; padding: 12px; 
            background: rgba(200, 0, 0, 0.8); color: white; 
            border: none; border-radius: 6px; 
            font-weight: bold; margin-top: 8px; 
            font-size: 12px; letter-spacing: 1px;
        }

        .lbl { font-size: 10px; color: #888; text-transform: uppercase; margin-top: 4px; font-weight: bold; letter-spacing: 1px; }
        
        .prog-track { 
            width: 100%; height: 8px; 
            background: rgba(255,255,255,0.2); 
            border-radius: 4px; position: relative; 
            margin-bottom: 8px; cursor: pointer; 
        }
        .prog-fill { height: 100%; background: #007bff; width: 0%; border-radius: 4px; pointer-events: none; }

        #webgl-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    </style>
    
    <!-- Using Import Map for modern Three.js modules -->
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
</head>
<body>

<!-- SETUP UI -->
<div id="setup">
    <div class="setup-box">
        <div>
            <label for="fileInput" class="file-btn" id="fileLabel">Tap to Select Video File</label>
            <input type="file" id="fileInput" accept="video/*">
        </div>
        <div class="preview-box">
            <span id="placeholder">No Video Selected</span>
            <!-- Added 'controls' here as requested -->
            <video id="pVideo" playsinline controls></video>
        </div>
        <button id="startBtn" disabled>ENTER VR</button>
    </div>
</div>

<!-- IN-VR OVERLAY -->
<div id="overlay"></div>

<!-- SHADERS -->
<script id="vs" type="x-shader/x-vertex">varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}</script>
<script id="fs" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D tDiffuse; uniform vec2 texSize; uniform float ipd; uniform float zoom; varying vec2 vUv;
    const float PI = 3.14159265359;
    
    // Lanczos Filtering Math
    float sinc(float x){ if(abs(x)<0.0001)return 1.0; float a=PI*x; return sin(a)/a; }
    float lw(float x){ if(abs(x)>=2.0)return 0.0; return sinc(x)*sinc(x*0.5); }

    vec4 textureLanczos(sampler2D smp, vec2 uv, vec2 size) {
        vec2 inv = 1.0/size; vec2 pos = uv*size; vec2 ipos = floor(pos-0.5)+0.5; vec2 f = pos-ipos;
        vec4 wX = vec4(lw(1.0+f.x), lw(f.x), lw(1.0-f.x), lw(2.0-f.x));
        vec4 wY = vec4(lw(1.0+f.y), lw(f.y), lw(1.0-f.y), lw(2.0-f.y));
        wX /= dot(wX, vec4(1.0)); wY /= dot(wY, vec4(1.0));
        
        vec4 r0 = texture2D(smp, (ipos+vec2(-1,-1))*inv)*wX.x + texture2D(smp, (ipos+vec2(0,-1))*inv)*wX.y + texture2D(smp, (ipos+vec2(1,-1))*inv)*wX.z + texture2D(smp, (ipos+vec2(2,-1))*inv)*wX.w;
        vec4 r1 = texture2D(smp, (ipos+vec2(-1, 0))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 0))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 0))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 0))*inv)*wX.w;
        vec4 r2 = texture2D(smp, (ipos+vec2(-1, 1))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 1))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 1))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 1))*inv)*wX.w;
        vec4 r3 = texture2D(smp, (ipos+vec2(-1, 2))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 2))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 2))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 2))*inv)*wX.w;
        return r0*wY.x + r1*wY.y + r2*wY.z + r3*wY.w;
    }

    // Barrel Distortion
    vec2 distort(vec2 p){ vec2 c=vec2(0.5); vec2 v=p-c; float r2=dot(v,v); return c+v*(1.0+r2*(0.22+0.18*r2)); }

    void main(){
        vec2 d = distort(vUv);
        vec2 uv = (d-vec2(0.5))/zoom; uv.x+=ipd; uv+=vec2(0.5);
        if(uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0) gl_FragColor=vec4(0.0);
        else gl_FragColor=textureLanczos(tDiffuse, uv, texSize);
    }
</script>

<script type="module">
    import * as THREE from 'three';

    // --- VARIABLES ---
    let viewMode = 'full', srcURL = null, hideTimer = null;
    const defs = { z: 1.0, d: 3.0, i: 0.0 };
    let params = { ...defs };
    let videoAspect = 16/9;

    const els = { 
        setup: document.getElementById('setup'), 
        pVid: document.getElementById('pVideo'), 
        enter: document.getElementById('startBtn'), 
        lbl: document.getElementById('fileLabel'), 
        overlay: document.getElementById('overlay'),
        fileInput: document.getElementById('fileInput'),
        placeholder: document.getElementById('placeholder')
    };

    let scene, camera, renderer, effect, videoEl, screenGroup, tracker;

    // --- SETUP LOGIC ---
    els.fileInput.addEventListener('change', (e) => {
        const f = e.target.files[0]; if(!f) return;
        srcURL = URL.createObjectURL(f);
        
        // Setup Preview
        els.pVid.src = srcURL; 
        els.pVid.style.display = 'block';
        els.placeholder.style.display = 'none'; 
        els.lbl.textContent = f.name; 
        els.enter.disabled = false;
    });

    els.enter.addEventListener('click', async () => {
        // Pause preview so audio doesn't overlap
        els.pVid.pause();

        // iOS Permission Check
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') { 
            try { await DeviceOrientationEvent.requestPermission(); } catch (e) {} 
        }
        
        // Fullscreen
        const de = document.documentElement; 
        if(de.requestFullscreen) de.requestFullscreen();
        if(screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(()=>{});
        
        // Transition
        els.setup.style.display = 'none'; 
        viewMode = 'full'; 
        initEngine(); 
        updateOverlay();
    });

    // --- OVERLAY GENERATION ---
    function updateOverlay() {
        const isFull = (viewMode === 'full'); 
        els.overlay.className = isFull ? 'visible single' : 'visible split'; 
        resetTimer();
        
        const controls = `
            <div class="row">
                <div class="prog-track"><div class="prog-fill"></div></div>
            </div>
            <div class="row">
                <button class="btn-icon rw">«</button>
                <button class="btn-icon pp">▶</button>
                <button class="btn-icon fw">»</button>
            </div>
            <div class="lbl">View Mode</div>
            <div class="row">
                <button class="btn-pill m-full ${viewMode==='full'?'active':''}">FULL</button>
                <button class="btn-pill m-2d ${viewMode==='vr-2d'?'active':''}">2D</button>
                <button class="btn-pill m-3d ${viewMode==='vr-3d'?'active':''}">3D</button>
            </div>
            <div class="lbl">Zoom</div>
            <div class="row">
                <button class="btn-icon zout">-</button>
                <button class="btn-pill zrst">R</button>
                <button class="btn-icon zin">+</button>
            </div>
            <div class="lbl">Distance</div>
            <div class="row">
                <button class="btn-icon ddec">-</button>
                <button class="btn-pill drst">R</button>
                <button class="btn-icon dinc">+</button>
            </div>
            <div class="lbl">IPD</div>
            <div class="row">
                <button class="btn-icon idec">-</button>
                <button class="btn-pill irst">R</button>
                <button class="btn-icon iinc">+</button>
            </div>
            <button class="btn-wide rec">RE-CENTER</button>
        `;
        els.overlay.innerHTML = isFull 
            ? `<div class="ctrl-panel">${controls}</div>` 
            : `<div class="ctrl-panel">${controls}</div><div class="ctrl-panel">${controls}</div>`;
    }

    // --- MAIN 3D ENGINE ---
    function initEngine() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
        screenGroup = new THREE.Group(); 
        scene.add(screenGroup); 
        scene.add(camera);
        
        tracker = new Tracker(); 
        tracker.connect();

        // Create main video element for Texture
        videoEl = document.createElement('video'); 
        videoEl.src = srcURL; 
        videoEl.playsInline = true; 
        videoEl.loop = false;
        
        videoEl.addEventListener('loadedmetadata', () => {
            if(videoEl.videoHeight) videoAspect = videoEl.videoWidth / videoEl.videoHeight;
        });

        const tex = new THREE.VideoTexture(videoEl); 
        tex.minFilter = THREE.LinearFilter; 
        tex.magFilter = THREE.LinearFilter;
        tex.colorSpace = THREE.SRGBColorSpace;
        
        const geo = new THREE.PlaneGeometry(6, 6); 
        
        // Mesh 1: Standard Full 2D (Layer 0)
        const mStd = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({map:tex, side:2})); 
        mStd.name = 'screenStandard'; 
        screenGroup.add(mStd);
        
        // Shaders for Splitting Left/Right eyes
        const vs = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
        const fsL = `precision highp float; uniform sampler2D map; varying vec2 vUv; void main() { gl_FragColor = texture2D(map, vec2(vUv.x*0.5, vUv.y)); }`;
        const fsR = `precision highp float; uniform sampler2D map; varying vec2 vUv; void main() { gl_FragColor = texture2D(map, vec2(vUv.x*0.5+0.5, vUv.y)); }`;
        
        // Mesh 2: Left Eye Crop (Layer 1)
        const mL = new THREE.Mesh(geo, new THREE.ShaderMaterial({uniforms:{map:{value:tex}}, vertexShader:vs, fragmentShader:fsL, side:2})); 
        mL.layers.set(1);
        
        // Mesh 3: Right Eye Crop (Layer 2)
        const mR = new THREE.Mesh(geo, new THREE.ShaderMaterial({uniforms:{map:{value:tex}}, vertexShader:vs, fragmentShader:fsR, side:2})); 
        mR.layers.set(2);
        
        mL.name = mR.name = 'screenSBS'; 
        screenGroup.add(mL); 
        screenGroup.add(mR);

        // WebGL Renderer
        renderer = new THREE.WebGLRenderer({antialias:false, powerPreference:"high-performance"});
        renderer.domElement.id = 'webgl-canvas'; 
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); 
        document.body.appendChild(renderer.domElement);
        
        tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
        
        // Initialize the Custom Stereo Renderer
        effect = new StereoEffect(renderer, videoEl); 
        effect.setSize(window.innerWidth, window.innerHeight);
        
        videoEl.play(); 
        videoEl.addEventListener('timeupdate', updateProg);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(effect) effect.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Overlay Interactions
        document.addEventListener('click', (e) => { 
            if(e.target.closest('#overlay')) { resetTimer(); return; } 
            if(els.overlay.classList.contains('visible')) hideOverlay(); 
            else showOverlay(); 
        });
        els.overlay.addEventListener('click', handleInput);
        
        animate();
    }

    function showOverlay() { els.overlay.classList.add('visible'); resetTimer(); }
    function hideOverlay() { els.overlay.classList.remove('visible'); }
    function resetTimer() { if(hideTimer) clearTimeout(hideTimer); hideTimer = setTimeout(hideOverlay, 3000); }

    // --- ANIMATION LOOP ---
    function animate() {
        requestAnimationFrame(animate); 
        tracker.update(); 
        camera.quaternion.copy(tracker.getQ());
        
        // Distance & Scale logic
        let z = (viewMode === 'full') ? -1.8 * params.d / 3.0 : -params.d;
        let s = ((viewMode === 'full') ? 0.6 : 1.0) * params.z;

        let effectiveAspect = videoAspect;
        if(viewMode === 'vr-3d') effectiveAspect = videoAspect / 2.0;

        screenGroup.children.forEach(c => { 
            c.position.z = z; 
            c.scale.set(s, s / effectiveAspect, s); 
        });
        
        // Visibility Logic (Swapping 2D vs 3D meshes)
        const mStd = screenGroup.getObjectByName('screenStandard');
        const mSBS = screenGroup.children.filter(c => c.name === 'screenSBS');
        
        if(viewMode === 'vr-3d') { 
            if(mStd) mStd.visible = false; 
            mSBS.forEach(m => m.visible = true); 
        } else { 
            if(mStd) mStd.visible = true; 
            mSBS.forEach(m => m.visible = false); 
        }

        // Render based on mode
        if(viewMode === 'full') {
            renderer.setScissorTest(false); 
            renderer.setViewport(0, 0, window.innerWidth, window.innerHeight); 
            renderer.render(scene, camera);
        } else {
            effect.setUniforms(params.i, params.z); 
            effect.render(scene, camera);
        }
    }

    // --- INPUT HANDLER ---
    function handleInput(e) {
        e.stopPropagation(); 
        const t = e.target.closest('button, .prog-track'); 
        if(!t) return; 
        const cl = t.classList;
        
        if(cl.contains('m-full')) { viewMode='full'; params.z=1.0; params.d=3.0; updateOverlay(); }
        if(cl.contains('m-2d')) { viewMode='vr-2d'; updateOverlay(); }
        if(cl.contains('m-3d')) { viewMode='vr-3d'; updateOverlay(); }
        
        if(cl.contains('zin')) params.z += 0.1; 
        if(cl.contains('zout')) params.z -= 0.1; 
        if(cl.contains('zrst')) params.z = defs.z;
        
        if(cl.contains('dinc')) params.d += 0.5; 
        if(cl.contains('ddec')) params.d -= 0.5; 
        if(cl.contains('drst')) params.d = defs.d;
        
        if(cl.contains('iinc')) params.i += 0.005; 
        if(cl.contains('idec')) params.i -= 0.005; 
        if(cl.contains('irst')) params.i = defs.i;
        
        if(cl.contains('rec')) screenGroup.quaternion.copy(camera.quaternion);
        
        if(cl.contains('prog-track')) { 
            const r = t.getBoundingClientRect(); 
            videoEl.currentTime = ((e.clientX - r.left)/r.width) * videoEl.duration; 
        }
        if(cl.contains('pp')) videoEl.paused ? videoEl.play() : videoEl.pause();
        if(cl.contains('rw')) videoEl.currentTime -= 10; 
        if(cl.contains('fw')) videoEl.currentTime += 10;
        
        document.querySelectorAll('.pp').forEach(b => b.textContent = videoEl.paused ? '▶' : '||');
    }

    function updateProg() { 
        const p = (videoEl.currentTime / videoEl.duration) * 100; 
        document.querySelectorAll('.prog-fill').forEach(f => f.style.width = p + '%'); 
    }

    // --- HEAD TRACKER (Gyroscope) ---
    class Tracker {
        constructor() { this.q = new THREE.Quaternion(); this.e = null; }
        connect() { window.addEventListener('deviceorientation', e => this.e = e); }
        getQ() { return this.q; }
        update() {
            if(!this.e) return;
            const d = this.e;
            // Updated to use MathUtils for modern Three.js
            const a = THREE.MathUtils.degToRad(d.alpha || 0);
            const b = THREE.MathUtils.degToRad(d.beta || 0);
            const g = THREE.MathUtils.degToRad(d.gamma || 0);
            const o = (screen.orientation ? screen.orientation.angle : window.orientation || 0) * Math.PI / 180;
            const q0 = new THREE.Quaternion();
            const q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5));
            this.q.setFromEuler(new THREE.Euler(b, a, -g, 'YXZ')).multiply(q1).multiply(q0.setFromAxisAngle(new THREE.Vector3(0, 0, 1), -o));
        }
    }

    // --- CUSTOM RENDERER (Distortion + Lanczos) ---
    function StereoEffect(r, videoElement) {
        const _s = new THREE.StereoCamera(); 
        _s.aspect = 0.5;
        const dpr = window.devicePixelRatio || 1;
        const vidW = videoElement && videoElement.videoWidth ? videoElement.videoWidth : 1920;
        
        // Ensure texture isn't too massive for mobile, but high quality if possible
        const sz = (sw, sh) => Math.min(Math.max(Math.floor(sw * dpr), vidW), 4096);
        
        let w = sz(window.innerWidth), h = sz(window.innerHeight);
        const opts = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, depthBuffer: false, stencilBuffer: false };
        
        let _tL = new THREE.WebGLRenderTarget(w, h, opts);
        let _tR = new THREE.WebGLRenderTarget(w, h, opts);
        
        // The Distortion Shader Material
        const _m = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: {value: null}, texSize: {value: new THREE.Vector2(w, h)}, zoom: {value: 1}, ipd: {value: 0} },
            vertexShader: document.getElementById('vs').textContent, 
            fragmentShader: document.getElementById('fs').textContent
        });
        
        const _sc = new THREE.Scene(); 
        _sc.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), _m));
        const _c = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        
        this.setSize = (sw, sh) => {
            r.setSize(sw, sh); 
            let nw = sz(sw), nh = sz(sh);
            if(nw !== w || nh !== h) { 
                w = nw; h = nh; 
                _tL.dispose(); _tR.dispose(); 
                _tL = new THREE.WebGLRenderTarget(w, h, opts); 
                _tR = new THREE.WebGLRenderTarget(w, h, opts); 
                _m.uniforms.texSize.value.set(w, h);
            }
        };
        
        this.setUniforms = (i, z) => { 
            _m.uniforms.ipd.value = i; 
            _m.uniforms.zoom.value = z; 
        };
        
        this.render = (s, c) => {
            s.updateMatrixWorld(); 
            _s.update(c);
            
            // Render LEFT Eye (Layer 1 if 3D, Layer 0 if 2D)
            if(viewMode === 'vr-3d') _s.cameraL.layers.set(1); 
            else _s.cameraL.layers.set(0);
            r.setRenderTarget(_tL); r.clear(); r.render(s, _s.cameraL);
            
            // Render RIGHT Eye (Layer 2 if 3D, Layer 0 if 2D)
            if(viewMode === 'vr-3d') _s.cameraR.layers.set(2); 
            else _s.cameraR.layers.set(0);
            r.setRenderTarget(_tR); r.clear(); r.render(s, _s.cameraR);
            
            // Render Distorted Result to Screen
            r.setRenderTarget(null);
            const sw = window.innerWidth, sh = window.innerHeight; 
            r.setScissorTest(true);
            
            // Left Half
            r.setScissor(0, 0, sw/2, sh); 
            r.setViewport(0, 0, sw/2, sh); 
            _m.uniforms.tDiffuse.value = _tL.texture; 
            _m.uniforms.ipd.value = params.i; 
            r.render(_sc, _c);
            
            // Right Half
            r.setScissor(sw/2, 0, sw/2, sh); 
            r.setViewport(sw/2, 0, sw/2, sh); 
            _m.uniforms.tDiffuse.value = _tR.texture; 
            _m.uniforms.ipd.value = -params.i; 
            r.render(_sc, _c);
            
            r.setScissorTest(false);
        };
    }
</script>
</body>
</html>
