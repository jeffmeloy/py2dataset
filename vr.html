<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Player - SBS Setup</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* CORE */
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: system-ui, -apple-system, sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* SPLIT SCREEN SETUP UI */
        #setup { 
            position: fixed; inset: 0; z-index: 10000; background: #121212; 
            display: flex; width: 100vw; height: 100vh;
        }
        #setup.hidden { display: none !important; }

        /* Each Eye's View in Setup */
        .setup-eye {
            width: 50%; height: 100%; 
            padding: 20px; box-sizing: border-box;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            border-right: 1px solid #222; /* Divider */
        }

        .menu-box {
            width: 100%; max-width: 400px;
            display: flex; flex-direction: column; gap: 12px;
        }

        h2 { margin: 0 0 10px 0; text-align: center; font-size: 18px; letter-spacing: 1px; color: #aaa; text-transform: uppercase; }

        /* Radio Buttons */
        .radio-group { display: flex; background: #2c2c2c; border-radius: 8px; padding: 4px; }
        .radio-label { 
            flex: 1; text-align: center; padding: 12px; cursor: pointer; border-radius: 6px; 
            color: #888; font-weight: 600; font-size: 14px; transition: 0.2s; 
        }
        .radio-label.selected { background: #007BFF; color: white; }

        /* File Input */
        .file-btn { 
            background: #333; color: #ddd; padding: 16px; border-radius: 8px; 
            text-align: center; font-weight: 600; border: 1px dashed #555; cursor: pointer; display: block; 
        }
        
        /* Preview */
        .preview-container {
            background: #000; border-radius: 8px; height: 150px; width: 100%;
            display: flex; align-items: center; justify-content: center; 
            border: 1px solid #333; overflow: hidden; position: relative;
        }
        .preview-video { width: 100%; height: 100%; object-fit: contain; display: none; }
        .preview-video.active { display: block; }
        .preview-text { position: absolute; color: #555; font-size: 14px; }

        /* Start Button */
        .btn-main { 
            background: #007BFF; color: white; border: none; padding: 16px; 
            font-size: 16px; font-weight: bold; border-radius: 8px; width: 100%; 
            text-transform: uppercase; letter-spacing: 1px; 
        }
        .btn-main:disabled { background: #333; color: #555; }

        /* --- IN-GAME VR OVERLAY --- */
        #overlay { 
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); 
            padding: 40px 0 20px 0; display: none; z-index: 9999; 
            transition: opacity 0.2s; 
        }
        #overlay.visible { display: flex; }
        #overlay.fading { opacity: 0; pointer-events: none; }
        
        .eye-ui { 
            width: 50%; display: flex; flex-direction: column; align-items: center; 
            padding: 0 15px; box-sizing: border-box; 
        }
        
        /* FULL WIDTH SEEK BAR */
        .bar-track { 
            width: 100%; /* Full width of the eye container */
            height: 40px; display: flex; align-items: center; cursor: pointer; margin-bottom: 10px; 
        }
        .bar-bg { width: 100%; height: 12px; background: rgba(255,255,255,0.2); border-radius: 6px; position: relative; overflow: hidden; pointer-events: none; }
        .bar-fill { height: 100%; background: #007BFF; width: 0%; pointer-events: none; }
        
        .row { display: flex; gap: 15px; margin-bottom: 15px; width: 100%; justify-content: center; }
        
        .btn-icon { 
            width: 60px; height: 60px; border-radius: 50%; 
            background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.1); 
            color: white; font-size: 24px; display: flex; align-items: center; justify-content: center; 
            backdrop-filter: blur(5px); cursor: pointer;
        }
        .btn-icon:active { background: rgba(0,123,255,0.8); transform: scale(0.95); }
        .btn-pill { height: 44px; padding: 0 24px; border-radius: 22px; background: rgba(255,255,255,0.15); border: none; color: white; font-weight: bold; backdrop-filter: blur(5px); }
    </style>
</head>
<body>

<!-- HIDDEN REAL INPUT -->
<input type="file" id="realFileInput" accept="video/*" style="display:none">

<!-- SPLIT SCREEN SETUP -->
<div id="setup">
    <!-- LEFT EYE SETUP -->
    <div class="setup-eye">
        <div class="menu-box">
            <h2>VR Player</h2>
            <div class="radio-group">
                <div class="radio-label selected" data-val="2d" onclick="setMode('2d')">2D</div>
                <div class="radio-label" data-val="3d" onclick="setMode('3d')">3D SBS</div>
            </div>
            <label for="realFileInput" class="file-btn file-lbl">Select Video</label>
            <div class="preview-container">
                <span class="preview-text">No Video</span>
                <video class="preview-video" muted playsinline></video>
            </div>
            <button class="btn-main start-btn" disabled onclick="launchVR()">ENTER VR</button>
        </div>
    </div>

    <!-- RIGHT EYE SETUP (Duplicate) -->
    <div class="setup-eye">
        <div class="menu-box">
            <h2>VR Player</h2>
            <div class="radio-group">
                <div class="radio-label selected" data-val="2d" onclick="setMode('2d')">2D</div>
                <div class="radio-label" data-val="3d" onclick="setMode('3d')">3D SBS</div>
            </div>
            <label for="realFileInput" class="file-btn file-lbl">Select Video</label>
            <div class="preview-container">
                <span class="preview-text">No Video</span>
                <video class="preview-video" muted playsinline></video>
            </div>
            <button class="btn-main start-btn" disabled onclick="launchVR()">ENTER VR</button>
        </div>
    </div>
</div>

<!-- IN-GAME OVERLAY -->
<div id="overlay">
    <div class="eye-ui" id="uiL"></div>
    <div class="eye-ui" id="uiR"></div>
</div>

<!-- CONTROLS TEMPLATE -->
<template id="uiTemplate">
    <div class="bar-track">
        <div class="bar-bg"><div class="bar-fill"></div></div>
    </div>
    <div class="row">
        <button class="btn-icon pan-l">&larr;</button>
        <button class="btn-icon pan-c">⦾</button>
        <button class="btn-icon pan-r">&rarr;</button>
    </div>
    <div class="row">
        <button class="btn-icon rew">↺</button>
        <button class="btn-icon pp">▶</button>
        <button class="btn-icon fwd">↻</button>
    </div>
    <div class="row">
        <button class="btn-icon zoom-out">-</button>
        <button class="btn-pill zr">ZOOM</button>
        <button class="btn-icon zoom-in">+</button>
    </div>
</template>

<!-- SHADERS (Standard Geometry-Based) -->
<script id="vert" type="x-shader/x-vertex">
    precision highp float;
    varying vec2 vUv;
    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
</script>

<script id="frag" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D tDiffuse;
    uniform float k1;
    uniform float k2;
    uniform float headYawOffset;
    uniform float headPitchOffset;
    uniform float manualPanOffset;
    uniform float manualTiltOffset;
    uniform float zoomLevel;
    varying vec2 vUv;

    vec2 distort(vec2 p) {
        vec2 center = vec2(0.5, 0.5);
        vec2 v = p - center;
        float r2 = dot(v, v);
        return center + v * (1.0 + r2 * (k1 + k2 * r2));
    }

    void main() {
        vec2 eyeCenter = vec2(0.5, 0.5);
        vec2 distortedUV = distort(vUv);
        vec2 uv = (distortedUV - eyeCenter) / zoomLevel;
        uv.x += headYawOffset + manualPanOffset;
        uv.y += headPitchOffset + manualTiltOffset;
        uv += eyeCenter;

        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
            gl_FragColor = texture2D(tDiffuse, uv);
        }
    }
</script>

<script>
    // --- GLOBAL VARIABLES ---
    let videoURL = null, activeVRVideo = null, isPlaying = false;
    let selectedMode = '2d';
    let renderer, scene, camera, effect, tracker;
    let zIdx = 4; 
    const zLvls = [0.2,0.4,0.6,0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.4, 3.0];
    let pan = {x:0, y:0}, head = {y:0, p:0}, offset = {y:0, p:0};

    // --- SETUP SCREEN LOGIC ---
    
    // 1. Inject Overlay Template
    const tmpl = document.getElementById('uiTemplate').content;
    document.getElementById('uiL').appendChild(tmpl.cloneNode(true));
    document.getElementById('uiR').appendChild(tmpl.cloneNode(true));

    // 2. Mode Selection (Syncs Left and Right UI)
    window.setMode = (mode) => {
        selectedMode = mode;
        document.querySelectorAll('.radio-label').forEach(el => {
            if(el.dataset.val === mode) el.classList.add('selected');
            else el.classList.remove('selected');
        });
    };

    // 3. File Selection (Syncs Labels and Previews)
    document.getElementById('realFileInput').onchange = (e) => {
        const f = e.target.files[0]; if(!f) return;
        
        // Update Button Text (Both Eyes)
        document.querySelectorAll('.file-lbl').forEach(el => el.textContent = f.name);
        
        if(videoURL) URL.revokeObjectURL(videoURL);
        videoURL = URL.createObjectURL(f);

        // Update Previews (Both Eyes)
        document.querySelectorAll('.preview-text').forEach(el => el.style.display = 'none');
        document.querySelectorAll('.preview-video').forEach(vid => {
            vid.src = videoURL;
            vid.classList.add('active');
            // Note: We don't auto-play previews in setup to save resources, 
            // but we load them so the user sees the thumbnail.
            vid.currentTime = 1; 
        });

        // Enable Start Buttons
        document.querySelectorAll('.start-btn').forEach(btn => btn.disabled = false);
    };

    // 4. Launch Logic
    window.launchVR = async () => {
        if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            try { await DeviceOrientationEvent.requestPermission(); } catch(e){}
        }
        
        const d = document.documentElement;
        if(d.requestFullscreen) d.requestFullscreen();
        screen.orientation?.lock('landscape').catch(()=>{});
        
        document.getElementById('setup').classList.add('hidden');
        
        // Clean up setup previews
        document.querySelectorAll('.preview-video').forEach(v => { v.src = ''; v.load(); });
        
        initVR();
    };

    // --- 3D ENGINE ---
    function initVR() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100);
        
        activeVRVideo = document.createElement('video');
        activeVRVideo.src = videoURL;
        activeVRVideo.loop = false;
        activeVRVideo.playsInline = true;
        activeVRVideo.setAttribute('webkit-playsinline', '');

        activeVRVideo.onloadeddata = () => {
            const videoTex = new THREE.VideoTexture(activeVRVideo);
            videoTex.format = THREE.RGBFormat;
            videoTex.minFilter = THREE.LinearFilter;
            videoTex.magFilter = THREE.LinearFilter;
            videoTex.generateMipmaps = false;
            
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Max Anisotropy on source
            const maxAniso = renderer.capabilities.getMaxAnisotropy();
            if(maxAniso > 1) videoTex.anisotropy = maxAniso;
            
            document.body.appendChild(renderer.domElement);

            // Standard Scale Logic
            const aspect = selectedMode==='3d' ? (activeVRVideo.videoWidth/2)/activeVRVideo.videoHeight : activeVRVideo.videoWidth/activeVRVideo.videoHeight;
            const width = 6;
            const height = width / aspect;
            const distance = -2.5;

            const mkEye = (l, off) => {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.ShaderMaterial({
                    uniforms: { t:{value:videoTex} },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.); }`,
                    fragmentShader: `precision highp float; uniform sampler2D t; varying vec2 vUv; void main() { gl_FragColor = texture2D(t, vec2(vUv.x*0.5+${off}, vUv.y)); }`,
                    side: THREE.DoubleSide
                }));
                m.position.z = distance; m.layers.set(l); return m;
            };
            
            if(selectedMode==='2d') {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({map:videoTex}));
                m.position.z = distance; camera.add(m);
            } else {
                camera.add(mkEye(1,0.0)); 
                camera.add(mkEye(2,0.5));
            }
            scene.add(camera);

            effect = new StereoEffect(renderer);
            tracker = new Tracker(); tracker.start();

            activeVRVideo.play(); 
            isPlaying = true;
            animate();
        };
    }

    function animate() {
        requestAnimationFrame(animate);
        if(tracker) tracker.update();
        if(effect) effect.render(scene, camera);
    }

    function StereoEffect(ren) {
        const _s = new THREE.StereoCamera(); _s.aspect = 0.5;
        const dpr = window.devicePixelRatio;
        const w = Math.min(window.innerWidth*dpr/2, 4096); 
        const h = Math.min(window.innerHeight*dpr, 4096);

        const rtConf = { 
            minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, 
            format: THREE.RGBFormat, generateMipmaps: false, 
            depthBuffer: false, stencilBuffer: false 
        };
        
        const rtL = new THREE.WebGLRenderTarget(w, h, rtConf);
        const rtR = new THREE.WebGLRenderTarget(w, h, rtConf);

        const mat = new THREE.ShaderMaterial({
            uniforms: { 
                tDiffuse:{value:null}, k1:{value:0.22}, k2:{value:0.18}, 
                headYawOffset:{value:0}, headPitchOffset:{value:0}, 
                manualPanOffset:{value:0}, manualTiltOffset:{value:0}, 
                zoomLevel:{value:1}
            },
            vertexShader: document.getElementById('vert').textContent,
            fragmentShader: document.getElementById('frag').textContent
        });
        
        const sceneQ = new THREE.Scene();
        const camQ = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        sceneQ.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), mat));

        window.addEventListener('resize', () => {
            ren.setSize(window.innerWidth, window.innerHeight);
        });

        this.render = (scn, cam) => {
            scn.updateMatrixWorld(); _s.update(cam);
            if(selectedMode==='3d') { _s.cameraL.layers.set(1); _s.cameraR.layers.set(2); }

            ren.setRenderTarget(rtL); ren.clear(); ren.render(scn, _s.cameraL);
            ren.setRenderTarget(rtR); ren.clear(); ren.render(scn, _s.cameraR);
            ren.setRenderTarget(null);

            let yd = ((head.y - offset.y + Math.PI) % (2*Math.PI)) - Math.PI;
            let pd = Math.max(-1.57, Math.min(1.57, head.p - offset.p));

            mat.uniforms.headYawOffset.value = -yd * 0.7;
            mat.uniforms.headPitchOffset.value = pd * 0.8;
            mat.uniforms.manualPanOffset.value = pan.x;
            mat.uniforms.manualTiltOffset.value = pan.y;
            mat.uniforms.zoomLevel.value = zLvls[zIdx];

            ren.setScissorTest(true);
            const sz = ren.getSize(new THREE.Vector2());
            
            mat.uniforms.tDiffuse.value = rtL.texture;
            ren.setScissor(0,0,sz.width/2,sz.height); ren.setViewport(0,0,sz.width/2,sz.height);
            ren.render(sceneQ, camQ);

            mat.uniforms.tDiffuse.value = rtR.texture;
            ren.setScissor(sz.width/2,0,sz.width/2,sz.height); ren.setViewport(sz.width/2,0,sz.width/2,sz.height);
            ren.render(sceneQ, camQ);
            ren.setScissorTest(false);
        }
    }

    // --- TRACKER ---
    function Tracker() {
        const euler = new THREE.Euler(), q = new THREE.Quaternion(), qCam = new THREE.Quaternion();
        const qScr = new THREE.Quaternion(), zAx = new THREE.Vector3(0,0,1), vec = new THREE.Vector3(0,0,-1);
        qCam.setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);
        let dev = {}, scr = 0, init = false, timer;
        const onD = (e) => dev = e;
        const onS = () => scr = (screen.orientation?.angle || window.orientation || 0) * (Math.PI/180);
        this.start = () => { onS(); window.addEventListener('orientationchange', onS); window.addEventListener('deviceorientation', onD); };
        
        this.update = () => {
            if(!dev.alpha) return;
            const a = THREE.MathUtils.degToRad(dev.alpha), b = THREE.MathUtils.degToRad(dev.beta), g = THREE.MathUtils.degToRad(dev.gamma);
            euler.set(b, a, -g, 'YXZ');
            q.setFromEuler(euler); q.multiply(qCam); q.multiply(qScr.setFromAxisAngle(zAx, -scr));
            const v = vec.clone().applyQuaternion(q);
            const p = Math.asin(v.y), y = Math.atan2(v.x, -v.z);
            if(!init) { 
                init = true; clearTimeout(timer); timer = setTimeout(() => { offset.y=head.y; offset.p=head.p; }, 500);
                head.y = y; head.p = p;
            } else { head.y = y; head.p = p; }
        }
    }

    // --- CONTROLS ---
    const ui = document.getElementById('overlay');
    let fadeT;
    const showUI = () => { ui.classList.add('visible'); ui.classList.remove('fading'); clearTimeout(fadeT); fadeT = setTimeout(hideUI, 3000); };
    const hideUI = () => { if(isPlaying) { ui.classList.add('fading'); setTimeout(()=>ui.classList.remove('visible'), 200); } };
    
    document.addEventListener('click', (e) => { 
        if(e.target.closest('.eye-ui')) return; 
        if(ui.classList.contains('visible')) hideUI(); else showUI(); 
    });

    const bind = (sel, fn) => {
        document.querySelectorAll(sel).forEach(b => {
            const handler = (e) => { 
                e.preventDefault(); e.stopPropagation(); 
                if(!activeVRVideo) return; 
                fn(b, e); 
                showUI(); 
            };
            b.onclick = handler; b.ontouchend = handler;
        });
    };

    bind('.pp', () => { 
        if(isPlaying) activeVRVideo.pause(); else activeVRVideo.play(); 
        isPlaying = !isPlaying; 
        document.querySelectorAll('.pp').forEach(x => x.textContent = isPlaying ? '||' : '▶');
    });
    bind('.rew', () => activeVRVideo.currentTime = Math.max(0, activeVRVideo.currentTime - 10));
    bind('.fwd', () => activeVRVideo.currentTime = Math.min(activeVRVideo.duration, activeVRVideo.currentTime + 10));
    bind('.zoom-in', () => zIdx = Math.min(zLvls.length-1, zIdx+1));
    bind('.zoom-out', () => zIdx = Math.max(0, zIdx-1));
    bind('.zr', () => zIdx = 4);
    bind('.pan-l', () => pan.x -= 0.05);
    bind('.pan-r', () => pan.x += 0.05);
    bind('.pan-c', () => { pan.x=0; pan.y=0; offset.y=head.y; offset.p=head.p; });

    bind('.bar-track', (b, e) => {
        const rect = b.getBoundingClientRect();
        const cx = (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0].clientX : e.clientX;
        if(cx !== undefined) activeVRVideo.currentTime = ((cx - rect.left) / rect.width) * activeVRVideo.duration;
    });
    
    setInterval(() => {
        if(!activeVRVideo) return;
        const p = (activeVRVideo.currentTime / activeVRVideo.duration) * 100;
        document.querySelectorAll('.bar-fill').forEach(f => f.style.width = p+'%');
    }, 200);

</script>
</body>
</html>
