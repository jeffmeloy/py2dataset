<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Player</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: system-ui, -apple-system, sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* SETUP UI */
        #setup { position: fixed; inset: 0; z-index: 10000; background: #121212; display: flex; align-items: center; justify-content: center; padding: 10px; }
        #setup.hidden { display: none !important; }
        .setup-box { width: 100%; max-width: 400px; background: #1e1e1e; border-radius: 16px; padding: 24px; display: flex; flex-direction: column; gap: 16px; box-shadow: 0 20px 50px rgba(0,0,0,0.7); }
        
        h2 { margin: 0; text-align: center; color: #fff; text-transform: uppercase; letter-spacing: 1px; font-size: 18px; }
        .radio-group { display: flex; background: #2c2c2c; border-radius: 8px; padding: 4px; }
        .radio-group label { flex: 1; text-align: center; padding: 12px; cursor: pointer; border-radius: 6px; color: #888; font-weight: 600; transition: 0.2s; }
        .radio-group input:checked + label { background: #007BFF; color: white; }
        
        .file-btn { background: #333; color: #ddd; padding: 16px; border-radius: 8px; text-align: center; font-weight: 600; border: 1px dashed #555; cursor: pointer; display: block; }
        .preview { background: #000; border-radius: 8px; height: 200px; display: flex; align-items: center; justify-content: center; border: 1px solid #333; overflow: hidden; position: relative; }
        #testVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        #testVideo.active { display: block; }
        
        .btn-main { background: #007BFF; color: white; border: none; padding: 16px; font-size: 16px; font-weight: bold; border-radius: 8px; width: 100%; text-transform: uppercase; letter-spacing: 1px; }
        .btn-main:disabled { background: #333; color: #555; }

        /* VR OVERLAY */
        #overlay { 
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent); 
            padding: 40px 0 20px 0; display: none; z-index: 9999; 
            transition: opacity 0.2s; 
        }
        #overlay.visible { display: flex; }
        #overlay.fading { opacity: 0; pointer-events: none; }
        
        .eye-ui { width: 50%; display: flex; flex-direction: column; align-items: center; padding: 0 10px; box-sizing: border-box; }
        
        .bar-track { width: 95%; height: 40px; display: flex; align-items: center; cursor: pointer; margin-bottom: 5px; }
        .bar-bg { width: 100%; height: 12px; background: rgba(255,255,255,0.2); border-radius: 6px; position: relative; overflow: hidden; pointer-events: none; }
        .bar-fill { height: 100%; background: #007BFF; width: 0%; pointer-events: none; }
        
        .row { display: flex; gap: 15px; margin-bottom: 15px; }
        .btn-icon { 
            width: 60px; height: 60px; border-radius: 50%; 
            background: rgba(255,255,255,0.15); border: 1px solid rgba(255,255,255,0.1); 
            color: white; font-size: 24px; display: flex; align-items: center; justify-content: center; 
            backdrop-filter: blur(5px); cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .btn-icon:active { background: rgba(0,123,255,0.8); transform: scale(0.95); }
        .btn-pill { height: 44px; padding: 0 24px; border-radius: 22px; background: rgba(255,255,255,0.15); border: none; color: white; font-weight: bold; backdrop-filter: blur(5px); }
    </style>
</head>
<body>

<div id="setup">
    <div class="setup-box">
        <div class="radio-group">
            <input type="radio" id="mode2d" name="mode" value="2d" checked><label for="mode2d">2D</label>
            <input type="radio" id="mode3d" name="mode" value="3d"><label for="mode3d">3D SBS</label>
        </div>
        <label for="fIn" class="file-btn" id="fLbl">Select Video</label>
        <input type="file" id="fIn" accept="video/*" style="display:none">
        <div class="preview"><span id="pTxt" style="color:#555">No Video</span><video id="testVideo" controls playsinline></video></div>
        <button id="goBtn" class="btn-main" disabled>Enter VR</button>
    </div>
</div>

<div id="overlay">
    <div class="eye-ui" id="uiL"></div>
    <div class="eye-ui" id="uiR"></div>
</div>

<template id="uiTemplate">
    <div class="bar-track">
        <div class="bar-bg"><div class="bar-fill"></div></div>
    </div>
    <div class="row">
        <button class="btn-icon pan-l">&larr;</button>
        <button class="btn-icon pan-c">⦾</button>
        <button class="btn-icon pan-r">&rarr;</button>
    </div>
    <div class="row">
        <button class="btn-icon rew">↺</button>
        <button class="btn-icon pp">▶</button>
        <button class="btn-icon fwd">↻</button>
    </div>
    <div class="row">
        <button class="btn-icon zoom-out">-</button>
        <button class="btn-pill zr">ZOOM</button>
        <button class="btn-icon zoom-in">+</button>
    </div>
</template>

<script id="vert" type="x-shader/x-vertex">
    precision highp float;
    varying vec2 vUv;
    void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
</script>

<script id="frag" type="x-shader/x-fragment">
    precision highp float;
    uniform sampler2D tDiffuse;
    uniform float k1;
    uniform float k2;
    uniform float headYawOffset;
    uniform float headPitchOffset;
    uniform float manualPanOffset;
    uniform float manualTiltOffset;
    uniform float zoomLevel;
    varying vec2 vUv;

    vec2 distort(vec2 p) {
        vec2 center = vec2(0.5, 0.5);
        vec2 v = p - center;
        float r2 = dot(v, v);
        return center + v * (1.0 + r2 * (k1 + k2 * r2));
    }

    void main() {
        vec2 eyeCenter = vec2(0.5, 0.5);
        vec2 distortedUV = distort(vUv);
        
        vec2 uv = (distortedUV - eyeCenter) / zoomLevel;
        uv.x += headYawOffset + manualPanOffset;
        uv.y += headPitchOffset + manualTiltOffset;
        uv += eyeCenter;

        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
        } else {
            gl_FragColor = texture2D(tDiffuse, uv);
        }
    }
</script>

<script>
    const el = (id) => document.getElementById(id);
    const tmpl = el('uiTemplate').content;
    el('uiL').appendChild(tmpl.cloneNode(true));
    el('uiR').appendChild(tmpl.cloneNode(true));

    let videoURL = null, activeVRVideo = null, isPlaying = false;

    el('fIn').onchange = (e) => {
        const f = e.target.files[0]; if(!f) return;
        el('fLbl').textContent = f.name;
        if(videoURL) URL.revokeObjectURL(videoURL);
        videoURL = URL.createObjectURL(f);
        const v = el('testVideo');
        v.src = videoURL; v.style.display='block'; el('pTxt').style.display='none';
        v.onloadedmetadata = () => el('goBtn').disabled = false;
    };

    el('goBtn').onclick = async () => {
        el('testVideo').pause(); 
        const mode = document.querySelector('input[name="mode"]:checked').value;
        
        // PERMISSIONS & WAKE LOCK
        if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            try { await DeviceOrientationEvent.requestPermission(); } catch(e){}
        }
        
        // WAKE LOCK ADDITION
        if ('wakeLock' in navigator) {
            try { await navigator.wakeLock.request('screen'); } catch(err) { console.warn('Wake Lock failed:', err); }
        }

        const d = document.documentElement;
        if(d.requestFullscreen) d.requestFullscreen();
        screen.orientation?.lock('landscape').catch(()=>{});
        el('setup').classList.add('hidden');
        init3D(mode);
    };

    let renderer, scene, camera, effect, tracker;
    let zIdx = 4; 
    const zLvls = [0.2,0.4,0.6,0.8, 1.0, 1.2, 1.4, 1.6, 1.8, 2.0, 2.4, 3.0];
    let pan = {x:0, y:0}, head = {y:0, p:0}, offset = {y:0, p:0};

    function init3D(mode) {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(90, window.innerWidth/window.innerHeight, 0.1, 100);
        
        activeVRVideo = document.createElement('video');
        activeVRVideo.src = videoURL;
        activeVRVideo.loop = false;
        activeVRVideo.playsInline = true;
        activeVRVideo.setAttribute('webkit-playsinline', '');

        activeVRVideo.onloadeddata = () => {
            const videoTex = new THREE.VideoTexture(activeVRVideo);
            videoTex.format = THREE.RGBFormat;
            videoTex.minFilter = THREE.LinearFilter;
            videoTex.magFilter = THREE.LinearFilter;
            videoTex.generateMipmaps = false;
            
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            const maxAniso = renderer.capabilities.getMaxAnisotropy();
            if(maxAniso > 1) videoTex.anisotropy = maxAniso;
            
            document.body.appendChild(renderer.domElement);

            const aspect = mode==='3d' ? (activeVRVideo.videoWidth/2)/activeVRVideo.videoHeight : activeVRVideo.videoWidth/activeVRVideo.videoHeight;
            const width = 6;
            const height = width / aspect; 
            const distance = -2.5;

            const mkEye = (l, off) => {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.ShaderMaterial({
                    uniforms: { t:{value:videoTex} },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.); }`,
                    fragmentShader: `precision highp float; uniform sampler2D t; varying vec2 vUv; void main() { gl_FragColor = texture2D(t, vec2(vUv.x*0.5+${off}, vUv.y)); }`,
                    side: THREE.DoubleSide
                }));
                m.position.z = distance; m.layers.set(l); return m;
            };
            
            if(mode==='2d') {
                const m = new THREE.Mesh(new THREE.PlaneGeometry(width, height), new THREE.MeshBasicMaterial({map:videoTex}));
                m.position.z = distance; camera.add(m);
            } else {
                camera.add(mkEye(1,0.0)); camera.add(mkEye(2,0.5));
            }
            scene.add(camera);

            effect = new StereoEffect(renderer, mode);
            tracker = new Tracker(); tracker.start();

            activeVRVideo.play(); 
            isPlaying = true;
            animate();
        };
    }

    function animate() {
        requestAnimationFrame(animate);
        if(tracker) tracker.update();
        if(effect) effect.render(scene, camera);
    }

    function StereoEffect(ren, mode) {
        const _s = new THREE.StereoCamera(); _s.aspect = 0.5;
        const dpr = window.devicePixelRatio;
        
        const w = Math.min(window.innerWidth*dpr/2, 4096); 
        const h = Math.min(window.innerHeight*dpr, 4096);

        const rtConf = { 
            minFilter: THREE.LinearFilter, 
            magFilter: THREE.LinearFilter, 
            format: THREE.RGBFormat, 
            generateMipmaps: false, 
            depthBuffer: false, 
            stencilBuffer: false 
        };
        
        const rtL = new THREE.WebGLRenderTarget(w, h, rtConf);
        const rtR = new THREE.WebGLRenderTarget(w, h, rtConf);

        const mat = new THREE.ShaderMaterial({
            uniforms: { 
                tDiffuse:{value:null}, 
                k1:{value:0.22}, k2:{value:0.18}, 
                headYawOffset:{value:0}, headPitchOffset:{value:0}, 
                manualPanOffset:{value:0}, manualTiltOffset:{value:0}, 
                zoomLevel:{value:1}
            },
            vertexShader: el('vert').textContent,
            fragmentShader: el('frag').textContent
        });
        
        const sceneQ = new THREE.Scene();
        const camQ = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
        sceneQ.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), mat));

        window.addEventListener('resize', () => {
            ren.setSize(window.innerWidth, window.innerHeight);
        });

        this.render = (scn, cam) => {
            scn.updateMatrixWorld(); _s.update(cam);
            if(mode==='3d') { _s.cameraL.layers.set(1); _s.cameraR.layers.set(2); }

            ren.setRenderTarget(rtL); ren.clear(); ren.render(scn, _s.cameraL);
            ren.setRenderTarget(rtR); ren.clear(); ren.render(scn, _s.cameraR);
            ren.setRenderTarget(null);

            let yd = ((head.y - offset.y + Math.PI) % (2*Math.PI)) - Math.PI;
            let pd = Math.max(-1.57, Math.min(1.57, head.p - offset.p));

            mat.uniforms.headYawOffset.value = -yd * 0.7;
            
            // FIXED: Inverted Pitch Direction here
            mat.uniforms.headPitchOffset.value = -pd * 0.8;
            
            mat.uniforms.manualPanOffset.value = pan.x;
            mat.uniforms.manualTiltOffset.value = pan.y;
            mat.uniforms.zoomLevel.value = zLvls[zIdx];

            ren.setScissorTest(true);
            const sz = ren.getSize(new THREE.Vector2());
            
            mat.uniforms.tDiffuse.value = rtL.texture;
            ren.setScissor(0,0,sz.width/2,sz.height); ren.setViewport(0,0,sz.width/2,sz.height);
            ren.render(sceneQ, camQ);

            mat.uniforms.tDiffuse.value = rtR.texture;
            ren.setScissor(sz.width/2,0,sz.width/2,sz.height); ren.setViewport(sz.width/2,0,sz.width/2,sz.height);
            ren.render(sceneQ, camQ);
            ren.setScissorTest(false);
        }
    }

    function Tracker() {
        const euler = new THREE.Euler(), q = new THREE.Quaternion(), qCam = new THREE.Quaternion();
        const qScr = new THREE.Quaternion(), zAx = new THREE.Vector3(0,0,1), vec = new THREE.Vector3(0,0,-1);
        qCam.setFromAxisAngle(new THREE.Vector3(1,0,0), -Math.PI/2);
        let dev = {}, scr = 0, init = false, timer;
        const onD = (e) => dev = e;
        const onS = () => scr = (screen.orientation?.angle || window.orientation || 0) * (Math.PI/180);
        this.start = () => { onS(); window.addEventListener('orientationchange', onS); window.addEventListener('deviceorientation', onD); };
        this.update = () => {
            if(!dev.alpha) return;
            const a = THREE.MathUtils.degToRad(dev.alpha), b = THREE.MathUtils.degToRad(dev.beta), g = THREE.MathUtils.degToRad(dev.gamma);
            euler.set(b, a, -g, 'YXZ');
            q.setFromEuler(euler); q.multiply(qCam); q.multiply(qScr.setFromAxisAngle(zAx, -scr));
            const v = vec.clone().applyQuaternion(q);
            const p = Math.asin(v.y), y = Math.atan2(v.x, -v.z);
            if(!init) { 
                init = true; clearTimeout(timer); timer = setTimeout(() => { offset.y=head.y; offset.p=head.p; }, 500);
                head.y = y; head.p = p;
            } else { head.y = y; head.p = p; }
        }
    }

    const ui = el('overlay');
    let fadeT;
    const showUI = () => { ui.classList.add('visible'); ui.classList.remove('fading'); clearTimeout(fadeT); fadeT = setTimeout(hideUI, 3000); };
    const hideUI = () => { if(isPlaying) { ui.classList.add('fading'); setTimeout(()=>ui.classList.remove('visible'), 200); } };
    document.addEventListener('click', (e) => { if(e.target.closest('.eye-ui')) return; if(ui.classList.contains('visible')) hideUI(); else showUI(); });

    const bind = (sel, fn) => {
        document.querySelectorAll(sel).forEach(b => {
            const handler = (e) => { e.preventDefault(); e.stopPropagation(); if(!activeVRVideo) return; fn(b, e); showUI(); };
            b.onclick = handler; b.ontouchend = handler;
        });
    };

    bind('.pp', () => { 
        if(isPlaying) activeVRVideo.pause(); else activeVRVideo.play(); 
        isPlaying = !isPlaying; 
        document.querySelectorAll('.pp').forEach(x => x.textContent = isPlaying ? '||' : '▶');
    });
    bind('.rew', () => activeVRVideo.currentTime = Math.max(0, activeVRVideo.currentTime - 10));
    bind('.fwd', () => activeVRVideo.currentTime = Math.min(activeVRVideo.duration, activeVRVideo.currentTime + 10));
    bind('.zoom-in', () => zIdx = Math.min(zLvls.length-1, zIdx+1));
    bind('.zoom-out', () => zIdx = Math.max(0, zIdx-1));
    bind('.zr', () => zIdx = 4);
    bind('.pan-l', () => pan.x -= 0.05);
    bind('.pan-r', () => pan.x += 0.05);
    bind('.pan-c', () => { pan.x=0; pan.y=0; offset.y=head.y; offset.p=head.p; });

    bind('.bar-track', (b, e) => {
        const rect = b.getBoundingClientRect();
        const cx = (e.changedTouches && e.changedTouches.length > 0) ? e.changedTouches[0].clientX : e.clientX;
        if(cx !== undefined) activeVRVideo.currentTime = ((cx - rect.left) / rect.width) * activeVRVideo.duration;
    });
    
    setInterval(() => {
        if(!activeVRVideo) return;
        const p = (activeVRVideo.currentTime / activeVRVideo.duration) * 100;
        document.querySelectorAll('.bar-fill').forEach(f => f.style.width = p+'%');
    }, 200);
</script>
</body>
</html>
