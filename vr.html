<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Player & Browser (Fixed)</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background: #000; color: white; }
        
        /* SETUP SCREEN */
        #setup { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 10000; 
            background: #121212; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #setup.hidden { display: none; }
        .setup-container {
            width: 90%; max-width: 400px; background: #1e1e1e; padding: 20px;
            border-radius: 12px; display: flex; flex-direction: column; gap: 15px;
        }
        .file-upload-label {
            background: #333; padding: 12px; border-radius: 6px; text-align: center; cursor: pointer; border: 1px dashed #555;
        }
        .url-input {
            padding: 12px; background: #252525; border: 1px solid #444; color: white; border-radius: 6px; width: 100%; box-sizing: border-box;
        }
        #startBtn {
            background: #007BFF; color: white; border: none; padding: 15px; font-weight: bold; font-size: 16px; border-radius: 6px; cursor: pointer;
        }
        #testVideo { display: none; width: 100%; height: 100px; object-fit: contain; background: black; }
        #testVideo.active { display: block; }

        /* OVERLAY */
        #progressOverlay { 
            position: fixed; bottom: 0; width: 100%; background: rgba(0,0,0,0.8); 
            display: none; flex-direction: row; z-index: 9999; padding: 10px 0;
        }
        #progressOverlay.visible { display: flex; }
        .eye-controls { width: 50%; padding: 0 5px; box-sizing: border-box; display: flex; flex-direction: column; align-items: center; gap: 5px; }
        .controls-row { display: flex; gap: 5px; justify-content: center; width: 100%; }
        button.btn-pill { background: #444; border: none; color: #fff; padding: 5px 10px; border-radius: 15px; font-size: 10px; }
        button.btn-pill.active { background: #007BFF; }
        .progressBar { width: 100%; height: 8px; background: #333; }
        .progressFill { height: 100%; width: 0%; background: #007BFF; }

        /* CSS3D LAYER (Must be z-index > 0 but < Overlay) */
        .css-renderer-container {
            position: absolute; top: 0; pointer-events: none; z-index: 100;
        }
    </style>
</head>
<body>

    <div id="setup">
        <div class="setup-container">
            <h2>VR Player & Web</h2>
            
            <label class="file-upload-label">
                Tap to Select Video (Optional)
                <input type="file" id="fileInput" accept="video/*" style="display:none">
            </label>
            <video id="testVideo" playsinline muted></video>
            
            <input type="text" id="urlInput" class="url-input" placeholder="Enter URL (Default: Wikipedia)">
            
            <button id="startBtn">ENTER VR</button>
            <div id="status" style="text-align:center; color:#888; font-size:12px;">Ready</div>
        </div>
    </div>

    <div id="progressOverlay">
        <!-- LEFT EYE CONTROLS -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="controls-row">
                <button class="btn-pill mode-2d-btn active">2D</button>
                <button class="btn-pill mode-3d-btn">3D</button>
                <button class="btn-pill web-toggle-btn active">WEB ON/OFF</button>
            </div>
            <div class="controls-row">
                <button class="btn-pill recenter-btn">RE-CENTER</button>
                <button class="btn-pill zoom-reset-btn">RESET ZOOM</button>
            </div>
        </div>
        <!-- RIGHT EYE CONTROLS -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="controls-row">
                <button class="btn-pill mode-2d-btn active">2D</button>
                <button class="btn-pill mode-3d-btn">3D</button>
                <button class="btn-pill web-toggle-btn active">WEB ON/OFF</button>
            </div>
            <div class="controls-row">
                <button class="btn-pill recenter-btn">RE-CENTER</button>
                <button class="btn-pill zoom-reset-btn">RESET ZOOM</button>
            </div>
        </div>
    </div>

    <!-- SHADERS -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script id="fragmentShaderDistortion" type="x-shader/x-fragment">
        uniform sampler2D tDiffuse; uniform vec2 texSize; uniform float ipdOffset; uniform float zoomLevel; varying vec2 vUv;
        // Simple Lanczos-like approximation for brevity
        void main() {
            vec2 center = vec2(0.5);
            vec2 v = vUv - center;
            float r2 = dot(v, v);
            vec2 distUV = center + v * (1.0 + r2 * (0.22 + 0.18 * r2)); // Distortion
            vec2 uv = (distUV - center) / zoomLevel; 
            uv.x += ipdOffset; uv += center;
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) gl_FragColor = vec4(0.0);
            else gl_FragColor = texture2D(tDiffuse, uv);
        }
    </script>

    <script>
        // UI Elements
        const setupDiv = document.getElementById('setup');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const testVideo = document.getElementById('testVideo');
        const overlay = document.getElementById('progressOverlay');
        const status = document.getElementById('status');
        
        // State
        let videoURL = null;
        let webURL = "https://en.m.wikipedia.org"; // Default
        let isWebActive = true;
        let mode = '2d';
        
        // Three.js Globals
        let scene, camera, renderer, effect;
        let cssScene, cssRendererL, cssRendererR;
        let video, videoTexture;
        let screenGroup, cssGroup;
        let orientationTracker;
        
        // Parameters
        let screenDist = 3.0;
        let zoom = 1.0;
        let ipd = 0.0;

        // 1. SETUP HANDLERS
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file){
                videoURL = URL.createObjectURL(file);
                testVideo.src = videoURL;
                testVideo.classList.add('active');
                status.textContent = "Video Selected: " + file.name;
            }
        });

        document.getElementById('startBtn').addEventListener('click', async () => {
            const val = urlInput.value.trim();
            if(val) webURL = val; // Override default if user typed something
            
            // Fullscreen & Permissions
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
            }
            const el = document.documentElement;
            if(el.requestFullscreen) el.requestFullscreen();
            if(screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(()=>{});

            setupDiv.classList.add('hidden');
            initVR();
        });

        function initVR() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            screenGroup = new THREE.Group();
            scene.add(screenGroup);
            scene.add(camera);

            // A. SETUP VIDEO (Or Dummy Black Screen)
            if(videoURL) {
                video = document.createElement('video');
                video.src = videoURL;
                video.playsinline = true;
                video.loop = true;
                videoTexture = new THREE.VideoTexture(video);
                videoTexture.minFilter = THREE.LinearFilter;
                video.play();
            } else {
                // Dummy black texture
                const cvs = document.createElement('canvas'); 
                cvs.width=2; cvs.height=2;
                const ctx = cvs.getContext('2d'); ctx.fillStyle='black'; ctx.fillRect(0,0,2,2);
                videoTexture = new THREE.CanvasTexture(cvs);
                video = { duration: 1, currentTime: 0 };
            }

            // B. SETUP WEB (CSS3D)
            setupWeb();

            // C. CREATE SCREEN MESHES (WebGL)
            createScreen();

            // D. RENDERERS
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.zIndex = 0; // Bottom layer
            document.body.appendChild(renderer.domElement);

            effect = new THREE.StereoEffect(renderer);
            effect.setSize(window.innerWidth, window.innerHeight);

            // E. TRACKING
            orientationTracker = new OrientationTracker();
            orientationTracker.connect();

            // F. EVENTS
            window.addEventListener('resize', onResize);
            document.addEventListener('click', (e) => {
                if(e.target.tagName !== 'BUTTON') {
                    overlay.classList.toggle('visible');
                }
            });
            
            // Buttons
            document.querySelectorAll('.mode-2d-btn').forEach(b => b.onclick = ()=>{ mode='2d'; createScreen(); });
            document.querySelectorAll('.mode-3d-btn').forEach(b => b.onclick = ()=>{ mode='3d'; createScreen(); });
            document.querySelectorAll('.recenter-btn').forEach(b => b.onclick = ()=>{ screenGroup.quaternion.copy(camera.quaternion); });
            document.querySelectorAll('.web-toggle-btn').forEach(b => {
                b.onclick = ()=>{ 
                    isWebActive = !isWebActive;
                    cssRendererL.domElement.style.display = isWebActive ? 'block' : 'none';
                    cssRendererR.domElement.style.display = isWebActive ? 'block' : 'none';
                };
            });

            animate();
        }

        function setupWeb() {
            // CSS Scene & Objects
            cssScene = new THREE.Scene();
            cssGroup = new THREE.Group();
            cssScene.add(cssGroup);

            // Create 2 Renderers (Left/Right)
            const makeCSSRenderer = (leftPos) => {
                const r = new THREE.CSS3DRenderer();
                r.setSize(window.innerWidth / 2, window.innerHeight);
                r.domElement.className = 'css-renderer-container';
                r.domElement.style.left = leftPos;
                document.body.appendChild(r.domElement);
                return r;
            };
            cssRendererL = makeCSSRenderer('0px');
            cssRendererR = makeCSSRenderer('50%');

            // Create Web Content Object
            // We use a white div background so you can see it even if iframe fails
            const w = 1024, h = 768;
            const makeObj = () => {
                const div = document.createElement('div');
                div.style.width = w+'px'; div.style.height = h+'px'; 
                div.style.background = 'white'; 
                
                const iframe = document.createElement('iframe');
                iframe.src = webURL;
                iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = '0';
                div.appendChild(iframe);

                const obj = new THREE.CSS3DObject(div);
                obj.scale.set(0.005, 0.005, 0.005);
                // Position slightly IN FRONT of the video screen (z = -2.8 vs -3.0)
                obj.position.set(0, 0, -2.8);
                return obj;
            };

            // We add 2 identical objects to the group (one for each eye/renderer to track)
            // Note: CSS3D has no "layers", so we just rely on the render loop to sync them
            // Simplest hack: One object in group, rendered by both cameras? 
            // No, CSS3D modifies DOM. 1 Object = 1 DOM Element.
            // We need TWO separate DOM trees for Stereo.
            const objL = makeObj();
            const objR = makeObj();
            
            // We assign them to custom properties to find them in render loop
            cssGroup.userData = { L: objL, R: objR };
            cssGroup.add(objL);
            cssGroup.add(objR);
            
            // Sync movement with main screen
            screenGroup.add(cssGroup);
        }

        function createScreen() {
            // Clear old
            screenGroup.children.filter(c => c.type==='Mesh').forEach(m=>screenGroup.remove(m));
            
            // Create Video Screen Mesh (WebGL)
            // 2D Mode: 1 Mesh. 3D Mode: 2 Meshes with layers.
            const asp = (16/9); 
            const geo = new THREE.PlaneGeometry(6, 6/asp);
            
            if(mode === '2d') {
                const mat = new THREE.MeshBasicMaterial({ map: videoTexture, side: 2 });
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.z = -3.0;
                screenGroup.add(mesh);
            } else {
                // 3D SBS Logic
                const matL = new THREE.ShaderMaterial({
                    uniforms: { tex: {value: videoTexture} },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x*0.5, vUv.y)); }`,
                    side: 2
                });
                const meshL = new THREE.Mesh(geo, matL); meshL.position.z = -3.0; meshL.layers.set(1);
                screenGroup.add(meshL);
                
                const matR = matL.clone();
                matR.fragmentShader = `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x*0.5+0.5, vUv.y)); }`;
                const meshR = new THREE.Mesh(geo, matR); meshR.position.z = -3.0; meshR.layers.set(2);
                screenGroup.add(meshR);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            if(orientationTracker) {
                orientationTracker.update();
                camera.quaternion.copy(orientationTracker.getQuaternion());
            }
            
            // 1. Render WebGL (Distorted Stereo)
            effect.render(scene, camera);
            
            // 2. Render CSS3D (Browser)
            if(isWebActive) {
                // Get stereo cameras calculated by effect
                const stereo = effect.getStereoCamera();
                const objs = cssGroup.userData;
                
                // Left Eye Pass
                objs.L.visible = true; objs.R.visible = false;
                cssRendererL.render(cssScene, stereo.cameraL);
                
                // Right Eye Pass
                objs.L.visible = false; objs.R.visible = true;
                cssRendererR.render(cssScene, stereo.cameraR);
                
                // Reset
                objs.L.visible = true; objs.R.visible = true;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            effect.setSize(window.innerWidth, window.innerHeight);
            cssRendererL.setSize(window.innerWidth/2, window.innerHeight);
            cssRendererR.setSize(window.innerWidth/2, window.innerHeight);
        }

        // --- HELPERS ---
        function OrientationTracker() {
            this.q = new THREE.Quaternion(); const zee = new THREE.Vector3(0,0,1); const q0=new THREE.Quaternion(), q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
            this.getQuaternion = () => this.q;
            this.update = () => {
                if(!this.e) return;
                const a = this.e.alpha ? THREE.Math.degToRad(this.e.alpha) : 0;
                const b = this.e.beta ? THREE.Math.degToRad(this.e.beta) : 0;
                const g = this.e.gamma ? THREE.Math.degToRad(this.e.gamma) : 0;
                const o = (screen.orientation?screen.orientation.angle:window.orientation||0) * (Math.PI/180);
                this.q.setFromEuler(new THREE.Euler(b,a,-g,'YXZ')).multiply(q1).multiply(q0.setFromAxisAngle(zee,-o));
            };
            this.connect = () => { window.addEventListener('deviceorientation', e=>this.e=e); };
        }

        THREE.StereoEffect = function(renderer) {
            const _stereo = new THREE.StereoCamera(); _stereo.aspect = 0.5;
            this.getStereoCamera = () => _stereo;
            
            const _targetL = new THREE.WebGLRenderTarget(512,512);
            const _targetR = new THREE.WebGLRenderTarget(512,512);
            
            const _mat = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: {value:null}, zoomLevel: {value:1.0}, ipdOffset:{value:0} },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderDistortion').textContent
            });
            const _scene = new THREE.Scene(); _scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), _mat));
            const _cam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);

            this.setSize = (w,h) => { 
                renderer.setSize(w,h); 
                _targetL.setSize(w,h); _targetR.setSize(w,h); // Simple resize
            };
            
            this.render = (scene, camera) => {
                scene.updateMatrixWorld();
                _stereo.update(camera);
                
                // Draw Scene to Targets
                renderer.setRenderTarget(_targetL); renderer.clear(); renderer.render(scene, _stereo.cameraL);
                renderer.setRenderTarget(_targetR); renderer.clear(); renderer.render(scene, _stereo.cameraR);
                renderer.setRenderTarget(null); 
                
                // Draw Targets to Screen with Distortion
                const w = window.innerWidth, h = window.innerHeight;
                renderer.setScissorTest(true);
                
                // Left
                renderer.setScissor(0,0,w/2,h); renderer.setViewport(0,0,w/2,h);
                _mat.uniforms.tDiffuse.value = _targetL.texture;
                renderer.render(_scene, _cam);
                
                // Right
                renderer.setScissor(w/2,0,w/2,h); renderer.setViewport(w/2,0,w/2,h);
                _mat.uniforms.tDiffuse.value = _targetR.texture;
                renderer.render(_scene, _cam);
                
                renderer.setScissorTest(false);
            };
        };
    </script>
</body>
</html>
