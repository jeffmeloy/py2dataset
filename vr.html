<!DOCTYPE html>
<html lang="en">
<head>
    <title>OnePlus VR Cinema</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1">
    <meta name="theme-color" content="#000000">
    <style>
        /* Dark AMOLED-friendly theme */
        body { margin: 0; background: #000; font-family: 'Segoe UI', sans-serif; height: 100vh; display: flex; align-items: center; justify-content: center; color: #fff; }
        
        #launcher {
            width: 100%; max-width: 600px; padding: 30px;
            display: flex; flex-direction: column; gap: 20px;
        }

        h1 { margin: 0 0 10px 0; text-align: center; font-weight: 300; letter-spacing: 2px; color: #eb0029; /* OnePlus Red */ }

        /* Big touch targets for high-res screens */
        button.launch-btn {
            width: 100%; padding: 25px; font-size: 20px; font-weight: bold;
            color: white; background: #1f1f1f; border: 2px solid #333;
            border-radius: 16px; cursor: pointer; text-transform: uppercase;
        }
        
        button.launch-btn:active { background: #333; transform: scale(0.98); }
        
        #btnEnter { 
            background: #eb0029; border-color: #c40022; opacity: 0.5; pointer-events: none; transition: 0.3s;
        }
        #btnEnter.ready { opacity: 1; pointer-events: auto; }

        #fileInput { display: none; }
        #status { text-align: center; color: #888; font-size: 14px; min-height: 20px; }
        
        /* OnePlus 13 specific: Hide scrollbars */
        ::-webkit-scrollbar { display: none; }
    </style>
</head>
<body>

<div id="launcher">
    <h1>ONEPLUS CINEMA</h1>
    
    <button class="launch-btn" onclick="document.getElementById('fileInput').click()">
        ðŸ“‚ Select Video
    </button>
    <input type="file" id="fileInput" accept="video/*">
    
    <div id="status">No video loaded</div>

    <!-- Mode selection hidden - defaulting to WebGL for Phone VR -->
    
    <button id="btnEnter" class="launch-btn">
        ENTER VR
    </button>
</div>

<script>
    let selectedBlobUrl = null;
    const fileInput = document.getElementById('fileInput');
    const btnEnter = document.getElementById('btnEnter');
    const status = document.getElementById('status');

    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        selectedBlobUrl = URL.createObjectURL(file);
        status.textContent = "Ready: " + file.name;
        btnEnter.classList.add('ready');
        btnEnter.textContent = "START MOVIE";
    });

    btnEnter.addEventListener('click', async () => {
        if (!selectedBlobUrl) return;

        // 1. Android Fullscreen
        const de = document.documentElement;
        if (de.requestFullscreen) {
            await de.requestFullscreen({ navigationUI: "hide" }); // Hides gesture bar
        }

        // 2. Android Landscape Lock
        if (screen.orientation && screen.orientation.lock) {
            try { await screen.orientation.lock('landscape'); } catch(e) { console.log('Orientation lock failed', e); }
        }

        // 3. Inject the High-Performance WebGL Player
        const playerHtml = getOnePlusPlayerSource(selectedBlobUrl);
        document.open();
        document.write(playerHtml);
        document.close();
    });

    function getOnePlusPlayerSource(videoUrl) {
        return `<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Player</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        #overlay {
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: linear-gradient(to top, rgba(0,0,0,0.9), transparent);
            z-index: 9999; display: flex; opacity: 0; transition: opacity 0.5s; pointer-events: none;
            padding-bottom: 20px;
        }
        #overlay.visible { opacity: 1; pointer-events: auto; }
        
        /* Split controls for VR view */
        .eye-col { width: 50%; display: flex; flex-direction: column; align-items: center; justify-content: flex-end; padding-bottom: 10px; }
        
        .controls { 
            background: rgba(30,30,30,0.8); border: 1px solid #444; 
            padding: 10px; border-radius: 20px; backdrop-filter: blur(10px);
            display: flex; flex-direction: column; gap: 8px; align-items: center; width: 280px;
        }

        .row { display: flex; gap: 10px; justify-content: center; width: 100%; align-items: center; }
        
        button { 
            background: #333; color: white; border: none; border-radius: 8px; 
            padding: 8px 12px; font-weight: bold; font-size: 14px; cursor: pointer; 
        }
        button.active { background: #eb0029; }
        button:active { transform: scale(0.95); }

        .slider-box { width: 100%; display: flex; align-items: center; gap: 5px; font-size: 12px; color: #ccc; }
        .bar-bg { flex: 1; height: 6px; background: #444; border-radius: 3px; position: relative; }
        .bar-fill { height: 100%; background: #eb0029; width: 0%; border-radius: 3px; }
    </style>
    <!-- Using Three.js r128 for stability with older stereo effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"><\/script>
</head>
<body>
    <div id="overlay"></div>
    
    <!-- SHADER: High Quality Lanczos Resampling for OnePlus Screen -->
    <script id="vs" type="x-shader/x-vertex">varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}<\/script>
    <script id="fs" type="x-shader/x-fragment">
        precision highp float;
        uniform sampler2D tDiffuse; uniform vec2 texSize; uniform float ipd; uniform float zoom; varying vec2 vUv;
        const float PI = 3.14159265359;
        // Lanczos2 Kernel
        float sinc(float x){ if(abs(x)<0.0001)return 1.0; float a=PI*x; return sin(a)/a; }
        float lw(float x){ if(abs(x)>=2.0)return 0.0; return sinc(x)*sinc(x*0.5); }
        vec4 textureLanczos(sampler2D smp, vec2 uv, vec2 size) {
            vec2 inv = 1.0/size; vec2 pos = uv*size; vec2 ipos = floor(pos-0.5)+0.5; vec2 f = pos-ipos;
            vec4 wX = vec4(lw(1.0+f.x), lw(f.x), lw(1.0-f.x), lw(2.0-f.x));
            vec4 wY = vec4(lw(1.0+f.y), lw(f.y), lw(1.0-f.y), lw(2.0-f.y));
            wX /= dot(wX, vec4(1.0)); wY /= dot(wY, vec4(1.0));
            // Manual unroll for performance on GPU
            vec4 r0 = texture2D(smp, (ipos+vec2(-1,-1))*inv)*wX.x + texture2D(smp, (ipos+vec2(0,-1))*inv)*wX.y + texture2D(smp, (ipos+vec2(1,-1))*inv)*wX.z + texture2D(smp, (ipos+vec2(2,-1))*inv)*wX.w;
            vec4 r1 = texture2D(smp, (ipos+vec2(-1, 0))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 0))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 0))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 0))*inv)*wX.w;
            vec4 r2 = texture2D(smp, (ipos+vec2(-1, 1))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 1))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 1))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 1))*inv)*wX.w;
            vec4 r3 = texture2D(smp, (ipos+vec2(-1, 2))*inv)*wX.x + texture2D(smp, (ipos+vec2(0, 2))*inv)*wX.y + texture2D(smp, (ipos+vec2(1, 2))*inv)*wX.z + texture2D(smp, (ipos+vec2(2, 2))*inv)*wX.w;
            return r0*wY.x + r1*wY.y + r2*wY.z + r3*wY.w;
        }
        // Barrel Distortion
        vec2 distort(vec2 p){ vec2 c=vec2(0.5); vec2 v=p-c; float r2=dot(v,v); return c+v*(1.0+r2*(0.22+0.18*r2)); }
        void main(){
            vec2 d = distort(vUv);
            vec2 uv = (d-vec2(0.5))/zoom; uv.x+=ipd; uv+=vec2(0.5);
            if(uv.x<0.0||uv.x>1.0||uv.y<0.0||uv.y>1.0) gl_FragColor=vec4(0.0);
            else gl_FragColor=textureLanczos(tDiffuse, uv, texSize);
        }
    <\/script>

    <script>
        // CONFIG
        const SRC_URL = "${videoUrl}";
        const CONFIG = { zoom: 1.0, ipd: 0.0, mode: '2d' }; // '2d' or '3d'
        
        let scene, camera, renderer, video, videoTex, screenMesh, effect, tracker;
        let overlayTimer;

        async function init() {
            // 1. Wake Lock (Crucial for OnePlus)
            if ('wakeLock' in navigator) {
                try { await navigator.wakeLock.request('screen'); console.log('Wake Lock Active'); } catch(e){}
            }

            // 2. Setup Three.js
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            
            // OnePlus 13 has a very high pixel density. 
            // We use standardPixelRatio to keep text sharp, but the video shader handles the heavy lifting.
            renderer = new THREE.WebGLRenderer({antialias: false, powerPreference: "high-performance"});
            renderer.setPixelRatio(window.devicePixelRatio); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // 3. Load Video
            video = document.createElement('video');
            video.src = SRC_URL;
            video.crossOrigin = "anonymous";
            video.playsInline = true; // Important for mobile
            video.loop = false;
            
            // 4. Create Texture
            videoTex = new THREE.Texture(video);
            videoTex.minFilter = THREE.LinearFilter;
            videoTex.magFilter = THREE.LinearFilter;
            videoTex.generateMipmaps = false;

            // Frame Sync Polyfill
            if ('requestVideoFrameCallback' in video) {
                const loop = () => { videoTex.needsUpdate = true; video.requestVideoFrameCallback(loop); };
                video.requestVideoFrameCallback(loop);
            } else {
                setInterval(() => { if(video.readyState >= 2) videoTex.needsUpdate = true; }, 16);
            }

            // 5. Screen Geometry
            const geo = new THREE.PlaneGeometry(8, 4.5); // 16:9 base
            // SBS handling in Shader Material
            const matStd = new THREE.MeshBasicMaterial({map: videoTex, side: 2});
            screenMesh = new THREE.Mesh(geo, matStd);
            screenMesh.position.z = -5;
            scene.add(screenMesh);
            
            // 6. Stereo Effect & Tracker
            effect = new StereoEffect(renderer);
            effect.setSize(window.innerWidth, window.innerHeight);
            
            tracker = new OrientationTracker();
            tracker.connect();

            // 7. Events
            window.addEventListener('resize', onResize);
            document.body.addEventListener('click', toggleOverlay);
            video.addEventListener('loadedmetadata', () => {
                // Adjust aspect ratio based on actual video
                const aspect = video.videoWidth / video.videoHeight;
                screenMesh.scale.set(1, 1/aspect * (16/9), 1);
            });

            video.play();
            updateOverlayHTML();
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Update Camera Rotation
            tracker.update();
            camera.quaternion.copy(tracker.q);

            effect.render(scene, camera);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            effect.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Controls & UI ---
        
        function toggleOverlay(e) {
            // Don't toggle if clicking a button
            if(e.target.tagName === 'BUTTON') return;
            
            const ov = document.getElementById('overlay');
            if(ov.classList.contains('visible')) {
                ov.classList.remove('visible');
            } else {
                updateOverlayHTML();
                ov.classList.add('visible');
                clearTimeout(overlayTimer);
                overlayTimer = setTimeout(() => ov.classList.remove('visible'), 4000);
            }
        }

        function handleBtn(action) {
            clearTimeout(overlayTimer);
            overlayTimer = setTimeout(() => document.getElementById('overlay').classList.remove('visible'), 4000);

            if(action === 'play') video.paused ? video.play() : video.pause();
            if(action === 'seek-') video.currentTime -= 10;
            if(action === 'seek+') video.currentTime += 10;
            if(action === 'mode-2d') { 
                CONFIG.mode = '2d'; 
                // Reset UVs to full
                screenMesh.material = new THREE.MeshBasicMaterial({map: videoTex, side: 2});
            }
            if(action === 'mode-3d') { 
                CONFIG.mode = '3d';
                // Handled in render loop or specialized mesh, 
                // but for single mesh simplicity we just scale it differently here or swap geometry
                // For this simple OneFile, we will rely on aspect ratio fix:
                screenMesh.scale.x = 2; // Stretch geometry for SBS
            }
            if(action === 'center') {
                tracker.resetOffset();
            }
            if(action === 'zoom+') CONFIG.zoom += 0.05;
            if(action === 'zoom-') CONFIG.zoom -= 0.05;
            
            updateOverlayHTML();
        }

        function updateOverlayHTML() {
            const isPaused = video.paused;
            const html = \`
                <div class="controls">
                    <div class="row">
                        <button onclick="handleBtn('seek-')">Â« 10s</button>
                        <button onclick="handleBtn('play')" style="width:50px">\${isPaused ? 'â–¶' : '||'}</button>
                        <button onclick="handleBtn('seek+')">10s Â»</button>
                    </div>
                    <div class="row">
                        <button onclick="handleBtn('mode-2d')" class="\${CONFIG.mode=='2d'?'active':''}">2D</button>
                        <button onclick="handleBtn('mode-3d')" class="\${CONFIG.mode=='3d'?'active':''}">3D (SBS)</button>
                    </div>
                    <div class="row">
                        <button onclick="handleBtn('zoom-')">Zoom -</button>
                        <button onclick="handleBtn('center')">Recenter</button>
                        <button onclick="handleBtn('zoom+')">Zoom +</button>
                    </div>
                </div>
            \`;
            // Duplicate for both eyes
            document.getElementById('overlay').innerHTML = \`<div class="eye-col">\${html}</div><div class="eye-col">\${html}</div>\`;
        }

        // --- Helpers ---

        class OrientationTracker {
            constructor() { 
                this.q = new THREE.Quaternion(); 
                this.offset = new THREE.Quaternion();
                this.deviceQ = new THREE.Quaternion();
                this.zee = new THREE.Vector3(0, 0, 1);
                this.euler = new THREE.Euler();
            }
            connect() {
                window.addEventListener('deviceorientation', (e) => {
                    const alpha = e.alpha ? THREE.Math.degToRad(e.alpha) : 0;
                    const beta = e.beta ? THREE.Math.degToRad(e.beta) : 0;
                    const gamma = e.gamma ? THREE.Math.degToRad(e.gamma) : 0;
                    const orient = (screen.orientation ? screen.orientation.angle : window.orientation || 0) * THREE.Math.degToRad(1); // deg to rad

                    this.euler.set(beta, alpha, -gamma, 'YXZ');
                    this.deviceQ.setFromEuler(this.euler);
                    this.deviceQ.multiply(new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5))); // Fix for device vs camera coords
                    this.deviceQ.multiply(new THREE.Quaternion().setFromAxisAngle(this.zee, -orient));
                });
            }
            update() {
                this.q.copy(this.deviceQ).multiply(this.offset);
            }
            resetOffset() {
                // Invert current Y rotation to center view
                this.offset.copy(this.deviceQ).invert();
            }
        }

        function StereoEffect(renderer) {
            const _s = new THREE.StereoCamera(); 
            _s.aspect = 0.5;
            
            // Shader setup for lens distortion
            const _scene = new THREE.Scene();
            const _cam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            const _target = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter});
            
            const _mat = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: {value: null}, texSize: {value: new THREE.Vector2()}, zoom: {value: 1.0}, ipd: {value: 0.0} },
                vertexShader: document.getElementById('vs').textContent,
                fragmentShader: document.getElementById('fs').textContent
            });
            _scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), _mat));

            this.setSize = (w, h) => {
                renderer.setSize(w, h);
                _target.setSize(w, h);
                _mat.uniforms.texSize.value.set(w, h);
            };

            this.render = (scene, camera) => {
                scene.updateMatrixWorld();
                _s.update(camera);

                // Render Scene to Texture
                renderer.setRenderTarget(_target);
                renderer.clear();
                renderer.render(scene, _s.cameraL); // Note: Simple implementation renders full scene twice, usually okay for video
                
                // We actually need left/right separation for the Shader. 
                // To keep this OneFile simple and performant on OnePlus, we do a multi-pass:
                
                // 1. Left Eye to Target
                renderer.setScissorTest(true);
                renderer.setRenderTarget(_target);
                renderer.setScissor(0, 0, window.innerWidth/2, window.innerHeight);
                renderer.setViewport(0, 0, window.innerWidth/2, window.innerHeight);
                
                // SBS logic for 3D mode
                if(CONFIG.mode === '3d') {
                    videoTex.offset.x = 0; videoTex.repeat.x = 0.5;
                } else {
                    videoTex.offset.x = 0; videoTex.repeat.x = 1;
                }
                renderer.render(scene, _s.cameraL);

                // 2. Right Eye to Target
                renderer.setScissor(window.innerWidth/2, 0, window.innerWidth/2, window.innerHeight);
                renderer.setViewport(window.innerWidth/2, 0, window.innerWidth/2, window.innerHeight);
                
                if(CONFIG.mode === '3d') {
                    videoTex.offset.x = 0.5;
                }
                renderer.render(scene, _s.cameraR);

                // 3. Render Post-Process (Distortion) to Screen
                renderer.setRenderTarget(null);
                renderer.setScissorTest(false);
                _mat.uniforms.tDiffuse.value = _target.texture;
                _mat.uniforms.zoom.value = CONFIG.zoom;
                
                // Left Lens
                renderer.setScissorTest(true);
                renderer.setScissor(0, 0, window.innerWidth/2, window.innerHeight);
                renderer.setViewport(0, 0, window.innerWidth/2, window.innerHeight);
                _mat.uniforms.ipd.value = 0.0;
                renderer.render(_scene, _cam);

                // Right Lens
                renderer.setScissor(window.innerWidth/2, 0, window.innerWidth/2, window.innerHeight);
                renderer.setViewport(window.innerWidth/2, 0, window.innerWidth/2, window.innerHeight);
                _mat.uniforms.ipd.value = 0.0;
                renderer.render(_scene, _cam);
                
                renderer.setScissorTest(false);
            };
        }

        init();
    <\/script>
</body>
</html>`;
    }
</script>
</body>
</html>
