<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Universal Player</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    
    <!-- Three.js & CSS3DRenderer -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background: #000; color: white; }
        
        /* --- SETUP SCREEN --- */
        #setup { 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; 
            background: #121212; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 20px;
        }
        #setup.hidden { display: none; }
        
        .setup-container {
            width: 100%; max-width: 400px; background: #1e1e1e; border-radius: 16px; padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px;
        }

        h2 { margin: 0 0 5px 0; text-align: center; color: #fff; }
        
        /* Input Rows */
        .input-group { display: flex; flex-direction: column; gap: 8px; border-bottom: 1px solid #333; padding-bottom: 15px; }
        .label-text { font-size: 12px; color: #888; text-transform: uppercase; font-weight: bold; }
        
        /* File Input */
        .file-upload-label {
            background: #333; color: #ddd; padding: 12px; border-radius: 8px; text-align: center; 
            border: 1px dashed #555; cursor: pointer; transition: 0.2s;
        }
        .file-upload-label:active { background: #444; }
        #fileInput { display: none; }

        /* URL Input */
        .url-row { display: flex; gap: 8px; }
        .url-input { flex: 1; padding: 10px; border-radius: 8px; border: 1px solid #444; background: #252525; color: white; }
        .btn-preview { background: #444; color: white; border: none; padding: 0 15px; border-radius: 8px; cursor: pointer; font-weight: bold; }

        /* Unified Preview Window */
        .preview-area {
            background: #000; border-radius: 8px; overflow: hidden; height: 200px; 
            display: flex; align-items: center; justify-content: center; position: relative; border: 1px solid #333;
        }
        .placeholder { position: absolute; color: #555; font-size: 14px; pointer-events: none; }
        
        /* Preview Elements */
        #previewVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        #previewFrame { width: 100%; height: 100%; border: none; background: #fff; display: none; }
        
        /* Enter Button */
        #startBtn {
            background: #007BFF; color: white; border: none; padding: 14px; font-size: 16px; font-weight: bold; 
            border-radius: 8px; cursor: pointer; width: 100%; margin-top: 5px;
        }
        #startBtn:disabled { background: #333; color: #555; cursor: not-allowed; }

        /* --- VR OVERLAY (Original Layout) --- */
        #progressOverlay { 
            position: fixed; bottom: 0; left: 0; right: 0; background: rgba(0, 0, 0, 0.7);
            padding: 8px 0; display: none; z-index: 9999; flex-direction: row;
        }
        #progressOverlay.visible { display: flex; }
        
        .eye-controls { width: 50%; display: flex; flex-direction: column; align-items: center; padding: 0 5px; box-sizing: border-box; }
        
        /* Progress Bar (Only visible in video mode) */
        .progressBar { width: 100%; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; cursor: pointer; margin-bottom: 5px; display: none; }
        .progressBar.active { display: block; }
        .progressFill { height: 100%; background: #007BFF; border-radius: 4px; width: 0%; pointer-events: none; }
        .timeDisplay { font-size: 10px; color: #ccc; margin-bottom: 5px; font-family: monospace; display: none; }
        .timeDisplay.active { display: block; }
        
        .controls-row { display: flex; justify-content: center; gap: 5px; margin-bottom: 4px; width: 100%; }
        
        /* Buttons */
        .btn-icon {
            background: rgba(255,255,255,0.2); border: none; color: #eee; width: 30px; height: 30px; 
            border-radius: 50%; font-size: 12px; display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .btn-pill {
            background: rgba(255,255,255,0.2); border: none; color: #eee; height: 26px; padding: 0 10px; 
            border-radius: 13px; font-size: 10px; font-weight: bold; cursor: pointer;
        }
        .btn-pill.active { background: #007BFF; color: white; }
        .section-label { font-size: 9px; color: #888; text-transform: uppercase; margin: 5px 0 2px 0; font-weight: bold; }
        .btn-wide { background: #007BFF; border: none; color: white; width: 90%; height: 32px; border-radius: 8px; font-size: 12px; font-weight: bold; cursor: pointer; margin-top: 5px; }

        /* Renderers */
        canvas { display: block; z-index: 1; }
        .css-renderer { position: absolute; top: 0; z-index: 2; } /* Sits on top of WebGL */
    </style>
</head>
<body>

    <!-- 1. SETUP SCREEN -->
    <div id="setup">
        <div class="setup-container">
            <h2>VR Player</h2>

            <!-- Video Input -->
            <div class="input-group">
                <span class="label-text">Option A: Local Video</span>
                <label class="file-upload-label" id="fileLabel">Tap to Select File</label>
                <input type="file" id="fileInput" accept="video/*">
            </div>

            <!-- Web Input -->
            <div class="input-group">
                <span class="label-text">Option B: Web URL</span>
                <div class="url-row">
                    <input type="text" id="urlInput" class="url-input" placeholder="https://..." value="https://en.m.wikipedia.org">
                    <button id="previewWebBtn" class="btn-preview">Preview</button>
                </div>
            </div>

            <!-- Single Preview Window -->
            <div class="preview-area">
                <span class="placeholder" id="placeholderText">No Media Selected</span>
                <video id="previewVideo" controls playsinline muted></video>
                <iframe id="previewFrame"></iframe>
            </div>
            
            <button id="startBtn" disabled>ENTER VR</button>
        </div>
    </div>

    <!-- 2. VR CONTROLS OVERLAY -->
    <div id="progressOverlay">
        <!-- Left Eye -->
        <div class="eye-controls">
            <!-- Video Specific Controls -->
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            
            <div class="controls-row video-controls">
                <button class="btn-icon rewind-btn">&laquo;</button>
                <button class="btn-icon play-pause-btn">▶</button>
                <button class="btn-icon forward-btn">&raquo;</button>
            </div>
            
            <div class="section-label">Mode</div>
            <div class="controls-row">
                <button class="btn-pill mode-2d-btn active">2D</button>
                <button class="btn-pill mode-3d-btn">3D</button>
            </div>

            <div class="section-label">Zoom</div>
            <div class="controls-row">
                <button class="btn-icon zoom-out-btn">−</button>
                <button class="btn-pill zoom-reset-btn">100%</button>
                <button class="btn-icon zoom-in-btn">+</button>
            </div>

            <div class="section-label">Distance</div>
            <div class="controls-row">
                <button class="btn-icon dist-dec-btn">−</button>
                <button class="btn-pill dist-reset-btn">RESET</button>
                <button class="btn-icon dist-inc-btn">+</button>
            </div>
            
            <div class="section-label">IPD</div>
            <div class="controls-row">
                <button class="btn-icon pd-dec-btn">&larr;&rarr;</button>
                <button class="btn-pill pd-reset-btn">RESET</button>
                <button class="btn-icon pd-inc-btn">&rarr;&larr;</button>
            </div>

            <button class="btn-wide recenter-btn">RE-CENTER</button>
        </div>

        <!-- Right Eye (Duplicate) -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            <div class="controls-row video-controls">
                <button class="btn-icon rewind-btn">&laquo;</button>
                <button class="btn-icon play-pause-btn">▶</button>
                <button class="btn-icon forward-btn">&raquo;</button>
            </div>
            <div class="section-label">Mode</div>
            <div class="controls-row">
                <button class="btn-pill mode-2d-btn active">2D</button>
                <button class="btn-pill mode-3d-btn">3D</button>
            </div>
            <div class="section-label">Zoom</div>
            <div class="controls-row">
                <button class="btn-icon zoom-out-btn">−</button>
                <button class="btn-pill zoom-reset-btn">100%</button>
                <button class="btn-icon zoom-in-btn">+</button>
            </div>
            <div class="section-label">Distance</div>
            <div class="controls-row">
                <button class="btn-icon dist-dec-btn">−</button>
                <button class="btn-pill dist-reset-btn">RESET</button>
                <button class="btn-icon dist-inc-btn">+</button>
            </div>
            <div class="section-label">IPD</div>
            <div class="controls-row">
                <button class="btn-icon pd-dec-btn">&larr;&rarr;</button>
                <button class="btn-pill pd-reset-btn">RESET</button>
                <button class="btn-icon pd-inc-btn">&rarr;&larr;</button>
            </div>
            <button class="btn-wide recenter-btn">RE-CENTER</button>
        </div>
    </div>

    <!-- SHADERS (Only used for Video Mode) -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>
    <script id="fragmentShaderDistortion" type="x-shader/x-fragment">
        uniform sampler2D tDiffuse; uniform float ipdOffset; uniform float zoomLevel; varying vec2 vUv;
        void main() {
            vec2 c = vec2(0.5); vec2 v = vUv - c; float r2 = dot(v, v);
            vec2 dUV = c + v * (1.0 + r2 * (0.22 + 0.18 * r2)); // Simple Barrel Distortion
            vec2 uv = (dUV - c) / zoomLevel; uv.x += ipdOffset; uv += c;
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) gl_FragColor = vec4(0.0);
            else gl_FragColor = texture2D(tDiffuse, uv);
        }
    </script>

    <script>
        // --- 1. SETUP & UI LOGIC ---
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const previewVideo = document.getElementById('previewVideo');
        const previewFrame = document.getElementById('previewFrame');
        const placeholder = document.getElementById('placeholderText');
        const startBtn = document.getElementById('startBtn');
        const setupDiv = document.getElementById('setup');
        
        let activeSource = null; // 'video' or 'web'
        let videoURL = null;
        let webURL = null;

        // Video Selection
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            activeSource = 'video';
            if (videoURL) URL.revokeObjectURL(videoURL);
            videoURL = URL.createObjectURL(file);
            
            // UI Update
            previewVideo.src = videoURL;
            previewVideo.style.display = 'block';
            previewFrame.style.display = 'none';
            placeholder.style.display = 'none';
            document.getElementById('fileLabel').textContent = file.name;
            startBtn.disabled = false;
        });

        // Web Preview Button
        document.getElementById('previewWebBtn').addEventListener('click', () => {
            const val = urlInput.value.trim();
            if (!val) return;
            activeSource = 'web';
            webURL = val;

            // UI Update
            previewFrame.src = webURL;
            previewFrame.style.display = 'block';
            previewVideo.style.display = 'none';
            previewVideo.pause();
            placeholder.style.display = 'none';
            startBtn.disabled = false;
        });

        // Enter VR
        startBtn.addEventListener('click', async () => {
            if (!activeSource) return;

            // Permission / Fullscreen
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
            }
            const el = document.documentElement;
            if(el.requestFullscreen) el.requestFullscreen();
            if(screen.orientation && screen.orientation.lock) screen.orientation.lock('landscape').catch(()=>{});

            setupDiv.style.display = 'none';
            initVR();
        });


        // --- 2. VR ENGINE ---
        let scene, camera, renderer, effect; // WebGL (Video)
        let cssScene, cssRendererL, cssRendererR, cssGroup; // CSS3D (Web)
        let orientationTracker;
        let videoElement, videoTexture, screenGroup;
        
        // State
        let mode = '2d'; 
        let isPlaying = false;
        
        // Control Defaults
        const defaults = { zoom: 1.0, dist: 3.0, ipd: 0.0 };
        let currentZoom = defaults.zoom;
        let currentDist = defaults.dist;
        let currentIPD = defaults.ipd;

        function initVR() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
            scene.add(camera);

            screenGroup = new THREE.Group();
            scene.add(screenGroup);

            // --- A. VIDEO MODE SETUP ---
            if (activeSource === 'video') {
                videoElement = document.createElement('video');
                videoElement.src = videoURL;
                videoElement.playsinline = true;
                videoElement.loop = false; 
                videoTexture = new THREE.VideoTexture(videoElement);
                videoTexture.minFilter = THREE.LinearFilter;
                
                // Show video UI controls
                document.querySelectorAll('.progressBar, .timeDisplay').forEach(e => e.classList.add('active'));
                videoElement.play().then(() => isPlaying = true);
                
                createVideoScreen(); // Initial Mesh

                // WebGL Renderer with Distortion
                renderer = new THREE.WebGLRenderer({ antialias: false });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
                
                effect = new THREE.StereoEffect(renderer);
                effect.setSize(window.innerWidth, window.innerHeight);
            }

            // --- B. WEB MODE SETUP ---
            if (activeSource === 'web') {
                // Hide video controls
                document.querySelectorAll('.video-controls').forEach(e => e.style.display = 'none');
                
                cssScene = new THREE.Scene();
                cssGroup = new THREE.Group();
                cssScene.add(cssGroup);

                // Create Two Renderers (Left/Right)
                const makeR = (pos) => {
                    const r = new THREE.CSS3DRenderer();
                    r.setSize(window.innerWidth/2, window.innerHeight);
                    r.domElement.className = 'css-renderer';
                    r.domElement.style.left = pos;
                    document.body.appendChild(r.domElement);
                    return r;
                };
                cssRendererL = makeR('0px');
                cssRendererR = makeR('50%');

                // Create Content Objects
                const w = 1024, h = 768;
                const makeObj = () => {
                    const div = document.createElement('div');
                    div.style.width = w+'px'; div.style.height = h+'px'; 
                    div.style.background = 'white'; // CRITICAL: White background to be seen
                    const iframe = document.createElement('iframe');
                    iframe.src = webURL;
                    iframe.style.width='100%'; iframe.style.height='100%'; iframe.style.border='0';
                    div.appendChild(iframe);
                    const o = new THREE.CSS3DObject(div);
                    // Initial scale/pos
                    o.scale.set(0.005 * currentZoom, 0.005 * currentZoom, 0.005 * currentZoom);
                    o.position.set(0, 0, -currentDist);
                    return o;
                };

                const objL = makeObj();
                const objR = makeObj();
                cssGroup.userData = { L: objL, R: objR };
                cssGroup.add(objL); cssGroup.add(objR);
                screenGroup.add(cssGroup); // Link to Recenter logic

                // We still need a dummy WebGL renderer to clear the screen to black
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
            }

            // Tracking
            orientationTracker = new OrientationTracker();
            orientationTracker.connect();

            // Events
            window.addEventListener('resize', onResize);
            document.addEventListener('click', handleGlobalClick);
            document.getElementById('progressOverlay').addEventListener('click', handleControls);
            if(videoElement) videoElement.addEventListener('timeupdate', updateProgress);

            animate();
        }

        // --- 3. RENDERING & UPDATES ---
        
        function createVideoScreen() {
            // Rebuilds the mesh based on Mode, Dist, Zoom
            screenGroup.children.forEach(c => { if(c.isMesh) screenGroup.remove(c); });
            
            const aspect = videoElement ? videoElement.videoWidth/videoElement.videoHeight : 1.77;
            // Base width fixed, height calc
            const w = 6.0 * currentZoom; 
            const h = w / aspect; 
            const geo = new THREE.PlaneGeometry(w, h);
            const z = -currentDist;

            if (mode === '2d') {
                const mat = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
                const m = new THREE.Mesh(geo, mat); m.position.z = z;
                screenGroup.add(m);
            } else {
                // 3D SBS
                const vs = `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`;
                const matL = new THREE.ShaderMaterial({
                    uniforms: { tex: {value:videoTexture} }, vertexShader: vs, side: 2,
                    fragmentShader: `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x*0.5, vUv.y)); }`
                });
                const mL = new THREE.Mesh(geo, matL); mL.position.z = z; mL.layers.set(1);
                screenGroup.add(mL);
                
                const matR = matL.clone();
                matR.fragmentShader = `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x*0.5+0.5, vUv.y)); }`;
                const mR = new THREE.Mesh(geo, matR); mR.position.z = z; mR.layers.set(2);
                screenGroup.add(mR);
            }
        }

        function updateWebTransform() {
            // Updates CSS object based on controls
            if (!cssGroup) return;
            const s = 0.005 * currentZoom;
            const objs = [cssGroup.userData.L, cssGroup.userData.R];
            objs.forEach(o => {
                o.scale.set(s, s, s);
                o.position.z = -currentDist;
            });
            // IPD Simulation for CSS: Shift objects horizontally
            cssGroup.userData.L.position.x = -currentIPD * 2; // Rough approx
            cssGroup.userData.R.position.x = currentIPD * 2; 
        }

        function animate() {
            requestAnimationFrame(animate);
            if(orientationTracker) {
                orientationTracker.update();
                camera.quaternion.copy(orientationTracker.getQuaternion());
            }

            if (activeSource === 'video') {
                effect.render(scene, camera);
            } else {
                // Web Mode
                renderer.clear(); // Black background
                
                // Manually Render CSS Stereo
                // We calculate camera offset manually since we aren't using StereoEffect for CSS
                const halfIPD = 0.03 + (currentIPD * 0.1); // Base IPD + offset
                
                // Left Eye
                camera.position.set(-halfIPD, 0, 0); 
                camera.quaternion.copy(orientationTracker.getQuaternion()); // Rotate
                cssGroup.userData.L.visible = true; cssGroup.userData.R.visible = false;
                cssRendererL.render(cssScene, camera);
                
                // Right Eye
                camera.position.set(halfIPD, 0, 0);
                camera.quaternion.copy(orientationTracker.getQuaternion());
                cssGroup.userData.L.visible = false; cssGroup.userData.R.visible = true;
                cssRendererR.render(cssScene, camera);

                // Reset for next frame logic
                camera.position.set(0,0,0);
            }
        }

        // --- 4. CONTROLS HANDLING ---
        function handleGlobalClick(e) {
            if(e.target.closest('#progressOverlay')) return;
            const ov = document.getElementById('progressOverlay');
            if(ov.classList.contains('visible')) ov.classList.remove('visible');
            else ov.classList.add('visible');
        }

        function handleControls(e) {
            e.stopPropagation();
            const t = e.target.closest('button, .progressBar');
            if(!t) return;
            const cl = t.classList;

            // VIDEO: Seek
            if (cl.contains('progressBar') && activeSource === 'video') {
                const r = t.getBoundingClientRect();
                const p = (e.clientX - r.left)/r.width;
                videoElement.currentTime = p * videoElement.duration;
            }
            // VIDEO: Play/Rewind
            if (cl.contains('play-pause-btn')) { 
                if(isPlaying) videoElement.pause(); else videoElement.play(); 
                isPlaying = !isPlaying; 
            }
            if (cl.contains('rewind-btn')) videoElement.currentTime -= 10;
            if (cl.contains('forward-btn')) videoElement.currentTime += 10;

            // GENERAL: Mode
            if (cl.contains('mode-2d-btn')) mode = '2d';
            if (cl.contains('mode-3d-btn')) mode = '3d';
            
            // GENERAL: Recenter
            if (cl.contains('recenter-btn')) {
                screenGroup.quaternion.copy(camera.quaternion);
            }

            // CONTROLS: Zoom
            if (cl.contains('zoom-in-btn')) currentZoom += 0.1;
            if (cl.contains('zoom-out-btn')) currentZoom -= 0.1;
            if (cl.contains('zoom-reset-btn')) currentZoom = defaults.zoom;

            // CONTROLS: Distance
            if (cl.contains('dist-inc-btn')) currentDist += 0.5;
            if (cl.contains('dist-dec-btn')) currentDist -= 0.5;
            if (cl.contains('dist-reset-btn')) currentDist = defaults.dist;

            // CONTROLS: IPD
            if (cl.contains('pd-inc-btn')) currentIPD += 0.005;
            if (cl.contains('pd-dec-btn')) currentIPD -= 0.005;
            if (cl.contains('pd-reset-btn')) currentIPD = defaults.ipd;

            // Apply Updates
            updateUIState();
            if (activeSource === 'video') {
                createVideoScreen();
                if(effect) {
                    // Update uniforms manually attached to effect
                    // (Requires recreating the shader refs or accessing internals)
                    // Simplified: We just updated globals, the shader reads them in render? 
                    // No, we need to push them.
                    effect.setUniforms(currentIPD, currentZoom);
                }
            } else {
                updateWebTransform();
            }
        }

        function updateUIState() {
            document.querySelectorAll('.mode-2d-btn').forEach(b => b.classList.toggle('active', mode==='2d'));
            document.querySelectorAll('.mode-3d-btn').forEach(b => b.classList.toggle('active', mode==='3d'));
            document.querySelectorAll('.play-pause-btn').forEach(b => b.textContent = isPlaying ? '||' : '▶');
        }

        function updateProgress() {
            if(!videoElement || !videoElement.duration) return;
            const p = (videoElement.currentTime/videoElement.duration)*100;
            document.querySelectorAll('.progressFill').forEach(f => f.style.width = p+'%');
            const fmt = s => { const m=Math.floor(s/60), ss=Math.floor(s%60); return `${m}:${ss.toString().padStart(2,'0')}`; };
            document.querySelectorAll('.timeDisplay').forEach(d => d.textContent = `${fmt(videoElement.currentTime)} / ${fmt(videoElement.duration)}`);
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(effect) effect.setSize(window.innerWidth, window.innerHeight);
            if(cssRendererL) { cssRendererL.setSize(window.innerWidth/2, window.innerHeight); cssRendererR.setSize(window.innerWidth/2, window.innerHeight); }
        }

        // --- 5. HELPERS ---
        function OrientationTracker() {
            this.q = new THREE.Quaternion(); const zee = new THREE.Vector3(0,0,1); const q0=new THREE.Quaternion(), q1=new THREE.Quaternion(-Math.sqrt(0.5),0,0,Math.sqrt(0.5));
            this.getQuaternion = () => this.q;
            this.update = () => {
                if(!this.e) return;
                const a = this.e.alpha ? THREE.Math.degToRad(this.e.alpha) : 0;
                const b = this.e.beta ? THREE.Math.degToRad(this.e.beta) : 0;
                const g = this.e.gamma ? THREE.Math.degToRad(this.e.gamma) : 0;
                const o = (screen.orientation?screen.orientation.angle:window.orientation||0) * (Math.PI/180);
                this.q.setFromEuler(new THREE.Euler(b,a,-g,'YXZ')).multiply(q1).multiply(q0.setFromAxisAngle(zee,-o));
            };
            this.connect = () => { window.addEventListener('deviceorientation', e=>this.e=e); };
        }

        THREE.StereoEffect = function(renderer) {
            const _stereo = new THREE.StereoCamera(); _stereo.aspect = 0.5;
            const _tL = new THREE.WebGLRenderTarget(512,512), _tR = new THREE.WebGLRenderTarget(512,512);
            const _mat = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: {value:null}, zoomLevel: {value:1.0}, ipdOffset:{value:0} },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderDistortion').textContent
            });
            const _scene = new THREE.Scene(); _scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2), _mat));
            const _cam = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
            
            this.setSize = (w,h) => { renderer.setSize(w,h); _tL.setSize(w,h); _tR.setSize(w,h); };
            this.setUniforms = (ipd, zoom) => { _mat.uniforms.ipdOffset.value = ipd; _mat.uniforms.zoomLevel.value = zoom; };
            
            this.render = (scene, camera) => {
                scene.updateMatrixWorld(); _stereo.update(camera);
                this.setUniforms(currentIPD, currentZoom); // Push globals
                
                renderer.setRenderTarget(_tL); renderer.clear(); renderer.render(scene, _stereo.cameraL);
                renderer.setRenderTarget(_tR); renderer.clear(); renderer.render(scene, _stereo.cameraR);
                renderer.setRenderTarget(null); 
                
                const w = window.innerWidth, h = window.innerHeight; renderer.setScissorTest(true);
                renderer.setScissor(0,0,w/2,h); renderer.setViewport(0,0,w/2,h);
                _mat.uniforms.tDiffuse.value = _tL.texture; _mat.uniforms.ipdOffset.value = currentIPD;
                renderer.render(_scene, _cam);
                
                renderer.setScissor(w/2,0,w/2,h); renderer.setViewport(w/2,0,w/2,h);
                _mat.uniforms.tDiffuse.value = _tR.texture; _mat.uniforms.ipdOffset.value = -currentIPD;
                renderer.render(_scene, _cam);
                renderer.setScissorTest(false);
            };
        };
    </script>
</body>
</html>
