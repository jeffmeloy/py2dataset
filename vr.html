<!DOCTYPE html>
<html lang="en">
<head>
    <title>VR Player & Browser</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#000000">
    <!-- Core Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- CSS3DRenderer: REQUIRED for displaying iframes -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background: #000; color: white; }
        
        /* --- SETUP SCREEN --- */
        #setup { 
            position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; 
            background: #121212; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            padding: 20px;
        }
        #setup.hidden { display: none; }
        
        .setup-container {
            width: 100%; max-width: 360px;
            background: #1e1e1e;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; gap: 15px;
        }

        h2 { margin: 0 0 10px 0; text-align: center; font-size: 22px; color: #fff; }

        .file-upload-label {
            display: block; background: #333; color: #ddd; width: 100%; padding: 10px;
            border-radius: 8px; text-align: center; font-weight: 500; border: 1px dashed #555;
            cursor: pointer; box-sizing: border-box; transition: background 0.2s;
        }
        .file-upload-label:active { background: #444; }
        #fileInput { display: none; }

        /* New URL Input Styling */
        .url-input {
            width: 100%; padding: 12px; border-radius: 8px; border: 1px solid #444;
            background: #252525; color: white; box-sizing: border-box;
        }

        .preview-area {
            background: #000; border-radius: 8px; overflow: hidden; 
            height: 150px; display: flex; align-items: center; justify-content: center;
            position: relative; border: 1px solid #333;
        }
        #testVideo { width: 100%; height: 100%; object-fit: contain; display: none; }
        #testVideo.active { display: block; }
        .placeholder-text { position: absolute; color: #555; font-size: 14px; pointer-events: none; }
        .preview-area.has-video .placeholder-text { display: none; }

        #status { font-size: 13px; color: #666; text-align: center; height: 16px; }
        #status.success { color: #4CAF50; }
        
        button.primary {
            background: #007BFF; color: white; border: none; padding: 14px;
            font-size: 16px; font-weight: bold; border-radius: 8px; cursor: pointer;
            width: 100%; transition: transform 0.1s;
        }
        button.primary:active { transform: scale(0.98); background: #0056b3; }
        button:disabled { background: #333; color: #555; cursor: not-allowed; transform: none; }

        /* --- VR OVERLAY (COMPACT) --- */
        #progressOverlay { 
            position: fixed; bottom: 0; left: 0; right: 0; 
            background: rgba(0, 0, 0, 0.6);
            padding: 6px 0; 
            display: none; 
            z-index: 9999; /* Higher than CSS3D */
            transition: opacity 0.3s;
            max-height: 100vh;
            overflow-y: auto;
        }
        #progressOverlay.visible { display: flex; }
        #progressOverlay.fading { opacity: 0; }
        .eye-controls { 
            width: 50%; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            padding: 0 4px; 
            box-sizing: border-box; 
        }
        
        .progressBar { width: 100%; height: 10px; background: rgba(255,255,255,0.2); border-radius: 5px; cursor: pointer; margin-bottom: 2px; position: relative; }
        .progressFill { height: 100%; background: #007BFF; border-radius: 5px; width: 0%; pointer-events: none; }
        .timeDisplay { font-size: 10px; color: #ccc; margin-bottom: 4px; font-family: monospace; }
        
        .controls-row { display: flex; justify-content: center; gap: 6px; margin-bottom: 3px; width: 100%; }
        
        .btn-icon {
            background: rgba(255,255,255,0.2); border: none; color: #eee;
            width: 32px; height: 32px; border-radius: 50%; font-size: 12px; font-weight: bold;
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            flex-shrink: 0; transition: background 0.1s;
        }
        .btn-icon:active { background: #007BFF; }
        
        .btn-pill {
            background: rgba(255,255,255,0.2); border: none; color: #eee;
            height: 28px; padding: 0 12px; border-radius: 14px; font-size: 10px; cursor: pointer;
            white-space: nowrap; flex-shrink: 0; font-weight: bold; transition: background 0.2s;
        }
        .btn-pill:active { background: #007BFF; }
        .btn-pill.active { background: #007BFF; color: white; }

        .btn-wide {
            background: #007BFF; border: none; color: white;
            width: 90%; height: 36px; border-radius: 8px; font-size: 12px; font-weight: bold;
            cursor: pointer; margin-top: 4px;
        }
        .btn-wide:active { background: #0056b3; transform: scale(0.98); }

        .section-label {
            font-size: 9px; color: #888; text-transform: uppercase; letter-spacing: 0.5px; margin: 4px 0 2px 0; font-weight: bold;
        }
        
        /* CSS3D RENDERER CONTAINERS */
        /* Must sit on top of canvas, but below Overlay */
        .css-renderer-container {
            position: absolute;
            top: 0;
            pointer-events: none; /* Let clicks pass through to overlay */
            overflow: hidden;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="setup">
        <div class="setup-container">
            <h2>VR Setup</h2>
            <label for="fileInput" class="file-upload-label" id="fileLabel">1. Select Video (Optional)</label>
            <input type="file" id="fileInput" accept="video/*">

            <div class="preview-area" id="previewArea">
                <span class="placeholder-text">Video Preview</span>
                <video id="testVideo" controls playsinline webkit-playsinline></video>
            </div>
            
            <input type="text" id="urlInput" class="url-input" placeholder="2. Or Enter Website URL (https://...)">

            <div id="status">Ready</div>
            <button id="startBtn" class="primary">ENTER VR</button>
        </div>
    </div>

    <div id="progressOverlay">
        <!-- LEFT EYE UI -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            
            <div class="controls-row">
                <button class="btn-icon rewind-btn">&lsaquo;</button>
                <button class="btn-icon play-pause-btn">▶</button>
                <button class="btn-icon forward-btn">&rsaquo;</button>
            </div>
            
            <div class="controls-row">
                <button class="btn-pill mode-2d-btn active">2D</button>
                <button class="btn-pill mode-3d-btn">3D</button>
                <button class="btn-pill web-toggle-btn">WEB</button>
            </div>
            
            <div class="section-label">Screen</div>
            <div class="controls-row">
                <button class="btn-icon zoom-out-btn">−</button>
                <button class="btn-pill zoom-reset-btn">ZOOM</button>
                <button class="btn-icon zoom-in-btn">+</button>
            </div>

            <div class="section-label">Distance & IPD</div>
            <div class="controls-row">
                <button class="btn-icon dist-dec-btn">D-</button>
                <button class="btn-icon dist-inc-btn">D+</button>
                <button class="btn-icon pd-dec-btn">IPD-</button>
                <button class="btn-icon pd-inc-btn">IPD+</button>
            </div>
            <button class="btn-wide recenter-btn">RE-CENTER</button>
        </div>
        
        <!-- RIGHT EYE UI (Duplicate) -->
        <div class="eye-controls">
            <div class="progressBar"><div class="progressFill"></div></div>
            <div class="timeDisplay">0:00 / 0:00</div>
            
            <div class="controls-row">
                <button class="btn-icon rewind-btn">&lsaquo;</button>
                <button class="btn-icon play-pause-btn">▶</button>
                <button class="btn-icon forward-btn">&rsaquo;</button>
            </div>
            
            <div class="controls-row">
                <button class="btn-pill mode-2d-btn active">2D</button>
                <button class="btn-pill mode-3d-btn">3D</button>
                <button class="btn-pill web-toggle-btn">WEB</button>
            </div>
            
            <div class="section-label">Screen</div>
            <div class="controls-row">
                <button class="btn-icon zoom-out-btn">−</button>
                <button class="btn-pill zoom-reset-btn">ZOOM</button>
                <button class="btn-icon zoom-in-btn">+</button>
            </div>

            <div class="section-label">Distance & IPD</div>
            <div class="controls-row">
                <button class="btn-icon dist-dec-btn">D-</button>
                <button class="btn-icon dist-inc-btn">D+</button>
                <button class="btn-icon pd-dec-btn">IPD-</button>
                <button class="btn-icon pd-inc-btn">IPD+</button>
            </div>
            <button class="btn-wide recenter-btn">RE-CENTER</button>
        </div>
    </div>

    <!-- VERTEX SHADER -->
    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
    </script>

    <!-- FRAGMENT SHADER (LENS DISTORTION) -->
    <script id="fragmentShaderDistortion" type="x-shader/x-fragment">
        uniform sampler2D tDiffuse;
        uniform vec2 texSize; 
        uniform float k1;
        uniform float k2;
        uniform float ipdOffset; 
        uniform float zoomLevel;
        varying vec2 vUv;
        const float PI = 3.14159265359;
        
        // Lanczos sampling logic
        float sinc(float x) { if (abs(x) < 0.0001) return 1.0; float a = PI * x; return sin(a) / a; }
        float lanczosWeight(float x) { if (abs(x) >= 2.0) return 0.0; return sinc(x) * sinc(x * 0.5); }
        vec4 textureLanczos(sampler2D sampler, vec2 texCoords, vec2 texSize) {
            vec2 invTexSize = 1.0 / texSize; vec2 pos = texCoords * texSize; vec2 ipos = floor(pos - 0.5) + 0.5; vec2 f = pos - ipos; 
            vec4 wX = vec4(lanczosWeight(1.0 + f.x), lanczosWeight(f.x), lanczosWeight(1.0 - f.x), lanczosWeight(2.0 - f.x));
            vec4 wY = vec4(lanczosWeight(1.0 + f.y), lanczosWeight(f.y), lanczosWeight(1.0 - f.y), lanczosWeight(2.0 - f.y));
            wX /= dot(wX, vec4(1.0)); wY /= dot(wY, vec4(1.0));
            vec4 row0 = texture2D(sampler, (ipos + vec2(-1, -1)) * invTexSize) * wX.x + texture2D(sampler, (ipos + vec2( 0, -1)) * invTexSize) * wX.y + texture2D(sampler, (ipos + vec2( 1, -1)) * invTexSize) * wX.z + texture2D(sampler, (ipos + vec2( 2, -1)) * invTexSize) * wX.w;
            vec4 row1 = texture2D(sampler, (ipos + vec2(-1,  0)) * invTexSize) * wX.x + texture2D(sampler, (ipos + vec2( 0,  0)) * invTexSize) * wX.y + texture2D(sampler, (ipos + vec2( 1,  0)) * invTexSize) * wX.z + texture2D(sampler, (ipos + vec2( 2,  0)) * invTexSize) * wX.w;
            vec4 row2 = texture2D(sampler, (ipos + vec2(-1,  1)) * invTexSize) * wX.x + texture2D(sampler, (ipos + vec2( 0,  1)) * invTexSize) * wX.y + texture2D(sampler, (ipos + vec2( 1,  1)) * invTexSize) * wX.z + texture2D(sampler, (ipos + vec2( 2,  1)) * invTexSize) * wX.w;
            vec4 row3 = texture2D(sampler, (ipos + vec2(-1,  2)) * invTexSize) * wX.x + texture2D(sampler, (ipos + vec2( 0,  2)) * invTexSize) * wX.y + texture2D(sampler, (ipos + vec2( 1,  2)) * invTexSize) * wX.z + texture2D(sampler, (ipos + vec2( 2,  2)) * invTexSize) * wX.w;
            return row0 * wY.x + row1 * wY.y + row2 * wY.z + row3 * wY.w;
        }
        vec2 distort(vec2 p) {
            vec2 center = vec2(0.5, 0.5); vec2 v = p - center; float r2 = dot(v, v);
            return center + v * (1.0 + r2 * (k1 + k2 * r2));
        }
        void main() {
            vec2 eyeCenter = vec2(0.5, 0.5); vec2 distortedUV = distort(vUv);
            vec2 uv = (distortedUV - eyeCenter) / zoomLevel; uv.x += ipdOffset; uv += eyeCenter;
            if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) { gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); } 
            else { gl_FragColor = textureLanczos(tDiffuse, uv, texSize); }
        }
    </script>

    <script>
        // --- INPUTS ---
        const fileInput = document.getElementById('fileInput');
        const fileLabel = document.getElementById('fileLabel');
        const urlInput = document.getElementById('urlInput');
        const testVideo = document.getElementById('testVideo');
        const previewArea = document.getElementById('previewArea');
        const startBtn = document.getElementById('startBtn');
        const setupDiv = document.getElementById('setup');
        const status = document.getElementById('status');
        
        // --- OVERLAY UI ---
        const progressOverlay = document.getElementById('progressOverlay');
        const progressFills = document.querySelectorAll('.progressFill');
        const timeDisplays = document.querySelectorAll('.timeDisplay');
        const playPauseBtns = document.querySelectorAll('.play-pause-btn');
        const mode2dBtns = document.querySelectorAll('.mode-2d-btn');
        const mode3dBtns = document.querySelectorAll('.mode-3d-btn');
        const webToggleBtns = document.querySelectorAll('.web-toggle-btn');

        // --- CORE VARIABLES ---
        let camera, scene, renderer, effect;
        let video, videoTexture, orientationTracker;
        let screenGroup; 
        
        // --- CSS3D VARIABLES (NEW) ---
        let cssRendererL, cssRendererR, cssScene;
        let cssObjectL, cssObjectR;
        let isWebActive = false;
        let targetWebURL = "";

        // --- STATE ---
        let mode = '2d', isPlaying = false, videoURL = null;
        let hideOverlayTimer = null;
        let currentZoomLevel = 1.0; 
        let userIPDOffset = 0.0; 
        let screenDistance = 3.0;
        const defaultWidth = 6.0; 
        let screenMeshes = [];

        // --- SETUP LISTENERS ---
        fileInput.addEventListener('change', handleFileSelect);
        startBtn.addEventListener('click', startVR);

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;
            fileLabel.textContent = file.name; 
            if (videoURL) URL.revokeObjectURL(videoURL);
            videoURL = URL.createObjectURL(file);
            testVideo.src = videoURL;
            testVideo.classList.add('active'); 
            previewArea.classList.add('has-video'); 
            testVideo.addEventListener('loadedmetadata', function() {
                status.textContent = `Video Ready: ${testVideo.videoWidth}x${testVideo.videoHeight}`;
                status.className = 'status success';
            }, { once: true });
        }

        async function startVR() {
            // Determine what we are playing
            targetWebURL = urlInput.value.trim();
            
            // Validation
            if (!videoURL && !targetWebURL) {
                status.textContent = "Please select a file OR enter a URL.";
                return;
            }

            testVideo.pause(); 

            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
            }

            const elem = document.documentElement;
            if (elem.requestFullscreen) elem.requestFullscreen();
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }

            setTimeout(() => {
                setupDiv.classList.add('hidden');
                initVR();
            }, 100);
        }

        function initVR() {
            // 1. SETUP THREE.JS SCENE
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            scene.add(camera); 
            screenGroup = new THREE.Group();
            scene.add(screenGroup);

            // 2. SETUP VIDEO (If present)
            if (videoURL) {
                setupVideoTexture();
            } else {
                // If no video, create a dummy black texture so shaders don't crash
                createDummyVideo();
            }

            // 3. SETUP WEB RENDERERS (If URL present)
            if (targetWebURL) {
                setupWebBrowser();
                isWebActive = true;
                webToggleBtns.forEach(b => b.classList.add('active'));
            } else {
                webToggleBtns.forEach(b => b.classList.remove('active'));
            }

            // 4. SETUP RENDERER & STEREO EFFECT
            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.zIndex = 0;
            document.body.appendChild(renderer.domElement);

            createScreenMeshes();

            effect = new THREE.StereoEffect(renderer, video); // Custom stereo logic
            effect.setSize(window.innerWidth, window.innerHeight);

            // 5. TRACKING & EVENTS
            orientationTracker = new OrientationTracker();
            orientationTracker.connect();

            window.addEventListener('resize', onResize);
            document.addEventListener('click', toggleOverlay);
            if(video) video.addEventListener('timeupdate', updateProgress);
            progressOverlay.addEventListener('click', handleControls);

            setTimeout(() => recenterScreen(), 500);
            showOverlay();
            
            if (video && videoURL) {
                video.play().then(() => {
                    isPlaying = true;
                    updatePlayPauseButtons();
                }).catch(console.error);
            }

            animate();
        }

        function setupVideoTexture() {
            video = document.createElement('video');
            video.src = videoURL;
            video.loop = false;
            video.muted = false;
            video.playsinline = true;
            video.setAttribute('webkit-playsinline', '');
            
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.LinearFilter;
            videoTexture.magFilter = THREE.LinearFilter;
        }

        function createDummyVideo() {
            // Create a 1x1 black canvas for the texture
            const canvas = document.createElement('canvas');
            canvas.width = 2; canvas.height = 2;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black'; ctx.fillRect(0,0,2,2);
            videoTexture = new THREE.CanvasTexture(canvas);
            // Dummy video object to satisfy logic
            video = { videoWidth: 1920, videoHeight: 1080, duration: 1, currentTime: 0, play:()=>{}, pause:()=>{}, addEventListener:()=>{} };
        }

        function setupWebBrowser() {
            // We need TWO CSS renderers for Stereo (Side-by-side)
            // Left Eye Renderer
            cssRendererL = new THREE.CSS3DRenderer();
            cssRendererL.setSize(window.innerWidth / 2, window.innerHeight);
            cssRendererL.domElement.className = 'css-renderer-container';
            cssRendererL.domElement.style.left = '0px';
            document.body.appendChild(cssRendererL.domElement);

            // Right Eye Renderer
            cssRendererR = new THREE.CSS3DRenderer();
            cssRendererR.setSize(window.innerWidth / 2, window.innerHeight);
            cssRendererR.domElement.className = 'css-renderer-container';
            cssRendererR.domElement.style.left = '50%'; // Right half
            document.body.appendChild(cssRendererR.domElement);

            // CSS Scene
            cssScene = new THREE.Scene();

            // Create Iframe Content
            const w = 1024; const h = 768;
            
            function makeIframeObj(xOffset) {
                const div = document.createElement('div');
                div.style.width = w + 'px'; div.style.height = h + 'px'; div.style.background = '#fff';
                const iframe = document.createElement('iframe');
                iframe.style.width = '100%'; iframe.style.height = '100%'; iframe.style.border = '0';
                iframe.src = targetWebURL;
                div.appendChild(iframe);
                const obj = new THREE.CSS3DObject(div);
                // Scale down to match world units roughly
                obj.scale.set(0.005, 0.005, 0.005);
                // Position similar to video screen
                obj.position.set(xOffset, 0, -3.0); 
                return obj;
            }

            // We create two distinct objects for parallax
            // Note: CSS3D doesn't share DOM elements well, better to duplicate logic or create two DOM trees
            // Actually, we can add the SAME object to the scene, but render it from different camera angles.
            // BUT for correct IPD parallax in CSS3D, we usually need two objects or move the object. 
            // Simplest robust method: Two objects.
            
            cssObjectL = makeIframeObj(0); 
            cssObjectR = makeIframeObj(0); // Position is modified by camera view
            
            // Add to a group we can rotate/recenter
            const cssGroup = new THREE.Group();
            cssGroup.add(cssObjectL);
            cssGroup.add(cssObjectR);
            cssScene.add(cssGroup);
            
            // Sync rotation with screenGroup (video)
            screenGroup.add(cssGroup); // Parenting it ensures it moves with re-center
        }

        function createScreenMeshes() {
            screenMeshes.forEach(mesh => {
                screenGroup.remove(mesh);
                if(mesh.geometry) mesh.geometry.dispose();
                if(mesh.material) mesh.material.dispose();
            });
            screenMeshes = [];

            const vidW = video.videoWidth || 1920;
            const vidH = video.videoHeight || 1080;
            const aspect = mode === '3d' ? (vidW / 2) / vidH : vidW / vidH;
            
            const width = defaultWidth; // Fixed width
            const height = width / aspect;
            const geometry = new THREE.PlaneGeometry(width, height);

            // Standard Mesh Creation (Same as before)
            // ... (Left/Right Mesh logic identical to previous code)
            if (mode === '2d') {
                const material = new THREE.MeshBasicMaterial({ map: videoTexture, side: THREE.DoubleSide });
                const screenMesh = new THREE.Mesh(geometry, material);
                screenMesh.position.set(0, 0, -screenDistance);
                screenGroup.add(screenMesh);
                screenMeshes.push(screenMesh);
            } else {
                // 3D Shader Setup
                const matL = new THREE.ShaderMaterial({
                    uniforms: { tex: { value: videoTexture } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x * 0.5, vUv.y)); }`,
                    side: THREE.DoubleSide
                });
                const screenL = new THREE.Mesh(geometry, matL);
                screenL.position.set(0, 0, -screenDistance);
                screenL.layers.set(1);
                screenGroup.add(screenL);
                screenMeshes.push(screenL);

                const matR = new THREE.ShaderMaterial({
                    uniforms: { tex: { value: videoTexture } },
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `uniform sampler2D tex; varying vec2 vUv; void main() { gl_FragColor = texture2D(tex, vec2(vUv.x * 0.5 + 0.5, vUv.y)); }`,
                    side: THREE.DoubleSide
                });
                const screenR = new THREE.Mesh(geometry, matR);
                screenR.position.set(0, 0, -screenDistance);
                screenR.layers.set(2);
                screenGroup.add(screenR);
                screenMeshes.push(screenR);
            }
        }

        function updateScreenMeshes() {
            if (!videoTexture) return;
            createScreenMeshes();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // 1. Update Orientation
            if (orientationTracker) {
                orientationTracker.update();
                camera.quaternion.copy(orientationTracker.getQuaternion());
            }

            // 2. Render Video (WebGL) with Distortion
            if (effect) effect.render(scene, camera);

            // 3. Render Browser (CSS3D) on top
            if (isWebActive && cssRendererL && cssRendererR) {
                // We need to match the camera logic from StereoEffect
                // StereoEffect calculates eye positions internally. We need to grab them or approximate.
                // The easiest way to sync perfectly is to access the cameras generated by StereoEffect
                const stereo = effect.getStereoCamera(); // Modified StereoEffect below exposes this
                
                // Toggle visibility so left renderer only draws left object
                cssObjectL.visible = true; 
                cssObjectR.visible = false;
                cssRendererL.render(cssScene, stereo.cameraL);

                cssObjectL.visible = false;
                cssObjectR.visible = true;
                cssRendererR.render(cssScene, stereo.cameraR);
                
                // Restore visibility
                cssObjectL.visible = true;
                cssObjectR.visible = true;
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            effect.setSize(window.innerWidth, window.innerHeight);
            if(cssRendererL) cssRendererL.setSize(window.innerWidth / 2, window.innerHeight);
            if(cssRendererR) cssRendererR.setSize(window.innerWidth / 2, window.innerHeight);
        }

        // --- CONTROLS LOGIC (Preserved) ---
        function updatePlayPauseButtons() {
            playPauseBtns.forEach(btn => { btn.textContent = isPlaying ? '||' : '▶'; });
        }
        function togglePlayPause() {
            if (!video || !videoURL) return;
            if (isPlaying) { video.pause(); isPlaying = false; } else { video.play(); isPlaying = true; }
            updatePlayPauseButtons(); showOverlay();
        }
        function toggleOverlay(e) {
            if (e.target.closest('button, .progressBar')) return;
            if (progressOverlay.classList.contains('visible')) hideOverlay(); else showOverlay();
        }
        function showOverlay() {
            progressOverlay.classList.add('visible'); progressOverlay.classList.remove('fading');
            if (hideOverlayTimer) clearTimeout(hideOverlayTimer);
            hideOverlayTimer = setTimeout(() => { if (isPlaying) hideOverlay(); }, 4000);
        }
        function hideOverlay() {
            progressOverlay.classList.add('fading');
            setTimeout(() => { progressOverlay.classList.remove('visible'); }, 300);
        }
        function recenterScreen() {
            screenGroup.quaternion.copy(camera.quaternion);
            showOverlay();
        }
        function toggleWeb() {
            if (!targetWebURL) return;
            isWebActive = !isWebActive;
            webToggleBtns.forEach(b => b.classList.toggle('active', isWebActive));
            if(cssRendererL) cssRendererL.domElement.style.display = isWebActive ? 'block' : 'none';
            if(cssRendererR) cssRendererR.domElement.style.display = isWebActive ? 'block' : 'none';
        }

        // --- GENERIC CONTROL HANDLER ---
        function handleControls(e) {
            e.stopPropagation();
            const target = e.target.closest('button, .progressBar');
            if (!target) return;
            
            // ... (Existing seek logic) ...
            if (target.matches('.progressBar')) { 
                if(!videoURL) return;
                const rect = target.getBoundingClientRect();
                const pos = (e.clientX - rect.left) / rect.width;
                video.currentTime = pos * video.duration; showOverlay();
                return;
            }

            const cl = target.classList;
            
            if (cl.contains('play-pause-btn')) togglePlayPause();
            else if (cl.contains('web-toggle-btn')) toggleWeb(); // NEW
            
            else if (cl.contains('mode-2d-btn')) { mode = '2d'; updateScreenMeshes(); mode2dBtns.forEach(b=>b.classList.add('active')); mode3dBtns.forEach(b=>b.classList.remove('active')); }
            else if (cl.contains('mode-3d-btn')) { mode = '3d'; updateScreenMeshes(); mode2dBtns.forEach(b=>b.classList.remove('active')); mode3dBtns.forEach(b=>b.classList.add('active')); }

            else if (cl.contains('recenter-btn')) recenterScreen();

            // Zoom/Dist/IPD logic (Simplified for length)
            else if (cl.contains('zoom-in-btn')) { currentZoomLevel+=0.1; }
            else if (cl.contains('zoom-out-btn')) { currentZoomLevel-=0.1; }
            else if (cl.contains('dist-inc-btn')) { screenDistance+=0.5; updateScreenMeshes(); }
            else if (cl.contains('dist-dec-btn')) { screenDistance-=0.5; updateScreenMeshes(); }
            else if (cl.contains('pd-inc-btn')) { userIPDOffset+=0.005; }
            else if (cl.contains('pd-dec-btn')) { userIPDOffset-=0.005; }
            
            showOverlay();
        }

        function updateProgress() {
            if (!video || !video.duration) return;
            const percent = (video.currentTime / video.duration) * 100;
            progressFills.forEach(fill => { fill.style.width = percent + '%'; });
            // ... time formatting ...
        }

        // --- TRACKER ---
        function OrientationTracker() {
            this.deviceOrientation = {}; this.screenOrientation = 0; this.enabled = false;
            const _euler = new THREE.Euler(); const _deviceQ = new THREE.Quaternion(); const _q0 = new THREE.Quaternion(); const _q1 = new THREE.Quaternion(-Math.sqrt(0.5), 0, 0, Math.sqrt(0.5)); const _zee = new THREE.Vector3(0, 0, 1); 
            this.getQuaternion = function() { return _deviceQ; };
            const onEvent = (e) => { this.deviceOrientation = e; };
            const onScreen = () => { this.screenOrientation = (screen.orientation && typeof screen.orientation.angle === 'number') ? screen.orientation.angle : (window.orientation || 0); };
            this.connect = function() { onScreen(); window.addEventListener('orientationchange', onScreen); window.addEventListener('deviceorientation', onEvent); this.enabled = true; };
            this.update = function() {
                if (!this.enabled) return;
                const device = this.deviceOrientation; 
                if (!device || device.alpha === null) return;
                const alpha = device.alpha ? THREE.MathUtils.degToRad(device.alpha) : 0;
                const beta = device.beta ? THREE.MathUtils.degToRad(device.beta) : 0;
                const gamma = device.gamma ? THREE.MathUtils.degToRad(device.gamma) : 0;
                const orient = this.screenOrientation ? THREE.MathUtils.degToRad(this.screenOrientation) : 0;
                _euler.set(beta, alpha, -gamma, 'YXZ'); _deviceQ.setFromEuler(_euler); _deviceQ.multiply(_q1); _deviceQ.multiply(_q0.setFromAxisAngle(_zee, -orient));
            };
        }

        // --- MODIFIED STEREO EFFECT ---
        // We modify this to allow access to the cameras for CSS3D syncing
        THREE.StereoEffect = function(renderer, videoElement) {
            const _stereo = new THREE.StereoCamera(); 
            _stereo.aspect = 0.5;
            this.getStereoCamera = function() { return _stereo; }; // EXPOSE THIS

            const dpr = window.devicePixelRatio || 1;
            const videoW = videoElement && videoElement.videoWidth ? videoElement.videoWidth : 1920;
            const videoH = videoElement && videoElement.videoHeight ? videoElement.videoHeight : 1080;
            // Limit render target size for performance
            let rtWidth = Math.min(Math.max(window.innerWidth * dpr, videoW), 4096);
            let rtHeight = Math.min(Math.max(window.innerHeight * dpr, videoH), 4096);
            
            let renderTargetL = new THREE.WebGLRenderTarget(rtWidth, rtHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter });
            let renderTargetR = new THREE.WebGLRenderTarget(rtWidth, rtHeight, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter });
            
            const distortionMaterial = new THREE.ShaderMaterial({
                uniforms: { tDiffuse: { value: null }, texSize: { value: new THREE.Vector2(rtWidth, rtHeight) }, k1: { value: 0.22 }, k2: { value: 0.18 }, ipdOffset: { value: 0.0 }, zoomLevel: { value: 1.0 } },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderDistortion').textContent
            });
            const quadMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), distortionMaterial);
            const orthoScene = new THREE.Scene(); const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
            orthoScene.add(quadMesh); const sizeVec = new THREE.Vector2();
            
            this.setSize = function(width, height) {
                renderer.setSize(width, height);
                // logic to resize targets if window gets huge omitted for brevity
            };
            this.render = function(scene, camera) {
                scene.updateMatrixWorld(); _stereo.update(camera);
                renderer.getSize(sizeVec); const halfWidth = sizeVec.width * 0.5;
                
                // Hide web layer from WebGL pass
                if(cssRendererL) cssRendererL.domElement.style.visibility = 'hidden'; 
                if(cssRendererR) cssRendererR.domElement.style.visibility = 'hidden';

                if (mode === '3d') { _stereo.cameraL.layers.set(1); _stereo.cameraR.layers.set(2); } 
                else { _stereo.cameraL.layers.set(0); _stereo.cameraR.layers.set(0); }
                
                renderer.setRenderTarget(renderTargetL); renderer.clear(); renderer.render(scene, _stereo.cameraL);
                renderer.setRenderTarget(renderTargetR); renderer.clear(); renderer.render(scene, _stereo.cameraR);
                renderer.setRenderTarget(null); renderer.clear(); renderer.setScissorTest(true);
                
                distortionMaterial.uniforms.zoomLevel.value = currentZoomLevel;
                distortionMaterial.uniforms.ipdOffset.value = userIPDOffset; 
                distortionMaterial.uniforms.tDiffuse.value = renderTargetL.texture;
                renderer.setScissor(0, 0, halfWidth, sizeVec.height); renderer.setViewport(0, 0, halfWidth, sizeVec.height);
                renderer.render(orthoScene, orthoCamera);
                
                distortionMaterial.uniforms.ipdOffset.value = -userIPDOffset;
                distortionMaterial.uniforms.tDiffuse.value = renderTargetR.texture;
                renderer.setScissor(halfWidth, 0, halfWidth, sizeVec.height); renderer.setViewport(halfWidth, 0, halfWidth, sizeVec.height);
                renderer.render(orthoScene, orthoCamera);
                renderer.setScissorTest(false);

                // Show web layer again
                if(isWebActive && cssRendererL) {
                    cssRendererL.domElement.style.visibility = 'visible';
                    cssRendererR.domElement.style.visibility = 'visible';
                }
            };
        };
    </script>
</body>
</html>
